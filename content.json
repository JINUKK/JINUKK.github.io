{"meta":{"title":"KOO|디벨로그","subtitle":"Develop & Sabjil Log","description":"What I learned","author":"JINWOOK KOO","url":"http://JINUKK.github.io","root":"/"},"pages":[{"title":"about","date":"2019-04-29T10:11:33.000Z","updated":"2019-06-21T05:57:49.654Z","comments":true,"path":"about/index.html","permalink":"http://JINUKK.github.io/about/index.html","excerpt":"","text":"JINWOOK KOO Python Django"}],"posts":[{"title":"2019.07.18 Data Structure and Algorithm Study","slug":"190718-DSAA-Study","date":"2019-07-18T07:41:57.000Z","updated":"2019-07-21T07:57:11.766Z","comments":true,"path":"2019/07/18/190718-DSAA-Study/","link":"","permalink":"http://JINUKK.github.io/2019/07/18/190718-DSAA-Study/","excerpt":"","text":"완전 탐색(Brute-force Search) 알고리즘 문제알고리즘 해결 전략 1권 p.157 소풍을 간 학생들을 두 명씩 짝 지어 행동하게 하려 한다. 서로 친구인 경우에만 짝을 지어야 한다. 서로 친구인 경우의 쌍이 주어질 때, 학생들을 짝 지을 수 있는 방법의 수를 구현해보자. 데이터 개수 n은 항상 짝수이다.1234567891011121314151617181920212223242526272829303132333435# 조건n = 4friends = [[False for _ in range(n)] for _ in range(n)]friends[0][1] = friends[1][0] = Truefriends[1][2] = friends[2][1] = Truefriends[2][3] = friends[3][2] = Truefriends[3][0] = friends[0][3] = Truefriends[0][2] = friends[2][0] = Truefriends[1][3] = friends[3][1] = Truehas_pair = [False for _ in range(n)]# 재귀에서 가장 중요한 것은 계산되는 데이터의 개수가 점점 줄어들어야 한다는 것이다.def solve(has_pair): # base case first = None for i in range(n): if has_pair[i] == False: first = i break if first == None: return 1 ret = 0 for student in range(first+1, n): if has_pair[student] == False and friends[first][student] == True: has_pair[student] = has_pair[first] = True ret += solve(has_pair) has_pair[student] = has_pair[first] = False return ret# test codeif __name__ == \"__main__\": solve(has_pair) 알고리즘 해결 전략 1권 p.159 게임판 덮기(board cover) H x W의 보드가 검은색과 흰색으로 채워져 있다. 모든 흰 칸을 L자 모양의 흰색 블록으로 덮고 싶다. 블록은 회전 가능하지만 겹치거나 검은색을 침범하거나 밖으로 나가서는 안된다. 보드가 있을 때 이를 덮는 방법의 수를 구현해보자.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# 조건H = 8W = 10board = [ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] ]# L자 블록의 4가지 경우cases = [ [[1, 0], [0, 1], [0, 0]], [[0, 1], [1, 1], [0, 0]], [[1, 0], [1, 1], [0, 0]], [[1, 0], [1, -1], [0, 0]]]# (y, x) 위치가 보드를 벗어났는지를 판단하는 함수def in_range(y, x): if y &lt; 0 or x &lt; 0 or y &gt;= H or x &gt;= W: return False return True# (y, x)에 c 타입의 블록을 넣는 함수def put(y, x, c): # c : 블록 타입 ret = True for point in c: _y = y + point[0] _x = x + point[1] if not in_range(_y, _x): ret = False else: board[_y][_x] += 1 if board[_y][_x] &gt; 1: ret = False return ret# (y, x)에서 c 타입의 블록을 빼는 함수def get(y, x, c): for point in c: _y = y + point[0] _x = x + point[1] if not in_range(_y, _x): continue else: board[_y][_x] -= 1def solve(): # base case fx = fy = None for i in range(H): for j in range(W): if board[i][j] == 0: fy = i fx = j break if fx != None: break if fx == None: return 1 ret = 0 for c in cases: if put(fy, fx, c): ret += solve() get(fy, fx, c) return ret# test codeif __name__ == \"__main__\": solve()","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.07.15 Data Structure and Algorithm Study","slug":"190715-DSAA-Study","date":"2019-07-15T07:39:19.000Z","updated":"2019-07-21T07:40:01.985Z","comments":true,"path":"2019/07/15/190715-DSAA-Study/","link":"","permalink":"http://JINUKK.github.io/2019/07/15/190715-DSAA-Study/","excerpt":"","text":"MAX HEAP 완전이진트리 배열, heapsize(배열의 개수가 아닌 데이터의 개수) Priority Queue 때문에 구현한다. ADT 1) is_empty() -&gt; bool 2) is_full() -&gt; bool 3) push(data) -&gt; 반환없음 4) pop() -&gt; 삭제된 원소 반환 5) top() -&gt; 다음 번에 반환될 원소 반환 첫번째 배열 자리는 쓰지 않고 구현(인덱스 0번 자리) - 책마다 다르다! Heap property(push와 pop을 했을 때) 1) 여전히 완전이진트리인가? 2) 어떤 노드를 선택하든 key 값이 자식보다 작지 않다.(크거나 같다.) 구현 방법 1) heapsize++ 2) cur = Arr(heapsize) 3) cur.key가 parent.key보다 크다면 cur와 parent 교환 4) root node를 만날 때까지 진행 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142# 객체화 시켜주기 위해 Element class 선언class Element: def __init__(self, key): self.__key = key @property def key(self): return self.__key @key.setter def key(self, k): self.__key = kclass MaxHeap: MAX = 1024 def __init__(self): self.__heapsize = 0 self.__container = [None for _ in range(MaxHeap.MAX)] # 부모 노드의 자리를 구할 때 def __get_parent_idx(self, cur): return cur//2 # 자식 노드의 왼쪽 자리를 구할 때 def __get_left_child_idx(self, cur): return cur * 2 # 자식 노드의 오른쪽 자리를 구할 때 def __get_right_child_idx(self, cur): return cur * 2 + 1 def is_empty(self): if self.__heapsize == 0: return True else: return False def is_full(self): if self.__heapsize == MaxHeap.MAX: return True else: return False def push(self, key): if self.is_full(): raise IndexError(\"The heap is full.\") self.__heapsize+=1 cur_idx = self.__heapsize par_idx = self.__get_parent_idx(cur_idx) # cur_idx != root # key &gt; container[parent].key while cur_idx != 1 and key &gt; self.__container[par_idx].key: self.__container[cur_idx] = self.__container[par_idx] cur_idx = par_idx par_idx = self.__get_parent_idx(cur_idx) # Element는 객체를 만들기 위함 # 처음에 키 값이 존재하지 않는다면 cur_idx !=1의 조건만 보고 # 내려올 것이므로 뒤에 조건은 보지 않아서 에러가 발생하지 않는다. # 다음은 계속 Element 객체가 만들어진다. self.__container[cur_idx] = Element(key) # 자식 중에 큰 수를 구할 때 def __get_bigger_child_idx(self, cur): left_child_idx = self.__get_left_child_idx(cur) right_child_idx = self.__get_right_child_idx(cur) if left_child_idx &gt; self.__heapsize: return None elif left_child_idx == self.__heapsize: return left_child_idx else: left_child = self.__container[left_child_idx] right_child = self.__container[right_child_idx] if left_child.key &gt; right_child.key: return left_child_idx else: return right_child_idx def pop(self): if self.is_empty(): raise IndexError(\"The heap is empty.\") ret = self.__container[1] temp = self.__container[self.__heapsize] cur_idx = 1 bigger_child_idx = self.__get_bigger_child_idx(cur_idx) while bigger_child_idx and temp.key &lt; self.__container[bigger_child_idx].key: self.__container[cur_idx] = self.__container[bigger_child_idx] cur_idx = bigger_child_idx bigger_child_idx = self.__get_bigger_child_idx(cur_idx) self.__container[cur_idx] = temp self.__heapsize -= 1 # element를 줄 것인지 아니면 key값을 반환할 것인지를 선택하자. return ret.key def top(self): if self.is_empty(): raise IndexError(\"The heap is empty.\") return self.__container[1]class PriorityQueue: def __init__(self): self.container = MaxHeap() # 래핑 함수(wrapping function) def enqueue(self, data): self.container.push(Element(data)) def dequeue(self): return self.container.pop().key# test codeif __name__ == \"__main__\": mh = MaxHeap() mh.push(10) mh.push(7) mh.push(6) mh.push(15) for idx in range(mh._MaxHeap__heapsize+1) : elem = mh._MaxHeap__container[idx] if elem: print(elem.key, end = \" \") print() while not mh.is_empty(): print(mh.pop(), end = \" \")","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.07.11 Data Structure and Algorithm Study","slug":"190711-DSAA-Study","date":"2019-07-11T07:22:26.000Z","updated":"2019-07-21T07:23:16.472Z","comments":true,"path":"2019/07/11/190711-DSAA-Study/","link":"","permalink":"http://JINUKK.github.io/2019/07/11/190711-DSAA-Study/","excerpt":"","text":"동적 배열(Dynamic array) vs 연결 리스트(Linked list) 동적 배열(Dynamic array) 장점 : search - O(1) = Indexing 단점 : insert, delete - O(n) python의 동적배열은 list이다. append, pop - O(1)123456789다음과 같이 이미 할당된 배열의 공간이 있을 경우ex) [a][b][c][d][ ][ ][ ][ ]append(e)를 하게되면 d의 바로 뒤에 붙게 되고pop을 해도 바로 뒤에서 빼게되기 때문에 O(1)이다.그런데 a의 앞에 e를 넣으려고 하면 d부터 데이터를 한칸씩 밀어야한다.있는 데이터만큼 옮겨야 하기 때문에 O(n)이다. 메모리가 붙어 있기 때문에 cache hit가 존재한다. 메모리를 가져올 때 통째로 그 주변까지 가져온다. 연결 리스트(Linked list) 장점 : insert, delete - O(1) head와 tail만 이어주는 두번의 작업으로 끝난다. delete의 경우 한번의 작업으로 끝나고 하무것도 연결이 되지 않은 데이터는 가비지컬렉터에 의해 사라진다. 단점 : search - O(n) 데이터를 찾을 때 데이터의 개수만큼 if으로 찾아야 한다. BST(Binary Search Tree) insert, delete, search - O(log(n)) = 3가지 모두 성능이 좋음 height of tree -&gt; 아무리 많이 비교해도 트리의 높이만큼만 비교하게 된다.(log(n)) 데이터는 다른 곳에 저장되어 있고 tree 구조로 search만 한다. 실제 데이터와 포인터로 연결되어 있기 때문에 접근가능하다. 분할 상환 분석(Amortized Analysis) 평균적으로 실행시간이 얼마나 걸리는지 측정하는 방법 동적 배열(DA)의 예 1234567891011121314151) 배열이 다 찼을 경우, 배열의 크기를 2배로 늘림(Array Doubling)2) 공간을 할당할 경우 = O(n)3) 공간을 할당한 상태에서 데이터를 넣을 경우 = O(1)ex)[a] x 2 = [a][ ] : O(n)[a][ ] = [a][b] : O(1)[a][b] x 2 = [a][b][ ][ ] : O(n)[a][b][ ][ ] = [a][b][c][d] : O(1)[a][b][c][d] x 2 = [a][b][c][d][ ][ ][ ][ ] : O(n)[a][b][c][d][ ][ ][ ][ ] = [a][b][c][d][e][f][g][h] : O(1)4) 수가 늘어날수록 O(n)보다 O(1)이 더 자주 일어나게 됨 어떤 특정 상황에서는 최악의 경우이지만 나머지 상황에서는 좋은 결과를 보여줌","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.07.08 Data Structure and Algorithm Study","slug":"190708-DSAA-Study","date":"2019-07-08T06:37:17.000Z","updated":"2019-07-21T06:38:09.235Z","comments":true,"path":"2019/07/08/190708-DSAA-Study/","link":"","permalink":"http://JINUKK.github.io/2019/07/08/190708-DSAA-Study/","excerpt":"","text":"순회 재방문을 허용하지 않고 트리를 구성하는 모든 노드에 다해서 반드시 한번씩 방문하는 것 Queue 계열의 알고리즘 BFS(Breadth First Search) : 너비 우선 탐색 레벨 순서 순회(levelorder traversal) root를 시작으로 다음 레벨 왼쪽부터 방문12345678910111213141516171819202122232425262728293031323334353637383940414243# python Queue module 이용from queue import Queue# traversal(순회)# 재방문없이 어떤 자료구조의 모든 데이터(노드)를 방문하는 것class TreeNode: def __init__(self, data): self.data = data self.left = None self.right = Nonedef levelorder(cur): q = Queue() q.put(cur) while not q.empty(): cur = q.get() print(cur.data, end = \" \") if cur.left: q.put(cur.left) if cur.right: q.put(cur.right)if __name__ == \"__main__\": n1 = TreeNode(1) n2 = TreeNode(2) n3 = TreeNode(3) n4 = TreeNode(4) n5 = TreeNode(5) n6 = TreeNode(6) n7 = TreeNode(7) n1.left = n2 n1.right = n3 n2.left = n4 n2.right = n5 n3.left = n6 n3.right = n7 levelorder(n1) BST(Binary Search Tree) insert, search, delete 모두 O(log(n)) 최악의 경우 모두 O(n) 데이터가 정렬되어 있다. insert를 할 때 반드시 empty node에 들어가게 되어있다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166class TreeNode: def __init__(self, key=None): self.__key = key self.__left = None self.__right = None # getter @property def key(self): return self.__key # setter @key.setter def key(self, key): self.__key = key @property def left(self): return self.__left @left.setter def left(self, left): self.__left = left @property def right(self): return self.__right @right.setter def right(self, right): self.__right = rightclass BST: def __init__(self): self.__root = None @property def root(self): return self.__root def preorder(self, cur): if not cur: return print(cur.key, end = \" \") self.preorder(cur.left) self.preorder(cur.right) def insert(self, key): new_node = TreeNode(key) cur = self.__root if not cur: self.__root = new_node return while True: parent = cur if key &lt; cur.key: cur = cur.left if not cur: parent.left = new_node return else: cur = cur.right if not cur: parent.right = new_node return def search(self, target): # 함수를 구현할 때는 예외사항을 모두 생각하면 만들어야 한다. # root가 존재하지 않을 경우, cur가 None이므로 while 문이 돌지 않고 바로 빠져나가게 된다. cur = self.__root while cur: if cur.key == target: return cur elif cur.key &gt; target: cur = cur.left else: cur = cur.right return None # 1. 리프 노드일 때 # 2. 자식이 하나일 때 - 왼쪽, 오른쪽 # 3. 자식이 둘일 때 def delete(self, target): self.__root = self.__delete_recursion(self.__root, target) # 재귀 함수 # 자료구조에서 데이터를 빼고 반환하지 않는다. --&gt; delelte # 자료구조에서 데이터를 빼고 사용자에게 반환해준다. --&gt; remove def __delete_recursion(self, cur, target): # base case if not cur: return None elif target &lt; cur.key: cur.left = self.__delete_recursion(cur.left, target) elif target &gt; cur.key: cur.right = self.__delete_recursion(cur.right, target) # target == cur.key else: # 1. 삭제 노드가 리프 노드인 경우 if not cur.left and not cur.right: cur = None # 2. 삭제 노드의 자식이 하나일 때 # 왼쪽 자식이 있는 경우 elif not cur.right: cur = cur.left # 오른쪽 자식이 있는 경우 elif not cur.left: cur = cur.right # 3. 삭제 노드의 자식이 둘일 때 # - 왼쪽 서브 트리에서 가장 큰 수 # - 오른쪽 서브 트리에서 가장 작은 수 else: # 대체 노드를 찾는다 rep = cur.left while rep.right: rep = rep.right # 삭제 노드와 대체 노드의 키를 교환 cur.key, rep.key = rep.key, cur.key cur.left = self.__delete_recursion(cur.left, rep.key) return cur# test codeif __name__ == \"__main__\": bst = BST() bst.insert(6) bst.insert(3) bst.insert(8) bst.insert(2) bst.insert(4) bst.insert(10) bst.insert(9) bst.insert(11) bst.preorder(bst.root) print() bst.insert(5) bst.preorder(bst.root) print() ret = bst.search(13) if ret: print(f\"&#123;ret.key&#125; is found.\") else: print(\"No such data.\") # 삭제노드가 리프 노드일 때 # bst.delete(9) # bst.delete(8) bst.delete(6) bst.preorder(bst.root)","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.07.04 Data Structure and Algorithm Study","slug":"190704-DSAA-Study","date":"2019-07-04T06:24:50.000Z","updated":"2019-07-21T06:31:05.934Z","comments":true,"path":"2019/07/04/190704-DSAA-Study/","link":"","permalink":"http://JINUKK.github.io/2019/07/04/190704-DSAA-Study/","excerpt":"","text":"원형 큐(Circular Queue) 선형 큐의 문제점을 보완하기 위한 자료구조 크기가 정해져 있는 배열(list) head, tail이 존재 empty : head == tail full : tail + 1 == head tail은 마지막 데이터의 다음을 가리킨다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class CQueue: MAXSIZE = 10 def __init__(self): self.__container = [None for _ in range(CQueue.MAXSIZE)] self.__head = 0 self.__tail = 0 def is_empty(self): if self.__head == self.__tail: return True return False def is_full(self): next = self.__step_forward(self.__tail) if next == self.__head: return True return False def enqueue(self, data): if self.is_full(): raise Exception(\"The queue is full.\") self.__container[self.__tail] = data # tail은 마지막 데이터의 다음을 가리킨다. self.__tail = self.__step_forward(self.__tail) def dequeue(self): if self.is_empty(): raise Exception(\"The queue is empty.\") ret = self.__container[self.__head] self.__head = self.__step_forward(self.__head) return ret def peek(self): if self.is_empty(): raise Exception(\"The queue is empty.\") return self.__container[self.__head] # 편의 함수 def __step_forward(self, x): x += 1 if x &gt;= CQueue.MAXSIZE: x = 0 return x# test codeif __name__ == \"__main__\": cq = CQueue() for i in range(8): cq.enqueue(i) for i in range(5): print(cq.dequeue(), end=\" \") print() for i in range(8, 14): cq.enqueue(i) while not cq.is_empty(): print(cq.dequeue(), end=\" \") print() for i in range(10): print(cq._CQueue__container[i], end=\" \") 순회 재방문을 허용하지 않고 트리를 구성하는 모든 노드에 다해서 반드시 한번씩 방문하는 것 Stack 계열의 알고리즘 DFS(Depth First Search) : 깊이 우선 탐색 재귀(recursion)와 반복문, stack 자료구조를 통한 구현 - stack frame 전위 순회(preorder traversal) root -&gt; 왼쪽 서브 트리 -&gt; 오른쪽 서브 트리 중위 순회(inorder traversal) 왼쪽 서브 트리 -&gt; root -&gt; 오른쪽 서브 트리 후위 순회(postorder traversal) 왼쪽 서브 트리 -&gt; 오른쪽 서브 트리 -&gt; root123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142class Stack: def __init__(self): self.container = list() def is_empty(self): if not self.container: return True else: return False # 래핑 함수 : 기존에 있던 함수의 기능을 재정의해서 사용하는 함수 def push(self, data): self.container.append(data) def pop(self): return self.container.pop() def peek(self): return self.container[-1]# traversal(순회)# 재방문없이 어떤 자료구조의 모든 데이터(노드)를 방문하는 것class TreeNode: def __init__(self, data): self.data = data self.left = None self.right = None# 전위 순회def preorder(node): # base case if not node: return # 방문했다는 표시를 print로 함 print(node.data, end=' ') # 왼쪽 자식 preorder(node.left) # 오른쪽 자식 preorder(node.right)# 중위 순회def inorder(node): # base case if not node: return inorder(node.left) print(node.data, end=' ') inorder(node.right) # 후위 순회def postorder(node): # base case if not node: return postorder(node.left) postorder(node.right) print(node.data, end=' ')# stack을 이용한 전위 순회def iter_preorder(cur): s = Stack() while True: while cur: # 방문은 print로 표현 print(cur.data, end=\" \") s.push(cur) cur = cur.left if s.is_empty(): break cur = s.pop() cur = cur.right# stack을 이용한 중위 순회def iter_inorder(cur): s = Stack() while True: while cur: s.push(cur) cur = cur.left if s.is_empty(): break cur = s.pop() # 방문은 print로 표현 print(cur.data, end=\" \") cur = cur.right# stack을 이용한 후위 순회def iter_postorder(cur): s1 = Stack() s2 = Stack() s1.push(cur) while not s1.is_empty(): cur = s1.pop() if cur.left: s1.push(cur.left) if cur.right: s1.push(cur.right) s2.push(cur) while not s2.is_empty(): cur = s2.pop() # 방문은 print로 표현 print(cur.data, end = \" \")# test codeif __name__ == \"__main__\": n1 = TreeNode(1) n2 = TreeNode(2) n3 = TreeNode(3) n4 = TreeNode(4) n5 = TreeNode(5) n6 = TreeNode(6) n7 = TreeNode(7) n1.left = n2 n1.right = n3 n2.left = n4 n2.right = n5 n3.left = n6 n3.right = n7 # preorder(n1) # print(\"\") # inorder(n1) # print(\"\") # postorder(n1) iter_preorder(n1) print(\"\") iter_inorder(n1) print(\"\") iter_postorder(n1)","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.07.01 Data Structure and Algorithm Study","slug":"190701-DSAA-Study","date":"2019-07-01T05:03:32.000Z","updated":"2019-07-21T06:04:08.154Z","comments":true,"path":"2019/07/01/190701-DSAA-Study/","link":"","permalink":"http://JINUKK.github.io/2019/07/01/190701-DSAA-Study/","excerpt":"","text":"Sort Algorithm 복습 정리Help Link! TED-Ed Youtube(https://www.youtube.com/watch?v=WaNLJf8xzC4) bubble sort Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 O(n^2) simple sort 마지막 전 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬 한번 순회가 끝나면 가장 큰 자료가 맨뒤로 이동 2번째 순회에서는 맨 끝에 있는 자료를 정렬에서 제외되는 방식 순회할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어남12345678910111213141516171819\"\"\"for문이 2개 = n^2데이터가 종속적\"\"\"def bubble_sort(arr): n = len(arr) for i in range(n - 1): for j in range(n - 1- i): if arr[j] &gt; arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j]# test codeif __name__ == \"__main__\": arr = [7, 2, 5, 12, 6] bubble_sort(arr) print(arr) insertion sort Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 O(n^2) Comparison sort 중에 그나마 나음 simple sort 두 번째 자료부터 시작하여 그 앞 자료들과 비교하면서 삽입할 위치를 지정 지정한 후, 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 방식 처음 key 값은 두번째 자료부터 시작한다.12345678910111213141516171819202122232425262728\"\"\"simple sort 중에 insertion sort가 제일 낫다.if문을 비교하는데 있어서 insertion sort는 더 적게 사용할 수 있다.\"\"\"def insertion_sort(arr): n = len(arr) for i in range(1, n): temp = arr[i] j = i-1 while j!=-1: if arr[j] &gt; temp: arr[j+1] = arr[j] j-=1 else: break # 이미 있는 j의 다음 위치에 존재하기 위해 arr[j+1] = temp # test codeif __name__ == \"__main__\": arr = [7, 2, 5, 12, 6] insertion_sort(arr) print(arr) selection sort Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 O(n^2) simple sort 제자리 정렬 알고리즘의 하나 입력 리스트(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법12341) 주어진 배열 중에서 최솟값을 찾는다.2) 그 값을 맨 앞에 위치한 값과 교체한다.(두 수를 비교하여 pass도 가능)3) 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.4) 하나의 원소만 남을 때까지 위의 1~3 과정을 반복한다. 123456789101112131415161718def selection_sort(arr): n = len(arr) for i in range(n-1): min_idx = i for j in range(i+1, n): if arr[min_idx] &gt; arr[j]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] # test codeif __name__ == \"__main__\": arr = [7, 2, 5, 12, 6] selection_sort(arr) print(arr) quick sort Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 divide and conquer(분할 정복 알고리즘) O(nlogn) 맨 앞의 데이터를 기준으로 선택했을 경우 모든 데이터가 정렬되었을 때, 오히려 많은 시간이 걸리게 된다.(O(n^2)) 따라서 이 문제를 해결하는 방법은 기준을 선택할 때 중간 값을 기준으로 선택한다.12341) 리스트의 중간 원소 pivot을 기준으로 pivot보다 큰 원소는 오른쪽으로 옮긴다.2) 리스트의 중간 원소 pivot을 기준으로 pivot보다 작은 원소는 왼쪽으로 옮긴다.3) pivot의 오른쪽 리스트와 왼쪽 리스트를 분할하여 재귀를 통해 다시 정렬 반복한다.4) 리스트의 크기가 0이나 1이 될때까지 반복한다. 123456789101112131415161718192021222324252627282930313233343536373839\"\"\"patition : pivot을 기준으로 왼쪽에 작은 값이, 오른쪽에 큰 값이 정렬되는 것\"\"\"def quick_sort(arr, start, end): # base case if start &gt;= end: return left = start right = end pivot = arr[(left + right)//2] # patition # left, right가 교차하기 전이라면 while left &lt;= right: # left가 언제 멈춰야 하는지 while arr[left] &lt; pivot: left+=1 while pivot &lt; arr[right]: right-=1 # left와 right가 교차하지 않았다면 # 교환 if left &lt;= right: arr[left], arr[right] = arr[right], arr[left] left+=1 right-=1 quick_sort(arr, start, right) quick_sort(arr, left, end) # test codeif __name__ == \"__main__\": arr = [7, 2, 5, 12, 6, 1, 7, 6, 3, 10, 11] quick_sort(arr, 0, len(arr)-1) print(arr) merge sort Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 divide and conquer(분할 정복 알고리즘) O(nlogn) 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않을 경우에는 정렬되지 않는 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def merge(arr, start, mid, end): left = start right = mid + 1 temp = [] # 둘 중에 하나라도 범위를 벗어나기 전까지 while left &lt;= mid and right &lt;= end: if arr[left] &lt; arr[right]: temp.append(arr[left]) left+=1 else: temp.append(arr[right]) right+=1 # 만약에 left가 남아있다면 # temp에다가 넣는다. while left &lt;= mid: temp.append(arr[left]) left+=1 while right &lt;= end: temp.append(arr[right]) right+=1 print(\"arr:\"+str(arr)) # arr에 temp를 업데이트한다. arr[start:end+1] = temp print(\"temp:\"+str(temp))def merge_sort(arr, start, end): #base case if start &gt;= end: return mid = (start + end) // 2 # divide 시점 merge_sort(arr, start, mid) merge_sort(arr, mid+1, end) # conquer 시점 merge(arr, start, mid, end)# test codeif __name__ == \"__main__\": arr = [7, 2, 5, 12, 6, 1, 7, 6, 3, 10, 11] merge_sort(arr, 0, len(arr)-1) print(arr)","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.06.20 Django Study","slug":"190620-Django-Study","date":"2019-06-20T10:38:08.000Z","updated":"2019-06-21T10:39:02.867Z","comments":true,"path":"2019/06/20/190620-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/06/20/190620-Django-Study/","excerpt":"","text":"DOCKER Basic 가상 컴퓨팅 환경과 비슷한 컨테이너 서비스 초기에는 LXC(Linux Container) 방식으로 구현되어 리눅스에서만 동작했었다. 현재는 runC라는 방식으로 변경되어 다양한 운영체제에서 사용할 수 있다. httpsL//hub.docker.com 에 접속해 가입을 진행한다. 추가 정보는 입력하지 않아도 된다. email 인증까지 진행하도록 한다. 도커를 설치한다. 12345# 리눅스에서 설치 시$ curl -s https://get.docker.com/ | sudo sh# curl이 없다면$ sudo apt-get -y install curl 도커의 권한을 변경한다. 12# 관리자 계정 권한$ sudo usermod -aG docker $USER docker 명령을 실행하여 옵션이 나타나는지 확인한다. 1$ docker 도커에서 ubuntu 18.04 가상 컨테이너를 사용해본다. run 명령어를 사용하여 이미지명을 지정하고 새로운 컨테이너를 실행한다. 컨테이너는 프로세스가 돌고있는 동안만 유효하다.1$ docker run ubuntu:18.04 다음 명령을 통해 현재 로컬에 있는 이미지 목록을 볼 수 있다. 1$ docker image ls 다음 명령을 통해 bash shell를 실행할 수 있다. 123$ docker run --rm -it ubuntu:18.04 bin/bash# --rm : 실행 종료 후 컨테이너 제거# -it : 터미널 사용 nginx를 설치하고 서버 접속 테스트를 해본다. 1234567891011121314# 포트는 여러 개를 지정할 수 있음$ docker container run --rm -it -p 8080:80 ubuntu:18.04 bin/bash# -y 옵션은 yes$ apt-get -y update$ apt-get -y install nginx# nginx version 확인$ nginx -v$ service nginx start# 서버에 접속하여 확인해보자.(127.0.0.1:8080) 베이스 파일을 만들어서 원하는 추가 프로그램 설치 목록을 넣어본다. 1$ vim Dockerfile.base 추가를 원하는 프로그램을 넣으면 된다. Amazon AWS의 EC2를 이용하여 배포할 때 넣은 내용을 넣었다. supervisor 명령을 통해 설정 파일을 복사하는 명령어를 입력한다. docker는 하나의 프로세스만 동작하는 명령을 실행할 수 있다. 동작하고 있는 프로세스가 없는 경우 컨테이너는 종료된다. nginx와 uwsgi가 모두 동작해야 하기 때문에 supervisor 모듈을 사용한다. FROM의 내용은 base image를 지정하는 것이기 때문에 정해져 있는 목록에서 지정해야 한다. RUN을 통해 생성 및 설치를 한다. ADD를 통해 이미 만들어진 파일을 복사할 수 있다. bash shell teminal를 하나 더 실행하여 추가 프로그램 설치 명령어를 직접 입력해보고 추가하도록 한다. 123456789101112131415161718192021222324252627[Dockerfile.base의 내용]FROM django:latestMAINTAINER askjw123@naver.comRUN apt-get -y updateRUN apt-get -y install nginxRUN apt-get -y install python3-dev python3-venv python3-pipRUN useradd -b /home -m -s /bin/bash djangoRUN usermod -a -G www-data djangoRUN mkdir -p /var/www/djangoRUN mkdir /var/www/django/runRUN mkdir /var/www/django/logsRUN mkdir /var/www/django/iniADD ./conf/nginx/default /etc/nginx/sites-available/defaultADD ./conf/uwsgi/uwsgi.ini /var/www/django/ini/uwsgi.iniADD ./conf/requirements.txt /var/www/django/requirements.txtRUN python3 -m venv /var/www/django/venvRUN /var/www/django/venv/bin/pip3 install -r /var/www/django/requirements.txtRUN /var/www/django/venv/bin/django-admin startproject config /var/www/djangoRUN apt-get -y install supervisorADD ./conf/supervisord.conf /etc/supervisor/supervisord.confCMD [&quot;/usr/bin/supervisord&quot;] 로컬에 conf 폴더를 만들어서 복사할 파일 내용들을 생성해둔다. conf/requirements.txt 12Django==2.2.2uwsgi conf/supervisord.conf 12345[supervisord]nodaemon=true[program:nginx]command = nginx -g &quot;daemon off;&quot; conf/nginx/default 1234567891011121314151617upstream django &#123; server unix:/var/www/django/run/uwsgi.sock;&#125;server &#123; listen 80; charset utf-8; access_log /var/www/django/logs/access.log; error_log /var/www/django/logs/error.log; server_name _; location = /favicon.ico &#123; access_log off; log_not_found off; &#125; location / &#123; include /etc/nginx/uwsgi_params; uwsgi_pass django; &#125;&#125; conf/uwsgi/uwsgi.ini 1234567891011121314151617[uwsgi]uid = djangobase = /var/www/djangohome = %(base)/venvchdir = %(base)module = config.wsgi:applicationenv = DJANGO_SETTINGS_MODULE=config.settingsmaster = trueprocesses = 5socket = %(base)/run/uwsgi.socklogto = %(base)/logs/uwsgi.logchown-socket = %(uid):www-datachmod-socket = 660vacuum = true conf/uwsgi/uwsgi.service 123456789101112131415[Unit]Description=uWSGI Emperor service[Service]ExecStart=/var/www/django/venv/bin/uwsgi --emperor /var/www/django/iniUser=djangoGroup=www-dataRestart=on-failureKillSignal=SIGQUITType=notifyNotifyAccess=allStandardError=syslog[Install]WantedBy=multi-user.target 새로운 내용으로 이미지를 만들어 본다. 12# 베이스를 사용하여 처음 이미지를 생성할 경우, 시간이 어느정도 걸릴 수 있다.$ docker iamge build -f Dockerfile.base -t django:0.2 생성된 이미지로 컨테이너를 실행해보고 사이트에도 접속해본다. 1$ docker container run it --rm -p 7000:80 django:0.2","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.06.19 Django Study","slug":"190619-Django-Study","date":"2019-06-19T09:12:34.000Z","updated":"2019-06-21T09:13:10.476Z","comments":true,"path":"2019/06/19/190619-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/06/19/190619-Django-Study/","excerpt":"","text":"번역 기능 추가하기 I18N(Internationalization) I와 N 사이에 18글자의 단어가 있어서 I18N으로 불림 다국어 시스템을 구현하는 환경을 구성하는 것 장고에서 번역 기능을 사용하는 것 django에서는 기본 언어를 바꾸는 작업은 settings.py에서 LANGUAGE_CODE를 변경하면 된다. 123456789LANGUAGE_CODE = 'ko-kr'TIME_ZONE = 'Asia/Seoul'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = True 다국어 지원을 하려면 LocaleMiddleware를 추가하고 언어 번역 파일을 준비해야 한다. settings.py의 MIDDLEWARE에 LocaleMiddleware를 추가한다. 123456789MIDDLEWARE = [ #... 'django.contrib.sessions.middleware.SessionMiddleware', # 순서를 지켜서 추가해야 한다. # CommonMiddleware가 localeMiddleware의 값을 가지고 사용하기 때문이다. 'django.middleware.locale.LocaleMiddleware', 'django.middleware.common.CommonMiddleware', #...] 지원하고 싶은 언어의 목록도 작성한다. 123456from django.utils.translation import ugettext_lazy as _LANGUAGES = [ ('ko', _('Korean')), ('en', _('English')),] 번역 파일이 저장될 폴더를 만들고 settings.py에도 경로를 추가한다. 1$ mkdir locale 123LOCALE_PATHS = [ os.path.join(BASE_DIR, 'locale')] views.py에 번역을 테스트할 뷰를 작성한다. 1234567from django.shortcuts import renderfrom django.http import HttpResponsefrom django.utils.translation import ugettext_lazy as _def index(request): msg = _(\"안녕하세요\") return HttpResponse(msg) 번역할 텍스트 목록 파일을 만들기 위해 아래 명령을 실행한다. 12345678910111213141516# 최초 실행 시에는 언어별로 별도 실행해야 한다.$ python manage.py makemessages -l ko$ python manage.py makemessages -l en# 가상 환경 파일 안에서 문제가 일어난다면 뒤에 -i venv를 붙여서 실행한다.# 최초 실행이 아닐 경우$ python manage.py makemessages -a# gettext가 없다는 오류 메세지가 나타난다면# Mac)$ brew install gettext$ brew link gettext --force# Ubuntu)$ sudo apt-get install gettext 파일이 만들어지면 django.po 파일에 들어가서 다음 내용을 지워주자. 12아래 내용을 지우지 않으면 동작하지 않는다.#, fuzzy django.po 파일을 보면 msgid와 msgstr이 있는데 msgid를 확인하여 번역 내용을 입력한다. 번역 내용을 읽어서 처리할 수 있도록 django.mo 파일을 만들어야 한다. 12345$ python manage.py compilemessages# 언어별로 실행$ python manage.py compilemessages -l ko$ python manage.py compilemessages -l en 번역 파일이 동작하는지 살펴보기 위해 강제로 언어 설정을 변경해본다. 12345678# vievs.py def index(request): if translation.LANGUAGE_SESSION_KEY in request.session: del(request.session[translation.LANGUAGE_SESSION_KEY]) translation.activate('en') request.session[translation.LANGUAGE_SESSION_KEY] = 'en' msg = _(\"안녕하세요\") return HttpResponse(msg) 사이트에 접속하여 원하는 번역으로 출력되는지 확인한다. views.py에서 언어 설정을 사용자가 선택해서 번경할 수 있도록 해보자. 123456789101112131415161718192021222324# views.pydef change_language(request, code): # 지원하는 언어 코드 목록을 만듦 languages = [language[0] for language in settings.LANGUAGES] # 기본 언어 설정 가져오기 default_language = settings.LANGUAGE_CODE[:2] if translation.LANGUAGE_SESSION_KEY in request.session: del(request.session[translation.LANGUAGE_SESSION_KEY]) if code in languages and code != default_language: translation.activate(code) request.session[translation.LANGUAGE_SESSION_KEY] = code else: request.session[translation.LANGUAGE_SESSION_KEY] = default_language code = default_language return HttpResponse(\"Language Change to \"+code)# urls.pyurlpatterns = [ #... path('language/&lt;code&gt;/', change_language),] 사이트에 접속하여 주소를 통해 언어를 변경해보자. template에서도 번ㅇ역 기능을 사용할 수 있다. 123456789&lt;!-- trans 태그 사용--&gt;&#123;% load i18n %&#125;&#123;% trans '안녕하세요' %&#125;&lt;!-- 여러 줄을 번역할 경우 --&gt;&#123;% blocktrans %&#125;번역 테스트번역 테스트&#123;% endblocktrans %&#125; url을 사용해서 언어를 선택할 수도 있다. 1234567891011121314151617# config.urls.py# 하위 urls.py에서는 쓸 수 없다.# Root urls.py에만 쓸 수 있다.from django.conf.urls.i18n import i18n_patternsurlpatterns += i18n_patterns( path('', include('app.urls')))# url에서 언어에 대한 인자를 제거하고 싶다면from django.conf.urls.i18n import i18n_patternsurlpatterns += i18n_patterns( path('', include('app.urls')) # 추가 prefix_default_language = False)","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.06.18 Django Study","slug":"190618-Django-Study","date":"2019-06-18T07:33:17.000Z","updated":"2019-06-21T09:18:23.225Z","comments":true,"path":"2019/06/18/190618-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/06/18/190618-Django-Study/","excerpt":"","text":"Elastic Beanstalk로 배포하기 배포하기에 앞서 S3와 RDS는 자동으로 만들어지지 않기 때문에 설정을 완료한 후 진행해야 한다. 먼저 Elastic Beanstalk API 키를 설정해야 한다. Amazon AWS에서 서비스 탭에 IAM으로 이동한다. 사용자 메뉴로 이동하여 사용자 추가를 클릭한다. 사용자 이름을 입력하고 액세스 유형은 [프로그래밍 방식 액세스]를 선택한다. 권한 설정으로 넘어가면 새로운 그룹을 생성하기 위해 그룹 생성을 클릭한다. 그룹 이름을 입력하고 정책 필터에서 [AWSElasticBeanstalkFullAccess]에 체크한다. 그룹을 생성하였다면 태그로 넘어간다. 태그는 선택 사항이므로 검토로 넘어가도록 한다. 검토하였다면 사용자 만들기를 클릭한다. 생성에 성공하였다면 csv 파일을 다운로드를 해두도록 한다. Elastic Beanstalk로 배포한다. 배포할 프로젝트에서 의존성 리스트를 만든다. 1$ pip freeze &gt; requirements.txt .ebextensions 폴더를 만든다. 1$ mkdir .ebextensions .ebextensions 폴더에 django.config 파일을 만들고 내용을 입력한다. 12345.ebextensions/django.config 내용option_setting: aws:elasticbeanstalk:container:python: WSGIPath: config/wsgi.py settings.py에서 배포 관련 설정을 진행한다. 12DEBUG = FalseALLOWED_HOSTS = ['*'] .gitignore 파일을 생성하고 작성한다. 12345*.pyc*~/venv__pycache__db.sqlite3 git을 초기화하고 commit까지 진행한다. 12345$ git init$ git add -A .$ git commit -m \"Elstic Beanstalk first commit\" EB CLI를 설치한다. 1$ pip install awsebcli eb init 명령을 실행한다. 1234567$ eb init# 사용하는 리전 선택: 10) ap-northeast-2 : Asia Pacific (Seoul)# IAM에서 만든 액세스 키와 보안 키를 입력# 새 애플리케이션을 생성하고 이름 지정# 언어 및 버전 선택 : Python 3.6# SSH 키 페어 선택 eb create 명령을 실행하여 로드 밸런서르 설정한다. 123$ eb create# load balancer의 type은 application 선택 생성이 완료되면 eb open 명령을 실행하여 사이트를 확인할 수 있다. 1$ eb open Amazon AWS에 들어가면 인스턴스 및 로드밸런서가 생성되있는 것을 확인할 수 있다. RDS 보안 그룹의 인바운드 규칙에 EC2 보안 그룹의 그룹 아이디를 추가하도록 하자. 코드 변경이 생긴다면 git commit까지 진행하고 eb deploy를 실행하여 업데이트하면 된다. 12345$ git add [변경한 파일]$ git commit -m [commit message]$ eb deploy","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.06.17 Django Study","slug":"190617-Django-Study","date":"2019-06-17T09:25:22.000Z","updated":"2019-06-17T10:20:47.987Z","comments":true,"path":"2019/06/17/190617-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/06/17/190617-Django-Study/","excerpt":"","text":"Django Rest Framework 사용하기 Views.py에서 만든 뷰를 Templates에서 활용해야 할 경우, django Template filter를 사용해야 한다. 프론트엔드 개발자도 django에 대해서 어느정도 알아야 한다는 말이 된다. 이렇게 되면 프론트엔드와 백엔드는 끊임없이 함께 코드를 고쳐야 한다. 따라서 프론트엔드와 백엔드가 완전히 구별되는 것이 이상적인데 이 때 필요한 것이 REST API이다. Django에서는 Django Rest Framework(DRF)를 사용하여 코드를 작성한다. API 실습을 위한 프로젝트 실습 django project를 생성하고 앱을 생성한다. 123456789$ pip install django$ django-admin startproject config .# 회원 관리를 위한 앱$ python manage.py startapp accounts# 문서 작성을 위한 앱$ python manage.py startapp tweet Django Rest Framework를 설치한다. 1$ pip install djangorestframework settings.py에서 INSTALLED_APPS에 ‘rest_framework’를 추가한다. 123456789101112INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', # 생성한 앱도 추가하는 것을 잊지 말자. 'accounts', 'tweet', 'rest_framework',] 유저 모델을 커스텀하고 데이터베이스는 아마존 AWS를 사용한다. 유저 모델을 커스텀한다. 12345678910111213141516171819202122232425262728# accounts/models.pyfrom django.db import modelsfrom django.contrib.auth.models import AbstractUserclass User(AbstractUser): message = models.TextField(blank=True) profile = models.ImageField(upload_to='user_image/profile/%Y/%m/%d', blank=True)# config/settings.pyAUTH_USER_MODEL = 'accounts.User'# accounts/admin.pyfrom django.contrib import adminfrom django.contrib.auth import get_user_model# Register your models here.from django.contrib.auth.admin import UserAdminclass CustomUserAdmin(UserAdmin): UserAdmin.fieldsets[1][1]['fields'] += ('profile','message') UserAdmin.add_fieldsets += ( (('Additional Info'), &#123;'fields':('profile','message')&#125;), )admin.site.register(get_user_model(), CustomUserAdmin) 아미존 AWS에서 RDS에 데이터베이스를 생성하고 settings.py를 수정한다. 12345678910111213 # psycopg2-binary를 설치하도록 한다. # 생성한 데이터베이스의 정보를 입력하도록 하자.DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'tweet', 'USER':'마스터 사용자 이름', 'PASSWORD':'마스터 사용자 비밀번호', 'HOST':'아마존 RDS의 엔드포인트', 'POST':'데이터베이스 접속 포트번호', &#125;, &#125; # migrate하는 것을 잊지 말자. 뷰를 동작하려면 Serializer와 View가 필요하다. Serializer는 API에서 동작하는 데이터 표현 객체이다. ModelForm과 비슷하다고 생각하면 된다. accounts 앱에서 serializers.py를 생성하고 다음과 같이 작성한다. 12345678910 # accounts/serializers.pyfrom rest_framework import serializers from .models import User # 유저 목록에 출력될 형식 지정 class UserListSerializer(serializers.ModelSerializer): class Meta: model = User fields = ['id', 'username', 'first_name', 'last_name', 'email', 'message', 'profile'] # fields = '__all__'로 전부 불러올 수도 있다. views.py에 API 뷰를 작성하도록 한다. 함수형 뷰와 클래스형 뷰 모두 만들 수 있다. 1234567891011121314151617181920212223from django.shortcuts import renderfrom .serializers import UserListSerializerfrom django.contrib.auth import get_user_modelfrom rest_framework.renderers import JSONRenderer, BrowsableAPIRendererfrom rest_framework import generics\"\"\"# generics 안에는 CRUD가 있다.List : GETCreate : POSTRetrieve : GETUpdate : PUT, PATCHDestroy : Delete\"\"\"class UserListView(generics.ListAPIView): # renderer_classes = [JSONRenderer] # JSON 형식으로만 받고 싶은 경우 queryset = get_user_model().objects.all() serializer_class = UserListSerializer def get_queryset(self): queryset = super().get_queryset() if not self.request.user.is_staff: queryset = queryset.filter(pk=self.request.user.id) return queryset urls.py를 생성하고 작성한다. 123456from django.urls import pathfrom .view import *urlpatterns = [ path('list/', UserListView.as_view()),] config/urls.py에도 accounts 앱을 연결해준다. 1234567from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('admin/', admin.site.urls), path('accounts/', include('accounts.urls')),] 서버 접속을 통해 유저 리스트가 나오는지 확인한다. 상세(Detail), 생성(Create), 수정(Update), 삭제(Delete) 모두 생성해보자. serializers.py에 추가 작성한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from rest_framework import serializersfrom .models import User# 유저 목록에 출력될 형식 지정# Listclass UserListSerializer(serializers.ModelSerializer): class Meta: model = User fields = ['id', 'username', 'first_name', 'last_name', 'email', 'message', 'profile']# 회원 가입할 때 필요한 필드들에 관한 Serializer# Createclass UserCreateSerializer(serializers.ModelSerializer): class Meta: model = User fields = ['username', 'password', 'first_name', 'last_name', 'email', 'message', 'profile'] # create method를 사용하지 않으면 password가 그대로 들어가게 된다. # 관리자 페이지에 가보면 password가 제대로 저장되지 않는 것을 확인할 수 있다. def create(self, validated_data): user = User.objects.create(**validated_data) user.set_password(validated_data.get('password')) user.save() return user # create는 방금 만든 오브젝트를 반드시 리턴해줘야 한다.# Updateclass UserModifySerializer(serializers.ModelSerializer): class Meta: model = User fields = ['password', 'first_name', 'last_name', 'email', 'message', 'profile'] # 기존의 update 함수를 오버라이딩해서 사용한다. # password만 수정하고 다른 정보는 빈 칸으로 둘 경우, 다른 정보들이 빈 칸으로 저장된다. # 따라서 기존의 update method를 오버라이딩해서 사용하도록 한다. def update(self, instance, validated_data): for key, value in validated_data.items(): if key == 'password' and value: instance.set_password(value) elif value: setattr(instance, key, value) instance.save() return instance# Detailclass UserDetailSerializer(serializers.ModelSerializer): class Meta: model = User fields = ['id', 'username', 'password', 'first_name', 'last_name', 'email', 'message', 'profile', 'is_superuser'] views.py를 작성한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from django.shortcuts import renderfrom .serializers import UserListSerializer, UserCreateSerializer ,UserModifySerializer, UserDetailSerializerfrom django.contrib.auth import get_user_modelfrom rest_framework import genericsfrom rest_framework.renderers import JSONRenderer, BrowsableAPIRenderer\"\"\"# generics 안에는 CRUD가 있다.List : GETCreate : POSTRetrieve : GETUpdate : PUT, PATCHDestroy : Delete\"\"\"# List Viewclass UserListView(generics.ListAPIView): # renderer_classes = [JSONRenderer] # JSON 형식으로만 받고 싶은 경우 queryset = get_user_model().objects.all() serializer_class = UserListSerializer # 관리자는 모든 유저 목록을 볼 수 있다. # 관리자가 아닌 유저는 자신의 정보만 볼 수 있다. def get_queryset(self): queryset = super().get_queryset() if not self.request.user.is_staff: queryset = queryset.filter(pk=self.request.user.id) return queryset# Create Viewclass UserCreateView(generics.CreateAPIView): serializer_class = UserCreateSerializer# Update Viewclass UserUpdateView(generics.UpdateAPIView): queryset = get_user_model().objects.all() serializer_class = UserModifySerializer# Detail Viewclass UserDetailView(generics.RetrieveAPIView): queryset = get_user_model().objects.all() serializer_class = UserDetailSerializer# Delete View# 삭제할 시, 형식을 지정할 필요가 없으므로, Serializer_class는 필요없다.class UserDeleteView(generics.DestroyAPIView): queryset = get_user_model().objects.all() urls.py를 작성한다. 12345678910from django.urls import pathfrom .views import *urlpatterns = [ path('delete/&lt;int:pk&gt;/', UserDeleteView.as_view()), path('detail/&lt;int:pk&gt;/', UserDetailView.as_view()), path('update/&lt;int:pk&gt;/', UserUpdateView.as_view()), path('create/', UserCreateView.as_view()), path('list/', UserListView.as_view()),] 서버 접속을 통해 동작을 확인해보자. 이번엔 tweet 앱을 작성해보자. models.py를 간단하게 작성한다. 12345678910from django.db import modelsfrom django.contrib.auth import get_user_modelclass Tweet(models.Model): author = models.ForeignKey(get_user_model(), on_delete=models.CASCADE, related_name='tweets') text = models.TextField() created = models.DateTimeField(auto_now_add=True) updated = models.DateTimeField(auto_now=True)# migrate하는 것을 잊지 말자. 같은 방법으로 serializers.py를 생성하여 작성한다. 123456789101112from rest_framework import serializersfrom .models import Tweetclass TweetListSerializer(serializers.ModelSerializer): class Meta: model = Tweet fields = '__all__'class TweetSerializer(serializers.ModelSerializer): class Meta: model = Tweet fields = ['author', 'text'] views.py를 작성한다. 위와 같이 각각 뷰마다 작성하는 방법이 있다. 다른 방법으로는 generics에 공통 뷰를 사용하는 방법도 있다. 12345678910111213141516171819202122232425262728293031323334353637383940from django.shortcuts import renderfrom .serializers import TweetListSerializer, TweetSerializerfrom . models import Tweetfrom rest_framework import generics# List &amp; Create Viewclass TweetListCreateView(generics.ListCreateAPIView): queryset = Tweet.objects.all() serializer_class = TweetListSerializer def create(self, request, *args, **kwargs): # print(request.user.id) # api를 공부하면서 print()를 이용해서 값을 받아보는 습관을 들이자. request.data['author'] = request.user.id # 기존 form에서는 form.instance.author를 사용 # 다른 점을 살펴보자. return super().create(request, *args, **kwargs)# Retrieve &amp; Update &amp; Destroy Viewclass TweetDetailView(generics.RetrieveUpdateDestroyAPIView): queryset = Tweet.objects.all() serializer_class = TweetSerializer# class TweetListView(generics.ListAPIView):# queryset = Tweet.objects.all()# serializer_class = TweetListSerializer## class TweetCreateView(generics.CreateAPIView):# serializer_class = TweetSerializer## class TweetDetailView(generics.RetrieveAPIView):# queryset = Tweet.objects.all()# serializer_class = TweetSerializer## class TweetUpdateView(generics.UpdateAPIView):# queryset = Tweet.objects.all()# serializer_class = TweetSerializer## class TweetDeleteView(generics.DestroyAPIView):# queryset = Tweet.objects.all() urls.py를 생성하고 작성한다. 12345678910111213from django.urls import pathfrom .views import *urlpatterns = [ path('', TweetListCreateView.as_view()), path('&lt;int:pk&gt;/', TweetDetailView.as_view()), # path('', TweetListView.as_view()), # path('create/', TweetCreateView.as_view()), # path('detail/&lt;int:pk&gt;', TweetDetailView.as_view()), # path('update/&lt;int:pk&gt;', TweetUpdateView.as_view()), # path('delete/&lt;int:pk&gt;', TweetDeleteView.as_view()),] config/urls.py에도 tweet 앱을 연결한다. 12345678from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('admin/', admin.site.urls), path('accounts/', include('accounts.urls')), path('tweet/', include('tweet.urls')),] 서버에 접속하여 동작을 확인하도록 한다. API 문서를 만들어서 한 눈에 모든 뷰를 확인해보도록 하자. swagger를 설치한다. 12# 입력한 토큰이 사라지는 버그로 인해 2.1.2 버전을 설치한다.$ pip install django-rest-swagger==2.1.2 settings.py에서 INSTALLED_APPS에 ‘rest_framework_swagger’를 추가한다. 1234INSTALLED_APPS = [ #... 'rest_framework_swagger',] config/urls.py에 swagger에 관한 뷰를 추가한다. 1234567891011121314151617from django.contrib import adminfrom django.urls import path, include# get_swagger_view 추가from rest_framework_swagger.views import get_swagger_viewfrom rest_framework.authtoken.views import obtain_auth_token# API 문서의 제목 지정schema_view = get_swagger_view(title='Tweeter API Document')urlpatterns = [ path('api/get_token/', obtain_auth_token), # 경로 추가 path('api/doc/', schema_view), path('admin/', admin.site.urls), path('accounts/', include('accounts.urls')), path('tweet/', include('tweet.urls')),] 이제 해당 경로로 접속하여 API 문서 뷰를 확인해보자. 이제 API에서 가장 많이 사용하는 토큰 인증 방식을 추가해보도록 한다. settings.py에서 INSTALLED_APPS에 ‘rest_framework.authtoken’을 추가한다. 1234INSTALLED_APPS = [ #... 'rest_framework.authtoken',] 토큰 기능을 추가하면 추가 테이블이 필요하므로 migrate를 하도록 한다. config/urls.py에 토큰 관련 뷰를 추가한다. 12345678910111213141516from django.contrib import adminfrom django.urls import path, includefrom rest_framework_swagger.views import get_swagger_view# obtain_auth_token 추가from rest_framework.authtoken.views import obtain_auth_tokenschema_view = get_swagger_view(title='Tweeter API Document') # API 문서의 제목urlpatterns = [ # 경로 추가 path('api/get_token/', obtain_auth_token), path('api/doc/', schema_view), path('admin/', admin.site.urls), path('accounts/', include('accounts.urls')), path('tweet/', include('tweet.urls')),] API 문서 페이지에 접속하여 토큰을 발급받아본다. api의 POST /api/get_token을 누르고 오른쪽에 Example Value를 클릭한다. 왼쪽 Value에 Example Value 형식이 들어가면 입력하도록 한다. 발급받은 토큰을 알아두자. 모든 API 뷰가 로그인해야만 동작할 수 있도록 권한을 추가하도록 한다. settings.py에 관련 설정을 추가한다. 12345REST_FRAMEWORK = &#123; 'DEFAULT_PERMISSION_CLASSES': ( 'rest_framework.permissions.IsAuthenticated', ),&#125; 로그아웃했을 때 토큰 발급만 되는 것을 확인할 수 있다. 하지만 회원 가입같은 경우, 인증하지 않아도 사용하는 뷰이므로, 다음과 같은 코드를 추가한다. 12345678# accounts/views.py# AllowAny 추가from rest_framework.permissions import AllowAnyclass UserCreateView(generics.CreateAPIView): serializer_class = UserCreateSerializer # permission_classes 추가 permission_classes = (AllowAny,) swagger 페이지에서도 토큰을 인증할 수 있도록 settings.py에 다음과 같은 코드를 추가한다. 1234567891011121314151617181920REST_FRAMEWORK = &#123; 'DEFAULT_PERMISSION_CLASSES': ( 'rest_framework.permissions.IsAuthenticated', ), # 추가 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.TokenAuthentication', ),&#125;# 추가SWAGGER_SETTINGS = &#123; 'SECURITY_DEFINITIONS': &#123; \"api_key\": &#123; \"type\": \"apiKey\", \"name\": \"Authorization\", \"in\": \"header\" &#125; &#125;&#125; 이제 swagger 페이지에서 오른쪽 상단에 Authorize를 누르면 토큰 키를 입력할 수 있다. 12# value에 다음과 같이 입력하면 된다.value: Token [토큰 값] 이번에는 자신이 작성한 글이거나 관리자인 경우에만 글에 대한 권한을 가질 수 있도록 해본다. tweet/permissions.py를 생성하고 작성한다. 1234567891011121314151617181920from rest_framework import permissions# 작성자인 경우# 반환값은 booleanclass IsOwnerOnly(permissions.BasePermission): def has_object_permission(self, request, view, obj): return obj.author == request.user# 작성자이거나 관리자인 경우class IsOwnerAndAdminOnly(permissions.BasePermission): def has_object_permission(self, request, view, obj): return obj.author == request.user or request.user.is_superuserclass IsOwnerOrReadOnly(permissions.BasePermission): def has_object_permission(self, request, view, obj): if request.method in permissions.SAFE_METHODS: # SAPE_METHODS : GET, HEAD, OPTIONS - 값을 변경하지 않는 메소드 return True return obj.author == request.user or request.user.is_superuser tweet/views.py에 추가한다. 12345678910# permissions 추가from .permissions import *# IsAuthenticated 추가from rest_framework.permissions import IsAuthenticatedclass TweetDetailView(generics.RetrieveUpdateDestroyAPIView): queryset = Tweet.objects.all() serializer_class = TweetSerializer # 로그인을 하지 않으면 사용 못함 permission_classes = [IsAuthenticated, IsOwnerAndAdminOnly] 필터 기능을 활용해보자. django-filter를 설치한다. 1$ pip install django-filter settings.py에서 INSTALLED_APPS에 ‘diango_filters’ 및 관련 설정을 추가한다. 1234567891011121314151617INSTALLED_APPS = [ #... 'django_filters',]REST_FRAMEWORK = &#123; 'DEFAULT_PERMISSION_CLASSES': ( 'rest_framework.permissions.IsAuthenticated', ), 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.TokenAuthentication', ), # 추가 'DEFAULT_FILTER_BACKENDS': ( 'django_filters.rest_framework.DjangoFilterBackend', )&#125; 필터 기능을 동작하고 싶은 뷰에 추가한다. 123456789101112class UserListView(generics.ListAPIView): # renderer_classes = [JSONRenderer] # JSON 형식으로만 받고 싶은 경우 queryset = get_user_model().objects.all() serializer_class = UserListSerializer # 필터 기능 추가 filterset_fields = ('username', 'first_name') def get_queryset(self): queryset = super().get_queryset() if not self.request.user.is_staff: queryset = queryset.filter(pk=self.request.user.id) return queryset swagger 페이지로 접속하여 해당 파라미터에 필드가 적용되었는지 확인한다. 이번에는 검색 필드를 사용해보도록 한다. ForeignKey로 묶인 필드들을 기준으로 검색할 수 있다. settings.py에 관련 설정을 추가한다. 12345678910111213REST_FRAMEWORK = &#123; 'DEFAULT_PERMISSION_CLASSES': ( 'rest_framework.permissions.IsAuthenticated', ), 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.TokenAuthentication', ), 'DEFAULT_FILTER_BACKENDS': ( 'django_filters.rest_framework.DjangoFilterBackend', # 추가 'rest_framework.filters.SearchFilter' )&#125; 검색하고자 하는 필드를 뷰에 추가한다. ForeignKey로 묶인 필드의 경우, 언더바 두 개(__)를 사용하여 필드명을 작성하면 된다. 123456789class TweetListCreateView(generics.ListCreateAPIView): queryset = Tweet.objects.all() serializer_class = TweetListSerializer # 검색 기능 추가 search_fields = ('text', 'author__username') def create(self, request, *args, **kwargs): request.data['author'] = request.user.id return super().create(request, *args, **kwargs) swagger 페이지로 접속하여 파라미터에 search 기능이 나오는지 확인한다. Postman에서도 확인할 수 있다. Postman을 설치하고 실행한다. 유저 리스트를 보기 위해 다음과 같이 설정한다. 123456Method : GETAddress : 127.0.0.1:8000/accounts/listHeaders : KEY - Authorization VALUE - Token [토큰 값]위 설정을 입력하고 SEND를 누른다. 유저 리스트가 나오는지 확인하자. tweet 앱에서 글을 작성할 경우 다음과 같이 설정한다. 123456789Method : POSTAddress : 127.0.0.1:8000/tweet/Headers : KEY - Authorization VALUE - Token [토큰 값]Body : raw/JSON(application/json) 선택Body 내용: &#123; &quot;text&quot;: &quot;test&quot;, &quot;author&quot;: 1 &#125; 결과를 확인한다. 설정하는 내용은 swagger 페이지에서 확인하면 된다. 메소드와 형식, 입력하는 곳이 어디인지 확인해서 적용하자.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.06.10 Django Study","slug":"190610-Django-Study","date":"2019-06-10T06:33:45.000Z","updated":"2019-06-21T06:36:19.984Z","comments":true,"path":"2019/06/10/190610-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/06/10/190610-Django-Study/","excerpt":"","text":"allauth template 파일 수정하기 django-allauth를 사용했을때, 이미 만들어진 template 파일을 사용하게 된다. template 파일을 커스텀하려면 다음과 같이 진행하도록 한다. 회원을 관리하는 앱에서 template 폴더를 생성한다. 회원을 관리하는 앱 이름은 account로 하지 않는 것이 좋다. 만약 account로 했을 경우, 다음의 경우를 보자. 1234567891011121314151617181920INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'django.contrib.humanize', # account라는 이름으로 앱을 생성한다면 'account', 'django.contrib.sites', 'allauth', 'allauth.account', 'allauth.socialaccount', 'allauth.socialaccount.providers.naver',]# 위에서 보는 것처럼 account라는 이름으로 앱을 생성했을 때,# allauth.account라는 이름과 충돌이 생겨 문제가 발생할 수 있다.# 따라서 다른 이름으로 하는 것이 좋다.(ex] accounts) template 폴더를 생성할 경우, templates라는 폴더를 만든다. 그리고 하위에 앱 이름과 같은 폴더를 한번 더 만든 뒤 그 하단에 html 파일을 생성했다. 하지만 이번에는 allauth의 template 파일을 커스텀하는 것이기 때문에 account라고 생성한다. account라고 생성하지 않는다면 이미 만들어진 template 파일을 수정할 수 없게 된다. 가상 환경 폴더인 venv/lib에는 설치한 패키지들이 들어있다. 패키지 안에 allauth/templates 폴더를 보면 이미 생성된 html 파일들을 볼 수 있다. 생성된 html 파일들과 이름을 같게 하여 html 파일을 account 폴더 하단에 생성한다. 이미 생성된 html 파일의 내용을 그대로 가져와서 내가 바꾸고 싶은 부분만 커스텀하면 된다. 로그인과 로그아웃 관련 template 파일을 가져와서 커스텀해보자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--// 기존에 생성되있는 login.html //--&gt;&#123;% extends \"account/base.html\" %&#125;&#123;% load i18n %&#125;&#123;% load account socialaccount %&#125;&#123;% block head_title %&#125;&#123;% trans \"Sign In\" %&#125;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;h1&gt;&#123;% trans \"Sign In\" %&#125;&lt;/h1&gt;&#123;% get_providers as socialaccount_providers %&#125;&#123;% if socialaccount_providers %&#125;&lt;p&gt;&#123;% blocktrans with site.name as site_name %&#125;Please sign in with oneof your existing third party accounts. Or, &lt;a href=\"&#123;&#123; signup_url &#125;&#125;\"&gt;sign up&lt;/a&gt;for a &#123;&#123; site_name &#125;&#125; account and sign in below:&#123;% endblocktrans %&#125;&lt;/p&gt;&lt;div class=\"socialaccount_ballot\"&gt;&lt;ul class=\"socialaccount_providers\"&gt; &#123;% include \"socialaccount/snippets/provider_list.html\" with process=\"login\" %&#125;&lt;/ul&gt;&lt;div class=\"login-or\"&gt;&#123;% trans 'or' %&#125;&lt;/div&gt;&lt;/div&gt;&#123;% include \"socialaccount/snippets/login_extra.html\" %&#125;&#123;% else %&#125;&lt;p&gt;&#123;% blocktrans %&#125;If you have not created an account yet, then please&lt;a href=\"&#123;&#123; signup_url &#125;&#125;\"&gt;sign up&lt;/a&gt; first.&#123;% endblocktrans %&#125;&lt;/p&gt;&#123;% endif %&#125;&lt;form class=\"login\" method=\"POST\" action=\"&#123;% url 'account_login' %&#125;\"&gt;&#123;% csrf_token %&#125;&#123;&#123; form.as_p &#125;&#125;&#123;% if redirect_field_value %&#125;&lt;input type=\"hidden\" name=\"&#123;&#123; redirect_field_name &#125;&#125;\" value=\"&#123;&#123; redirect_field_value &#125;&#125;\" /&gt;&#123;% endif %&#125;&lt;a class=\"button secondaryAction\" href=\"&#123;% url 'account_reset_password' %&#125;\"&gt;&#123;% trans \"Forgot Password?\" %&#125;&lt;/a&gt;&lt;button class=\"primaryAction\" type=\"submit\"&gt;&#123;% trans \"Sign In\" %&#125;&lt;/button&gt;&lt;/form&gt;&#123;% endblock %&#125; widget_tweaks를 사용하면 만들어진 폼을 별도로 처리하고싶을 때 편하게 처리할 수 있다. 다음과 같이 django-widget-tweaks를 설치한다. 1$ pip install django-widget-tweaks settings.py의 INSTALLED_APPS에 추가한다. 1234INSTALLED_APPS = [ #... 'widget_tweaks',] 가져온 login.html에서 원하는 부분만 수정한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!--// 원하는 부분만 커스텀한 login.html 화면 //--&gt;&#123;% extends 'base.html' %&#125;&#123;% load i18n %&#125;&#123;% load account socialaccount %&#125;&#123;% block head_title %&#125;&#123;% trans \"Sign In\" %&#125;&#123;% endblock %&#125;&#123;% block content %&#125;&#123;% get_providers as socialaccount_providers %&#125;&lt;div class=\"alert alert-info mt-3\" role=\"alert\"&gt; &lt;h4 class=\"alert-heading\"&gt;&#123;% trans \"Sign In\" %&#125;&lt;/h4&gt; &#123;% if socialaccount_providers %&#125; &lt;p&gt;&#123;% blocktrans with site.name as site_name %&#125;Please sign in with one of your existing third party accounts. Or, &lt;a href=\"&#123;&#123;signup_url&#125;&#125;\"&gt;sign up&lt;/a&gt; for a &#123;&#123; site_name &#125;&#125; account and sign in below:&#123;% endblocktrans %&#125;&lt;/p&gt; &lt;div class=\"socialaccount_ballot\"&gt; &lt;ul class=\"socialaccount_providers\"&gt; &#123;% include \"socialaccount/snippets/provider_list.html\" with process=\"login\" %&#125; &lt;/ul&gt; &lt;/div&gt; &#123;% include \"socialaccount/snippets/login_extra.html\" %&#125; &#123;% else %&#125; &lt;p&gt;&#123;% blocktrans %&#125;If you have not created an account yet, then please &lt;a href=\"&#123;&#123; signup_url &#125;&#125;\"&gt;sign up&lt;/a&gt; first.&#123;% endblocktrans %&#125;&lt;/p&gt; &#123;% endif %&#125;&lt;/div&gt;&lt;hr&gt;&#123;% load widget_tweaks %&#125;&lt;form class=\"login\" method=\"POST\" action=\"&#123;% url 'account_login' %&#125;\"&gt; &#123;% csrf_token %&#125; &lt;div class=\"form-group\"&gt; &lt;label&gt;&#123;&#123;form.login.label&#125;&#125;&lt;/label&gt; &#123;% render_field form.login class=\"form-control\" placeholder='Email Or Username' %&#125; &#123;% for error in form.login.errors %&#125; &lt;span class=\"help-block\"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &#123;% endfor %&#125; &lt;small class=\"form-text text-muted\"&gt;We'll never share your email with anyone else.&lt;/small&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;&#123;&#123;form.password.label&#125;&#125;&lt;/label&gt; &#123;% render_field form.password class=\"form-control\" placeholder='User password' %&#125; &#123;% for error in form.password.errors %&#125; &lt;span class=\"help-block\"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% if redirect_field_value %&#125; &lt;input type=\"hidden\" name=\"&#123;&#123; redirect_field_name &#125;&#125;\" value=\"&#123;&#123; redirect_field_value &#125;&#125;\"/&gt; &#123;% endif %&#125; &lt;a class=\"btn btn-info btn-sm\" href=\"&#123;% url 'account_reset_password' %&#125;\"&gt;&#123;% trans \"Forgot Password?\" %&#125;&lt;/a&gt; &lt;button class=\"btn btn-primary btn-sm\" type=\"submit\"&gt;&#123;% trans \"Sign In\" %&#125;&lt;/button&gt;&lt;/form&gt;&#123;% endblock %&#125; 로그인할 때 추가한 소셜 로그인 목록에 대한 template 파일은 다음과 같다. socialaccount/snippets/provider_list.html 위와 같은 폴더 이름으로 폴더와 파일을 생성하고 이미 만들어진 내용을 가져와서 수정해보자.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.06.07 Django Study","slug":"190607-Django-Study","date":"2019-06-07T05:27:00.000Z","updated":"2019-06-21T05:28:26.888Z","comments":true,"path":"2019/06/07/190607-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/06/07/190607-Django-Study/","excerpt":"","text":"new blog Project Create, Update, Delete View를 구현한다. Views.py에 추가 작성한다. 12345678910111213141516171819202122232425262728293031323334353637383940class PostUpdate(UpdateView): model = Post template_name = 'post/post_update.html' fields = ['title','text','tag'] # success_url =&gt; get_abslute_urlfrom django.urls import reverse_lazyclass PostDelete(DeleteView): model = Post template_name = 'post/post_delete.html' success_url = reverse_lazy('post:post_list')from django.utils.text import slugifyclass PostCreate(CreateView): model = Post template_name = 'post/post_create.html' fields = ['title', 'text', 'tag'] def form_valid(self, form): # 작성자 매칭 - form.instance.author_id = self.request.user.id # 관리자 페이지에서만 title 값이 slug가 된다. # slugify를 사용해서 title의 값을 slug 값으로 한다. form.instance.slug = slugify(form.instance.title, allow_unicode=True) return super().form_valid(form)# tag 기능 구현from tagging.views import TaggedObjectListclass PostTaggedObjectList(TaggedObjectList): model = Post allow_empty = True template_name = 'post/post_list.html'from django.views.generic import TemplateViewclass TagList(TemplateView): template_name = 'post/tag_list.html' urls.py에 경로를 추가한다. 123456789101112131415from django.urls import pathfrom .views import *app_name = 'post'urlpatterns = [ path('tags/', TagList.as_view(), name='tag_list'), path('tags/&lt;tag&gt;/', PostTaggedObjectList.as_view(), name='post_taggedlist'), path('create/', PostCreate.as_view(), name='post_create'), path('delete/&lt;int:pk&gt;/', PostDelete.as_view(), name='post_delete'), path('update/&lt;int:pk&gt;/', PostUpdate.as_view(), name='post_update'), path('detail/&lt;slug&gt;/', PostDetail.as_view(), name='post_detail'), path('&lt;category_slug&gt;/', PostList.as_view(), name='post_list_with_category'), path('', PostList.as_view(), name='post_list')] template 파일을 생성하고 작성한다. post/templates/post/post_create.html12345678910111213141516171819202122232425&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Create - &#123;&#123;object.title|truncatechars:15&#125;&#125;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row mt-3\"&gt; &lt;div class=\"col\"&gt; &#123;% include 'post/category_list.html' %&#125; &lt;/div&gt; &lt;div class=\"col-8\"&gt; &lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123;form.media&#125;&#125; &lt;table class=\"table table-striped\"&gt; &#123;&#123;form.as_table&#125;&#125; &lt;/table&gt; &lt;input type=\"submit\" class=\"btn btn-primary\" value=\"Write\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; layout/base.html 123456 &lt;!--// create 관련 기능 추가 //--&gt; &#123;% if user.is_authenticated %&#125; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"&#123;% url 'post:post_create' %&#125;\"&gt;Write&lt;/a&gt; &lt;/li&gt;&#123;% endif %&#125; post/templates/post/post_update.html 12345678910111213141516171819202122232425&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Update - &#123;&#123;object.title|truncatechars:15&#125;&#125;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row mt-3\"&gt; &lt;div class=\"col\"&gt; &#123;% include 'post/category_list.html' %&#125; &lt;/div&gt; &lt;div class=\"col-8\"&gt; &lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123;form.media&#125;&#125; &lt;table class=\"table table-striped\"&gt; &#123;&#123;form.as_table&#125;&#125; &lt;/table&gt; &lt;input type=\"submit\" class=\"btn btn-primary\" value=\"Update\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; post/templates/post/post_delete.html 12345678910111213141516171819202122&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Delete - &#123;&#123;object.title|truncatechars:15&#125;&#125;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row mt-3\"&gt; &lt;div class=\"col\"&gt; &#123;% include 'post/category_list.html' %&#125; &lt;/div&gt; &lt;div class=\"col-8\"&gt; &lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &lt;input type=\"submit\" class=\"btn btn-danger\" value=\"Delete\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; post/templates/post/post_detail.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;&#123;&#123;object.title|truncatechars:15&#125;&#125;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row mt-3\"&gt; &lt;div class=\"col\"&gt; &#123;% include 'post/category_list.html' %&#125; &lt;/div&gt; &lt;div class=\"col-8\"&gt; &lt;div class=\"row\" style=\"padding-bottom:3px; border-bottom:2px dashed #000000;\"&gt; &lt;div class=\"col-sm\"&gt; &lt;span style=\"color:red;\"&gt;[&#123;&#123;object.category&#125;&#125;]&lt;/span&gt; &lt;span style=\"font-weight:bold;\"&gt;&#123;&#123;object.title&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"col-sm text-muted\" style=\"text-align:right; font-size:0.9em;\"&gt;&#123;&#123;object.formatcreated2&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;br&gt; &#123;&#123;object.text|safe&#125;&#125; &lt;!--// 태그 기능 추가 //--&gt; &#123;% load tagging_tags %&#125; &#123;% tags_for_object object as tags %&#125; &#123;% if tags %&#125; Tags : &#123;% for tag in tags %&#125; &lt;a href=\"&#123;% url 'post:post_taggedlist' tag.name %&#125;\"&gt;#&#123;&#123;tag.name&#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &#123;% endif %&#125; &lt;!--// 수정, 삭제 기능 추가 //--&gt; &lt;div class=\"row\" style=\"padding-bottom:3px; border-bottom:2px dashed #000000;\"&gt; &lt;div class=\"col-sm\"&gt;&lt;/div&gt; &lt;div class=\"col-sm\" style=\"text-align:right;\"&gt; &#123;% if user.is_authenticated %&#125; &lt;a href=\"&#123;% url 'post:post_update' object.id %&#125;\"&gt;[수정]&lt;/a&gt; &lt;a href=\"&#123;% url 'post:post_delete' object.id %&#125;\" style=\"color:red\"&gt;[삭제]&lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; post/templates/post/tag_list.html 1234567891011121314&lt;!--//tag list 출력자주 나오는 tag일수록 글자 사이즈가 크게 출력된다.//--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Tag List&#123;% endblock %&#125;&#123;% block content %&#125;&#123;% load tagging_tags %&#125;&#123;% tag_cloud_for_model post.Post as post_tags with steps=9 min_count=1 distribution=log %&#125; &#123;% for tag in post_tags %&#125; &lt;a href=\"&#123;% url 'post:post_taggedlist' tag.name %&#125;\" style=\"font-size:&#123;&#123;tag.font_size&#125;&#125;em;\"&gt;&#123;&#123;tag&#125;&#125;&lt;/a&gt; &#123;% endfor %&#125;&#123;% endblock %&#125; Comment 앱을 생성해서 Comment 기능을 추가한다. comment 앱을 생성한다. 123$ python manage.py startapp comment# 잊지말고 settings.py의 INSTALLED_APPS에 추가하자. models.py를 작성한다. 12345678910111213141516171819202122232425from django.db import modelsfrom django.contrib.auth import get_user_modelfrom django.contrib.contenttypes.fields import GenericForeignKeyfrom django.contrib.contenttypes.models import ContentTypeclass Comment(models.Model): \"\"\" 1. 작성자 2. 어떤 모델과의 관계가 있는지 3. + 작성자가 없다면, 모델과의 관계가 없다면 \"\"\" author = models.ForeignKey(get_user_model(), on_delete=models.CASCADE, related_name='my_comments') # ContentType 사용 content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE) object_id = models.PositiveIntegerField() content_object = GenericForeignKey('content_type', 'object_id') text = models.CharField(max_length=400) created = models.DateTimeField(auto_now_add=True) def formatcreated(self): return self.created.strftime('%Y.%m.%d. %H:%M')# migrate를 잊지 말자. admin.py를 작성한다. 123456from django.contrib import admin# Register your models here.from .models import Commentadmin.site.register(Comment) views.py를 작성한다. 1234567891011121314151617181920212223242526272829303132333435from django.shortcuts import renderfrom .forms import CommentFormfrom django.shortcuts import redirectfrom django.urls import resolvefrom urllib.parse import urlparsefrom .models import Commentfrom django.contrib import messagesdef add_comment(request): if not request.user.is_anonymous: comment_form = CommentForm(request.POST) comment_form.instance.author_id = request.user.id if comment_form.is_valid(): comment_form.save() messages.add_message(request, messages.SUCCESS, \"댓글을 작성하였습니다.\") else: messages.add_message(request, messages.WARNING, \"Comment Invalid\") else: messages.add_message(request, messages.WARNING, \"댓글은 로그인 사용자만 남길 수 있습니다.\") referer = request.META['HTTP_REFERER'] return redirect(referer)def delete_comment(request, pk): comment = Comment.objects.filter(pk=pk) if comment.exists() and comment[0].author == request.user: comment.delete() messages.add_message(request, messages.SUCCESS, \"댓글을 삭제하였습니다.\") else: messages.add_message(request, messages.WARNING, \"댓글을 삭제할 수 없습니다.\") referer = request.META['HTTP_REFERER'] return redirect(referer) urls.py를 작성한다. config/urls.py 1234urlpatterns = [ #... path('comment/', include('comment.urls')),] comment/urls.py 1234567from django.urls import pathfrom .views import *urlpatterns = [ path('delete_comment/&lt;int:pk&gt;', delete_comment, name='delete_comment'), path('add_comment/', add_comment, name='add_comment'),] template 파일을 생성하고 작성한다. comment/templates/comment/show_comment.html 123456789101112131415161718192021222324&lt;form action=\"&#123;% url 'add_comment' %&#125;\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123;form.as_p&#125;&#125; &lt;input type=\"submit\" class=\"btn btn-outline-dark btn-sm\" value=\"등록\"&gt;&lt;/form&gt;&lt;br&gt;&lt;table class=\"table table\"&gt; &lt;tr&gt; &lt;th colspan=\"3\" class=\"align-left\" style=\"color:red\"&gt;댓글 &#123;&#123;object_list.count&#125;&#125;&lt;/th&gt; &lt;/tr&gt; &#123;% for object in object_list %&#125; &lt;tr&gt; &lt;td&gt; &lt;span style=\"font-weight:bold;\"&gt;&#123;&#123;object.author.username&#125;&#125;&lt;/span&gt; &lt;span style=\"font-size:0.8em;\" class=\"text-muted\"&gt;&#123;&#123;object.formatcreated&#125;&#125;&lt;/span&gt; &#123;% if object.author == user %&#125; &lt;a href=\"&#123;% url 'delete_comment' object.id %&#125;\" style=\"color:red\"&gt;&lt;small&gt;[삭제]&lt;/small&gt;&lt;/a&gt; &#123;% endif %&#125; &lt;br&gt; &#123;&#123;object.text&#125;&#125; &lt;/td&gt; &lt;/tr&gt;&#123;% endfor %&#125; &lt;/table&gt; layout/base.html 12345678910&lt;!--// 댓글과 관련한 메세지 기능 추가 //--&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt; &#123;% if messages %&#125; &#123;% for message in messages %&#125; &lt;div class=\"alert alert-&#123;&#123;message.tags&#125;&#125;\"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &#123;% endfor %&#125; &#123;% endif%&#125; &lt;/div&gt;&lt;/div&gt; templatetags 파일을 생성하고 작성한다. comment/templatetags/comment.py 1234567891011121314151617181920from django.template.loader import render_to_stringfrom django.contrib.contenttypes.models import ContentTypefrom django.template import Libraryregister = Library()from comment.forms import CommentFormfrom comment.models import Comment@register.simple_tag(takes_context=True)def show_comment(context, content_type, object_id): # 폼 만들기 content_type = ContentType.objects.get_for_model(content_type) form = CommentForm(initial=&#123;'content_type':content_type, 'object_id':object_id&#125;) # 해당 하는 댓글 목록 뽑기 comments = Comment.objects.filter(content_type=content_type, object_id=object_id).all() # 템플릿 렌더링 return render_to_string('comment/show_comment.html',&#123;'form':form, 'object_list':comments&#125;, request=context['request']) post/templates/post/detail.html에 comment 기능을 추가한다. 12&#123;% load comment %&#125;&#123;% show_comment content_type=object object_id=object.id %&#125;","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.06.04 Django Study","slug":"190604-Django-Study","date":"2019-06-04T07:21:21.000Z","updated":"2019-06-05T07:25:08.138Z","comments":true,"path":"2019/06/04/190604-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/06/04/190604-Django-Study/","excerpt":"","text":"new blog Project 새로운 블로그 웹 사이트를 만들어본다. 프로젝트를 생성하고 django를 설치한다. 1$ pip install django django project를 만든다. 1$ django-admin startproject config . 다음 항목을 설치하고 해당 관련 항목들의 코드를 추가하도록 한다. 1234567891011121314151617# debug tool bar 설치$ pip install django-debug-toolbar# 모델 간의 관계도를 그리기 위해 extentions 설치$ pip install django-extensions# HTML 편집기를 사용하기 위해 ckeditor 설치$ pip install django-ckeditor# tag 기능을 사용하기 위해 tagging 설치$ pip install django-tagging# static 파일을 서빙하기 위해 whitenoise 설치$ pip install whitenoise# 의존성 리스트 생성$ pip freeze &gt; requirements.txt post라는 이름을 가진 앱을 만든다. 1python manage.py startapp post models.py를 작성한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243# post/models.pyfrom django.db import modelsfrom ckeditor_uploader.fields import RichTextUploadingFieldfrom tagging.fields import TagFieldfrom django.shortcuts import resolve_url# Create your models here.class Category(models.Model): name = models.CharField(max_length=100) slug = models.SlugField(max_length=120, unique=True, allow_unicode=True, db_index=True) # 상위 카테고리를 만들기 위해 parent_category = models.ForeignKey(\"self\", on_delete=models.SET_NULL, blank=True, null=True) def __str__(self): return self.name def get_absolute_url(self): return resolve_url('post:post_list_with_category', self.slug)class Post(models.Model): category = models.ForeignKey(Category, on_delete=models.SET_NULL, blank=True, null=True) title = models.CharField(max_length=100) slug = models.SlugField(max_length=120, unique=True, allow_unicode=True, db_index=True) text = RichTextUploadingField() material = models.FileField(upload_to='material/%Y/%m/%d',blank=True) tag = TagField(blank=True) created = models.DateTimeField(auto_now_add=True) updated = models.DateTimeField(auto_now=True) def __str__(self): return self.title + \" at \" + self.created.strftime(\"%Y-%m-%d\") def get_absolute_url(self): return resolve_url('post:post_detail', self.slug) # 날짜.월.일만 나오는 포맷을 사용하고 싶어서 추가 def formatcreated(self): return self.created.strftime('%Y.%m.%d') def formatupdated(self): return self.updated.strftime('%Y.%m.%d')# 모델 설계가 끝났다면 반드시 makemigrations와 migrate를 진행한다. admin.py를 작성한다. 123456789101112131415# post/admin.pyfrom django.contrib import adminfrom .models import *class CategoryAdmin(admin.ModelAdmin): list_display = ['id','name','slug'] prepopulated_fields = &#123;'slug':('name',)&#125;admin.site.register(Category, CategoryAdmin)class PostAdmin(admin.ModelAdmin): list_display = ['id','title','slug','created','updated'] ordering = ['-updated','-created'] prepopulated_fields = &#123;'slug': ('title',)&#125;admin.site.register(Post, PostAdmin) views.py를 작성한다. 123456789101112131415161718192021222324252627282930# post/views.pyfrom django.shortcuts import renderfrom django.views.generic.list import ListViewfrom django.views.generic.edit import CreateView, UpdateView, DeleteViewfrom django.views.generic.detail import DetailViewfrom .models import *class PostList(ListView): model = Post # paginate 테스트를 위해 1로 설정 paginate_by = 1 template_name = 'post/post_list.html' # 해당 category에 속한 리스트만을 불러오기 위해 def get_queryset(self): queryset = super().get_queryset() if 'category_slug' in self.kwargs: try: category = Category.objects.get(slug=self.kwargs['category_slug']) queryset = queryset.filter(category=category) except: pass return querysetclass PostDetail(DetailView): model = Post template_name = 'post/post_detail.html' context_processors.py를 생성하고 작성한 후, settings.py도 수정한다. 12345678910111213141516171819202122232425262728# context 항목을 만드는 데 있어서 중복 작업이 있을 경우,# context_processors를 만들어서 사용하면 중복 작업을 제거할 수 있다.# post/contest_processors.pyfrom .models import Category# 상위 카테고리만 구별하기 위해def category(request): categories = Category.objects.filter(parent_category=None) return &#123;'categories': categories&#125;# config/settings.pyTEMPLATES = [ &#123; #... 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', # 추가 'post.context_processors.category', ], &#125;, &#125;,] urls.py를 작성한다. 123456789101112131415161718192021222324252627282930313233# config/urls.pyfrom django.contrib import adminfrom django.views.static import servefrom django.urls import path,re_path, includefrom django.conf import settingsurlpatterns = [ path('admin/', admin.site.urls), path('ckeditor/', include('ckeditor_uploader.urls')), re_path(r'^media/(?P&lt;path&gt;.*)$', serve, &#123;'document_root':settings.MEDIA_ROOT&#125;), # post.urls 추가 path('', include('post.urls'))]if settings.DEBUG: import debug_toolbar urlpatterns = [ path('__debug__/', include(debug_toolbar.urls)), ] + urlpatterns# post/urls.pyfrom django.urls import pathfrom .views import *app_name = 'post'urlpatterns = [ path('detail/&lt;slug&gt;/', PostDetail.as_view(), name='post_detail'), path('&lt;category_slug&gt;/', PostList.as_view(), name='post_list_with_category'), path('', PostList.as_view(), name='post_list')] template 파일을 생성하고 작성한다. layout/base.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&#123;% block title %&#125;Blog&#123;% endblock %&#125;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" crossorigin=\"anonymous\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;nav class=\"navbar navbar-expand-lg navbar-light bg-light sticky-top\"&gt; &lt;a class=\"navbar-brand\" href=\"/\"&gt;Blog&lt;/a&gt; &lt;button class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"&gt; &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\"&gt; &lt;ul class=\"navbar-nav mr-auto\"&gt; &lt;li class=\"nav-item active\"&gt; &lt;a class=\"nav-link\" href=\"/\"&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Blog&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Guest Book&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=\"form-inline my-2 my-lg-0\"&gt; &lt;input class=\"form-control mr-sm-2\" type=\"search\" placeholder=\"Search\" aria-label=\"Search\"&gt; &lt;button class=\"btn btn-outline-success my-2 my-sm-0\" type=\"submit\"&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/nav&gt; &#123;% block content %&#125; &#123;% endblock %&#125;&lt;/div&gt;&lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\" integrity=\"sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\" integrity=\"sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; post/templates/post/post_list.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#123;% extends 'base.html' %&#125;&#123;% block content %&#125;&lt;div class=\"row mt-3\"&gt; &lt;div class=\"col col-md-2\"&gt; &lt;!-- category --&gt; &#123;% include 'post/category_list.html' %&#125; &lt;/div&gt; &lt;div class=\"col-10 col-md-8\"&gt; &lt;!-- list --&gt; &lt;table class=\"table table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;title&lt;/th&gt; &lt;th&gt;created&lt;/th&gt; &lt;th&gt;updated&lt;/th&gt; &#123;% if user.is_authenticated %&#125; &lt;th&gt;update&lt;/th&gt; &lt;th&gt;delete&lt;/th&gt; &#123;% endif %&#125; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for object in object_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;object.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=\"&#123;&#123;object.get_absolute_url&#125;&#125;\"&gt;&#123;&#123;object.title&#125;&#125;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&#123;&#123;object.formatcreated&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;object.formatupdated&#125;&#125;&lt;/td&gt; &#123;% if user.is_authenticated %&#125; &lt;th&gt;&lt;a href=\"&#123;% url 'post:post_update' object.id %&#125;\"&gt;update&lt;/a&gt;&lt;/th&gt; &lt;th&gt;&lt;a href=\"&#123;% url 'post:post_delete' object.id %&#125;\"&gt;delete&lt;/a&gt;&lt;/th&gt; &#123;% endif %&#125; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &#123;% if is_paginated %&#125; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination justify-content-center\"&gt; &#123;% if page_obj.has_previous %&#125; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" href=\"?page=&#123;&#123;page_obj.previous_page_number&#125;&#125;\"&gt;Previous&lt;/a&gt; &lt;/li&gt; &#123;% else %&#125; &lt;li class=\"page-item disabled\"&gt;&lt;a class=\"page-link\" href=\"#\"&gt;Previous&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% for page in paginator.page_range %&#125; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" href=\"?page=&#123;&#123;page&#125;&#125;\"&gt;&#123;&#123;page&#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &#123;% if page_obj.has_next %&#125; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" href=\"?page=&#123;&#123;page_obj.next_page_number&#125;&#125;\"&gt;Next&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li class=\"page-item disabled\"&gt;&lt;a class=\"page-link\" href=\"#\"&gt;Next&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt; &lt;/nav&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; post/templates/post/category_list.html 12345&lt;div class=\"accordion\" id=\"category_list\"&gt; &#123;% for category in categories %&#125; &#123;% include 'post/part_category_list.html' %&#125; &#123;% endfor %&#125;&lt;/div&gt; post/templates/post/part_category_list.html 12345678910111213141516171819202122232425&lt;div &#123;% if parent_id %&#125; class=\"collapse card category_sub_&#123;&#123;parent_id&#125;&#125;\" &#123;% else %&#125; class=\"card\" &#123;% endif %&#125;&gt; &lt;div class=\"card-header\" style=\"padding:0;\"&gt; &lt;h2 class=\"mb-0\"&gt; &#123;% if parent_id %&#125; &lt;a class=\"btn btn-link\" href=\"&#123;&#123;category.get_absolute_url&#125;&#125;\"&gt; &#123;&#123;category&#125;&#125; &lt;/a&gt; &#123;% else %&#125; &lt;button class=\"btn btn-link\" type=\"button\" data-toggle=\"collapse\" data-target=\".category_sub_&#123;&#123;category.id&#125;&#125;\" aria-expanded=\"false\"&gt; &#123;&#123;category&#125;&#125; &lt;/button&gt; &#123;% endif %&#125; &lt;/h2&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- related_name을 쓰지 않았기 때문에 [default_name]_set으로 불러온다. --&gt;&#123;% if category.category_set %&#125;&lt;!-- category.id를 parent_id로 사용 --&gt;&#123;% with category.id as parent_id %&#125;&#123;% for category in category.category_set.all %&#125;&#123;% include 'post/part_category_list.html' %&#125;&#123;% endfor %&#125;&#123;% endwith %&#125;&#123;% endif %&#125; post/templates/post/post_detail.html 12345678910111213141516171819202122&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;&lt;!-- 커스텀 템플릿 태그 --&gt;&lt;!-- truncatechars : 문자열을 지정 글자 개수까지 제한 --&gt;&#123;&#123;object.title|truncatechars:15&#125;&#125;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row mt-3\"&gt; &lt;div class=\"col\"&gt; &#123;% include 'post/category_list.html' %&#125; &lt;/div&gt; &lt;div class=\"col-8\"&gt; &#123;&#123;object.text|safe&#125;&#125; Tags : &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; 커스텀 템플릿 태그 만들기 커스텀 탬플릿 태그를 만들렸면 templatetags 폴더를 만들어야 한다. templatetags에 작성한 파일 이름으로 템플릿 파일에서 불러올 수 있다. 템플릿 라이브러리 변수를 만든다. 12345# templatetags/exam.pyfrom django import templateregister = template.Library() 필터를 등록할 때는 다음과 같이 사용한다. 12345# templatetags/exam.py@ register.filterdef add_two(value): return value + 2 등록한 필터는 다음과 같이 사용한다. 12&#123;% load exam %&#125;&#123;&#123;변수|add_two&#125;&#125; 추가 인자가 있는 필터는 다음과 같이 사용한다. 12345# templatetags/exam.py@register.filterdef string_append(left, right): return left+\"-\"+right 등록한 필터는 다음과 같이 사용한다. 12&#123;% load exam %&#125;&#123;&#123;'string1'|string_append:'string2'&#125;&#125; 태그를 등록할 때는 다음과 같이 사용한다. 123@register.simple_tagdef print_template(): return render_to_string('exam/test.html') 등록한 태그는 다음과 같이 사용한다. 1234567&#123;% load exam %&#125;&#123;% print_template %&#125;&lt;!-- 태그 결과를 변수로 지정할 경우 --&gt;&#123;% load exam %&#125;&#123;% print_template as test %&#125;&#123;&#123;test&#125;&#125;","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.06.03 Django Study","slug":"190603-Django-Study","date":"2019-06-03T07:21:17.000Z","updated":"2019-08-08T12:40:57.329Z","comments":true,"path":"2019/06/03/190603-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/06/03/190603-Django-Study/","excerpt":"","text":"blog Project 멀티데이터베이스 만들기 데이터베이스도 스케일링을 고려해야 함 마스터 + 슬레이브(읽기 전용)의 형태 마스터로 사용할 데이터베이스를 생성한다. Amazon AWS에서 데이터베이스/RDS를 누른다. 데이터베이스 생성을 누른다. PostgreSQL 선택 및 화면 하단의 RDS 프리티어에 적용되는 옵션만 사용에 체크한다. DB 엔진 버전은 PostgreSQL 10.6-R1 선택한다. PostgreSQL 9.3.5 이상부터 일기 전용 복제본을 사용할 수 있다. 용량은 20Gib로 설정하고 관리자 정보를 입력한다. 퍼블릭 엑세스 가능성은 ‘예’를 선택한다. 실습 환경에서는 [예]를 선택하고, 프로덕션 환경에서는 꼭 [아니오]로 변경한다. 데이터베이스 이름을 입력하고 백업 보존 기간은 1일로 설정한다. 읽기 전용 복제본을 만들려면 백업 기능이 활성화되어 있어야 한다. 성능 개선 도우미는 비활성화하고 데이터베이스 생성을 누른다. 인스턴스 생성이 완료되면 settings.py의 DATABESES 부분을 수정한다. 123456789101112 # pip install psycopg2-binary를 설치하자.DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': '데이터베이스 이름', 'USER':'마스터 사용자 이름', 'PASSWORD':'마스터 사용자 비밀번호', 'HOST':'아마존 RDS의 엔드포인트', 'POST':'데이터베이스 접속 포트번호', &#125;, &#125; 수정이 완료되면 migrate한다. 1$ python manage.py migrate 슬레이브(읽기 전용)로 사용할 데이터베이스를 생성한다. 마스터로 사용할 데이터베이스를 누른 후, 상단 메뉴의 작업에서 읽기 복제본 생성을 누른다. 생성 창이 나타나면 퍼블릭 엑세스 가능 부분에서 예를 누른다. 데이터베이스 식별자를 입력한다. 읽기 전용 복제본 생성을 누른다. 위와 같은 방법으로 하나를 더 생성한다. 123- 퍼블릭 엑세스 가능과 데이터베이스 식별자를 잘 설정한다.- 복제본을 생성하는 것이기 때문에 옵션을 모두 건드릴 필요가 없다.- 읽기 데이터베이스인 경우, 높은 사양을 원한다면 인스턴스 사양을 올릴 수 있다. settings.py의 DATABESES 정보를 추가한다. 1234567891011121314151617181920212223242526272829DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'multi', 'USER':'마스터 사용자 이름', 'PASSWORD':'마스터 사용자 비밀번호', 'HOST':'마스터 전용 데이터베이스의 엔드포인트', 'POST':'5432', &#125;, # 복제했기 때문에 다른 것은 모두 같으나, HOST만 달라지게 된다. # 엔드 포인트 주소를 잘 확인하자. # 식별자가 다를 뿐 데이터베이스의 이름은 모두 같다. 'read1': &#123; 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'multi', 'USER':'마스터 사용자 이름', 'PASSWORD':'마스터 사용자 비밀번호', 'HOST':'첫 번째 읽기 전용 데이터베이스의 엔드포인트', 'POST':'5432', &#125;, 'read2': &#123; 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'multi', 'USER':'마스터 사용자 이름', 'PASSWORD':'마스터 사용자 비밀번호', 'HOST':'두 번째 읽기 전용 데이터베이스의 엔드포인트', 'POST':'5432', &#125;&#125; 라우터 클래스를 만들어서 추가한다. 1234567891011121314151617181920212223# config/master_slave_router.py# 자동으로 쓰기, 읽기 데이터베이스를 분기해서 사용하는 것이 아니기 때문이다.import randomclass MasterSlaveRouter: def db_for_read(self, model, **hints): return random.choice(['read1', 'read2']) def db_for_write(self, model, **hints): return 'default' # return None으로 대체 가능 def allow_relation(self, obj1, obj2, **hints): db_list = ('default', 'read1', 'read2') if obj1._state.db in db_list and obj2.state_db in db_list: return True return None # return None의 의미 # 다음 라우터에게 물어보겠다 # 전부 default에 넣겠다 def allow_migrate(self, db, app_label, model_name=None, **hints): return True settings.py에 만든 라우터를 추가한다. 1DATABASE_ROUTERS = ['config.master_slave_router.MasterSlaveRouter'] debug toolbar를 설치한다. 12# debug toolbar$ pip install django-debug-toolbar 123456789101112131415161718192021222324252627282930# settings.py# INSTALLED_APPS에 항목 추가INSTALLED_APPS = [ #... 'debug_toolbar',]# MIDDLEWARE에 항목 추가MIDDLEWARE = [ #... 'debug_toolbar.middleware.DebugToolbarMiddleware',]# debug = True, internal_ipsINTERNAL_IPS = ['127.0.0.1']DEBUG_TOOLBAR_PANELS = [ 'debug_toolbar.panels.versions.VersionsPanel', 'debug_toolbar.panels.timer.TimerPanel', 'debug_toolbar.panels.settings.SettingsPanel', 'debug_toolbar.panels.headers.HeadersPanel', 'debug_toolbar.panels.request.RequestPanel', 'debug_toolbar.panels.sql.SQLPanel', 'debug_toolbar.panels.staticfiles.StaticFilesPanel', 'debug_toolbar.panels.templates.TemplatesPanel', 'debug_toolbar.panels.cache.CachePanel', 'debug_toolbar.panels.signals.SignalsPanel', 'debug_toolbar.panels.logging.LoggingPanel', 'debug_toolbar.panels.redirects.RedirectsPanel',] 123456789# config.urls.pyfrom django.urls import path, includefrom django.conf import settingsif settings.DEBUG: import debug_toolbar urlpatterns = [ path('debug/', include(debug_toolbar.urls)), ] + urlpatterns 관리자 페이지로 접속하여 debug toolbar를 이용하여 데이터베이스를 확인한다. 유저 정보를 공유하기 위해 다른 프로젝트를 생성한다. Amazon AWS에서 RDS를 새로 생성하여 migrate까지 진행한다. 멀티데이터베이스를 진행한 프로젝트에서 settings.py의 DATABASES 정보를 추가한다. 123456789101112131415161718192021222324252627282930313233343536 DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'multi', 'USER':'마스터 사용자 이름', 'PASSWORD':'마스터 사용자 비밀번호', 'HOST':'마스터 전용 데이터베이스의 엔드포인트', 'POST':'5432', &#125;, 'read1': &#123; 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'multi', 'USER':'마스터 사용자 이름', 'PASSWORD':'마스터 사용자 비밀번호', 'HOST':'첫 번째 읽기 전용 데이터베이스의 엔드포인트', 'POST':'5432', &#125;, 'read2': &#123; 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'multi', 'USER':'마스터 사용자 이름', 'PASSWORD':'마스터 사용자 비밀번호', 'HOST':'두 번째 읽기 전용 데이터베이스의 엔드포인트', 'POST':'5432', &#125;, # 유저의 정보를 공유하기 위해 다른 프로젝트를 생성 # 다른 프로젝트에서 생성한 데이터베이스의 정보 'user': &#123; 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'base_user', 'USER':'마스터 사용자 이름', 'PASSWORD':'마스터 사용자 비밀번호', 'HOST': '추가로 생성한 데이터베이스의 엔드포인트', 'PORT': '5432', &#125;&#125; 유저의 정보 데이터베이스를 위한 라우터를 추가한다. 1234567891011121314151617181920212223# config/user_router.pyfrom django.conf import settingsclass UserRouter: def db_for_read(self, model, **hints): if model._meta.model_name == 'user': return 'user' return None def db_for_write(self, model, **hints): if model._meta.model_name == 'user': return 'user' return None def allow_relation(self, obj1, obj2, **hints): db_list = settings.DATABASES.keys() # settings에서 불러다가 사용할 수도 있다. if obj1._state.db in db_list and obj2._state.db in db_list: return True return None def allow_migrate(self, db, app_label, model_name=None, **hints): return True settings.py에 라우터를 추가한다. 12DATABASE_ROUTERS = ['config.user_router.UserRouter', 'config.master_slave_router.MasterSlaveRouter'] 관리자 페이지로 접속하여 멀티데이터베이스 프로젝트에서 로그인해본다. 유저 정보를 위한 프로젝트 관리자의 아이디로 접속이 된다. 멀티데이터베이스 프로젝트에서 유저를 생성해본다. 유저 정보 프로젝트에서 관리자 접속 후, 유저 정보를 확인해본다. 두 프로젝트의 유저 정보가 공유되는 것을 확인할 수 있다. EC2에 장고 배포하기(정리) 인스턴스를 생성한다. Amazon AWS에서 컴퓨팅/EC2로 이동한다. 인스턴스 시작을 누른다. Ubuntu server 18.04를 선택한다. 인스턴스 타입은 t2.micro를 선택한다. 서비스 상황에 따라 더 높은 사양을 선택하는 것도 생각하도록 하자. 인스턴스 세부 구성에서는 설정하지 않고 넘어간다. 스토리지 크기는 20Gib로, 볼륨 유형은 범용 SSD를 선택하고 넘어간다. 태그 추가에서는 설정하지 않고 넘어간다. 보안 그룹 구성에서는 새 보안 그룹을 선택하고 이름과 설명을 입력한다. ELB에 넣을 인스턴스를 생성하는 경우엔 기존 인스턴스와 같은 그룹을 선택하도록 한다, 검토 및 시작에서는 정보를 검토하고 시작하기를 누른다. 인스턴스에 접속하기 위해 새 키 파일 생성을 누른다. 키 페어 이름을 입력 후, 다운로드를 누르고 인스턴스를 시작한다. 인스턴스 보기를 누르고 목록을 확인 후, 생성한 인스턴스의 이름을 설정해둔다. 터미널에서 명령어를 입력한다. 다운로드 받은 키 페어 파일의 권한을 400으로 변경한다. 12# 키 페어 파일 경로도 가능$ chmod 400 [키 페어 파일 이름] 키 페어 파일을 .ssh 폴더로 이동시킨다. 1$ mv [키 페어 파일 이름] ~/.ssh/ 키 페어 파일을 이용하여 EC2 인스턴스에 ssh 접속을 한다. 1$ ssh -i [키 페어 파일 경로] [계정]@[EC2 접속 주소] 서버에 접속 후, 기존 패키지를 업데이트한다. 1$ sudo apt-get update Nginx를 설치한다. 1$ sudo apt-get install nginx vim을 설치한다. 1$ sudo apt-get install vim 파이썬 관련 패키지를 설치한다. 1$ sudo apt-get install python3-dev python3-venv python3-pip django 앱 구동용 계정을 생성한다. 1$ sudo useradd -b /home -m -s /bin/bash django www-data 그룹에 django 유저를 추가한다. 1$ sudo usermod -a -G www-data django www-data 그룹에 ubuntu 유저를 추가한다. 12# FTP로 업로드 시, ubuntu 계정을 사용하므로, 앱 소스 코드 폴더에 쓰기 권한을 얻기 위함$ sudo usermod -a -G Www-data ubuntu 소스 코드를 업로드하기 위한 폴더를 만든다. 12# -p는 중간 폴더가 없다면 자동 생성하게 해준다.$ sudo mkdir -p /var/www/django uswgi 모듈을 위해 폴더를 만든다. 123$ sudo mkdir /var/www/django/run$ sudo mkdir /var/www/django/logs$ sudo mkdir /var/www/django/ini uwsgi 설정 파일을 만든다. 1234567891011121314151617181920$ sudo vim /var/www/django/ini/uwsgi.ini# uwsgi.ini 내용[uwsgi]uid = djangobase = /var/www/djangohome = %(base)/venvchdir = %(base)module = config.wsgi:applicationenv = DJANGO_SETTINGS_MODULE=config.settingsmaster = trueprocesses = 5socket = %(base)/run/uwsgi.socklogto = %(base)/logs/uwsgi.logchown-socket = %(uid):www-datachmod-socket = 660vacuum = true 가상 환경을 소스 코드 폴더 밑에 만든다. 1$ sudo python3 -m venv /var/www/django/venv 소스 코드를 업로드하기 전에 폴더의 소유자와 사용 권한을 변경한다. 12$ sudo chown -R django:www-data /var/www/django$ sudo chmod -R g+w /var/www/django 파일질라를 실행하여 왼쪽 상단 탭에서 사이트 관리자로 들어간다. 새로운 사이트를 추가하고 접속 정보를 설정한다. 12345- 프로토콜 : SFTP- 호스트 : EC2의 접속 주소- 로그온 유형 : 키 파일- 사용자 : ubuntu- 키 파일 : 키 페어 파일 경로 지정 고급 탭에서 기본 로컬 디렉터리와 기본 리모트 디렉터리를 지정한다. 12기본 로컬 디렉터리 = pycharm으로 만든 프로젝트 폴더기본 리모트 디렉터리 = 소스 코드를 업로드할 폴더 설정이 완료되었다면 연결을 누른다. 처음 접속 시, 알 수 없는 호스트 창이 나타나면 캐시에 등록을 체크하고 확인을 누른다. 접속이 성공했다면, 소스 코드를 업로드한다. 가상 환경에 패키지를 설치하기 위해 소스 코드 폴더로 이동한다. 1$ cd /var/www/django 관리자 모드로 변경하고 가상 환경을 활성화시킨다. 12$ sudo -s$ source venv/bin/activate 의존성 리스트를 설치한다. 1$ pip install -r requirements.txt uwsgi를 설치한다. 1$ pip install uwsgi runserver 명령어를 통해 django project의 구동 여부를 확인한다. 1$ python manage.py runserver 0:8000 구동이 된다면 runserver를 종료하고, uwsgi 모듈로 구동 여부를 확인한다. 1$ uwsgi --http :8000 --home /var/www/django/venv/ --chdir /var/www/django/ --module config.wsgi 웹 브라우저를 통해 접속하여 구동이 된다면 uwsgi.service 파일을 작성한다. 123456789101112131415161718$ sudo vim /etc/systemed/system/uwsgi.service# uwsgi.service 내용[Unit]Description=uWSGI Emperor service[Service]ExecStart=/var/www/django/venv/bin/uwsgi --emperor /var/www/django/iniUser=djangoGroup=www-dataRestart=on-failureKillSignal=SIGQUITType=notifyNotifyAccess=allStandardError=syslog[Install]WantedBy=multi-user.target uwsgi의 서비스를 시작하고 시작 서비스로 등록한다. 12$ sudo systemctl start uwsgi$ sudo systemctl enable uwsgi 서비스 상태를 확인한다. 12# active 상태인지 확인하자.$ sudo systemctl status uwsgi Nginx의 default 파일을 수정한다. 1234567891011121314151617181920$ sudo vim /etc/nginx/sites-available/default# default 내용upstream django &#123; server unix:/var/www/django/run/uwsgi.sock;&#125;server &#123; listen 80; charset utf-8; access_log /var/www/django/logs/access.log; error_log /var/www/django/logs/error.log; server_name _; location = /favicon.ico &#123; access_log off; log_not_found off; &#125; location / &#123; include /etc/nginx/uwsgi_params; uwsgi_pass django; &#125;&#125; Nginx를 재시작한다. 1$ sudo systemctl restart nginx 웹 브라우저에 퍼블릭 DNS를 입력하고 구동 여부를 확인한다. 소스 코드의 업데이트를 위해서 아래 명령어를 실행해두자. 1$ sudo chmod -R g+w /var/www/django django와 관련된 부분이 수정이 된다면 uwsgi 서비스를 재시작해야 한다. 1$ sudo systemctl restart uwsgi 로드밸런서 설정하기 EC2 왼쪽 메뉴에서 로드 밸런서를 누른다. 로드밸런서 생성을 누르고 Application Load Balancer의 생성을 누른다. 다음으로, 로드밸런스의 이름을 입력하고 리스너를 만들어준다. HTTPS의 443을 추가한다. 가용 영역에서는 모두 체크하고 보안 설정 구성으로 넘어간다. 보안 설정 구성에서는 다음과 같이 설정한다. 인증서 유형은 ACM에서 인증서 선택을 누른다. 인증서 이름에는 기존에 생성한 인증서가 나타난다. 보안 정책은 ELBSecurityPolicy-2016-08을 선택한다. 보안 정책이 너무 최신일 경우, 폭넓게 지원하지 않는 문제가 있다. 보안 그룹 구성에서는 새 보안 그룹 생성을 누르고 이름과 설명을 입력한다. 라우팅 구성에서는 그룹의 이름을 입력하고 대상 등록으로 넘어간다. 프로토콜은 https(443)이 아닌 http(80)가 맞으므로 바꾸지 않아도 된다. 대상 등록에서는 미리 생성해둔 인스턴스를 추가하고 검토로 넘어간다. 검토 화면에서 내용을 확인하고 생성을 누른다. 생성이 완료되면 닫기를 누른다. 생성된 로드밸런서의 DNS 이름으로 웹 브라우저에 접속해보자.123456- https로만 접속하게 하고 싶을 경우1. 해당 로드밸런서에서 리스너에 http(80)을 편집으로 들어간다.2. 기본 작업에 다음으로 전달하는 값을 제거한다.3. 다음으로 리디렉션을 누르고 포트 번호를 443으로 설정한다.4. 체크를 누르고 업데이트를 누른다.5. 이제 https로만 접속되는지 확인한다. Route53을 통해 로드밸런서 등록하기 네트워킹 및 콘텐츠 전송/Route53으로 이동한다. 호스팅 영역에 등록한 도메인을 누르고 레코드 세트 생성을 누른다. 원하는 이름을 입력하고 별칭에서 예를 선택한다. 등록한 로드밸런서를 선택하고 생성한다. 웹 브라우저에서 https를 붙인 도메인 주소로 접속해본다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.31 Django Study","slug":"190531-Django-Study","date":"2019-05-31T07:21:12.000Z","updated":"2019-06-05T07:27:42.670Z","comments":true,"path":"2019/05/31/190531-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/31/190531-Django-Study/","excerpt":"","text":"blog Project ACM으로 SSL 인증서 발급받기 https 기능을 사이트에 적용하기 위해 ssl 인증서를 등록해야 한다. 로드밸런서를 사용하면 쉽게 인증서를 적용할 수 있다. Amazon에서는 ACM Service를 통해 무료로 인증서를 발급하고 있다. 서비스 탭에서 보안, 자격 증명 및 규정 준수/Certificate Manager를 누른다. 인증서 목록이 나타나면 인증서 요청을 누른다. 인증서 요청에서는 공인 인증서 요청을 선택한다. 도메인 이름 추가에서는 도메인 이름을 입력한다. *로 발급받으면 모든 서브 도메인에 적용이 가능하다.(와일드 카드 도메인)1ex) *.jinukk.me 검증 방법에서는 DNS 검증을 누르고 검토로 넘어간다. 내용을 확인하고 확인 및 요청을 누른다. 검증 단계에서는 검증 보류 메세지를 볼 수 있는데 도메인 주소 왼쪽 화살표를 누른다. 상세 정보에서 Route53에서 레코드 생성을 누른다. 레코드 내용을 확인하고 생성을 누른다. 생성 성공 메시지를 확인하면 계속을 누른다. 인증서 목록으로 돌아오면 검증 미완료 상태를 볼 수 있다. 일정 시간이 지나면 검증 완료가 되고 인증서가 발급된 것을 확인할 수 있다. ELB Setting 하기 ELB는 Amazon AWS의 Load Balancer Service 클래식, 네트워크, 애플리케이션 로드밸런서로 구성 복수의 서버에 적절한 트래픽을 분산시키기 위해 사용 서비스 탭에서 컴퓨팅/EC2를 누른다. EC2 왼쪽 메뉴에서 로드 밸런싱/로드밸런서를 누른다. 로드 밸런서 생성을 누른다. 유형은 Application Load Balancer의 생성을 누른다. 로드 밸런서 구성에서는 다음과 같이 설정한다. 이름을 입력한다. 리스너를 설정해준다. 가용 영역에서는 필요한 AZ를 체크한다. 보안 설정 구성에서는 HTTPS 관련 경고창이 나타나지만 넘어가도록 한다. 보안 그룹 구성에서는 이름과 설명을 입력하고 인바운드 규칙을 설정한다. 라우팅 구성에서는 그룹의 이름을 입력하고 넘어가도록 한다. 대상 등록에서는 미리 생성한 EC2 인스턴스를 선택하고 등록된 항목에 추가를 누른다. 검토 화면에서는 내용을 확인하고 생성을 누른다. 자동으로 생성이 진행되며, 절차가 끝나 완료가 나타나면 닫기를 누른다. 로드밸런서 목록에서 생성된 로드밸런서를 확인한다. 생성된 로드밸런서를 누르고 하단에 DNS 이름으로 접속해보자. 로드밸런서에 ssl 인증서 적용하기 인증서를 적용할 로드밸런서를 선택하고 리스너 탭에 잇는 리스너 추가를 누른다. HTTPS(443)을 설정하고 기본 작업은 다음으로 전달을 선택한 뒤, 리스너 그룹을 선택한다. 보안 정책은 ELBSecurityPolicy-2016-08을 선택한다. 기본 ssl 인증서는 ACM에서 발급받은 인증서를 선택하고 저장을 누른다. 성공적으로 생성함 메세지를 확인한다. 네트워킹 및 콘텐츠 전송/Route53으로 이동한다. 호스팅 영역에 등록한 도메인을 누르고 레코드 세트 생성을 누른다. 원하는 이름을 입력하고 별칭에서 예를 선택한다. 등록한 로드밸런서를 선택하고 생성한다. 웹 브라우저에서 https를 붙인 도메인 주소로 접속해본다. EC2 인스턴스의 이미지를 생성하여 ELB 그룹에 추가하기 해당 인스턴스의 오른쪽 클릭을 통해 이미지 생성을 누른다. 이미지 이름과 설명을 입력하고, 인스턴스 볼륨을 설정한다. 이름과 설명에는 생성한 날짜를 함께 적는 것이 좋다. 인스턴스 볼륨의 크기는 20Gib로, 유형은 범용 SSD를 선택하였다. EC2 왼쪽 메뉴에서 이미지/AMI를 누른다. 이미지 생성이 완료되면 시작하기를 누른다. 인스턴스 유형에서는 실습이므로 t2.micro로 선택한다.(목적에 따라 성능을 개선할 수 있다.) 인스턴스 세부 정보 구성에서는 추가할 인스턴스 개수와 서브넷을 선택해준다. 스토리지 추가에서는 크기를 20Gib로, 유형은 범용 SSD를 선택한다. 태그 추가는 넘어가도록 한다.(필요에 따라 설정 가능) 보안 그룹 구성에서는 기존 보안 그룹을 선택하여 이미 생성한 인스턴스와 같은 보안 그룹을 선택한다. 검토 및 시작을 누르고 시작하기를 누른다. EC2의 인스턴스 목록으로 돌아와서 추가한 인스턴스의 이름을 설정해둔다. EC2 왼쪽 메뉴에서 로드밸런싱/대상 그룹에서 로드밸런서를 선택하고 하단에 대상 편집을 누른다. 추가한 인스턴스를 등록된 항목에 추가한다. 추가한 인스턴스의 주소로 접속해서 동작하는지 확인한다. 소스 코드가 업데이트 됬다면… 로드 밸런서 목록에서 본체였던 대상을 제거해준다. filezilla를 사용하여 소스코드를 업로드한다. 해당 인스턴스의 이미지를 다시 생성한다.(이름에는 날짜와 몇번쨰인지 명명) AMI 목록에서 추가로 인스턴스들을 생성한다.(서브넷 : a그룹, c그룹) 대상 목록으로 가서 추가한 인스턴스들을 편집을 이용하여 등록한다. 구서버 인스턴스들을 목록에서 제거한다. 동작이 확인된다면, 인스턴스 목록에서 구서버를 종료시킨다. 신규 서버의 이름을 수정한다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.30 Django Study","slug":"190530-Django-Study","date":"2019-05-30T07:21:07.000Z","updated":"2019-06-05T07:22:15.209Z","comments":true,"path":"2019/05/30/190530-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/30/190530-Django-Study/","excerpt":"","text":"blog Project 클래스형 뷰와 함수형 뷰 클래스형 뷰(Class Based View) 자주 처리하는 내용을 미리 구현해 놓은 뷰 제대로 사용하려면 내부 속성 값들을 알고 있어야 함 클래스형 뷰를 사용하여 뷰를 구현해도 최종 실행에서는 함수형 뷰로 변환되어 동작 as_view() 메서드를 통해 클래스형 뷰를 함수형 뷰로 변환 함수형 뷰(Function Based View) 함수형 뷰는 request를 기본 매개변수로 가짐 URL에 포함된 패턴그룹을 추가 변수로 가짐 123456# urls.pypath('update/&lt;int:pk&gt;/', create_view)# views.pydef create_view(request, pk): pass 클래스형 뷰는 자주 처리하는 일들을 묶어둔 반면, 함수형 뷰는 모든 일을 직접 처리해야 함 클래스형 뷰와 함수형 뷰 비교 View 123456789101112131415161718192021222324252627from django.shortcuts import renderfrom django.http import JsonResponsefrom django.views.generic import View# 제네릭 뷰를 사용해서 클래스형 뷰를 만들 때는 상속# 함수형 뷰처럼 모든 내용을 직접 구현하고 싶을 때는 View를 상속받는다 ex) API Viewclass IndexView(View): def get(self, *args, **kwargs): return render(self.request, 'blog/test.html')def indexView(request): if request.method == \"GET\": return render(request, 'blog/test.html')class JsonView(View): def get(self, *args, **kwargs): return JsonResponse(&#123;\"data\": 'test'&#125;) def post(self, *args, **kwargs): return JsonResponse(&#123;\"data\": 'test'&#125;)def jsonView(request): if request.method == \"GET\": return JsonResponse(&#123;\"data\": 'test'&#125;) elif request.method == \"POST\": return JsonResponse(&#123;\"data\": 'test'&#125;) CRUDL(Create, Detail, Update, Delete, List View) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168from django.views.generic.detail import DetailViewfrom django.views.generic.list import ListViewfrom django.views.generic.edit import CreateView, UpdateView, DeleteViewfrom .models import Postfrom django.core.paginator import Paginatorfrom django.db.models import Qfrom django.http import Http404from django.shortcuts import redirectfrom django.forms import modelform_factoryfrom django.shortcuts import get_object_or_404from django.urls import reverse_lazyfrom django.shortcuts import reverse# ListView CBVclass PostList(ListView): model = Post # default : app_name/model_list.html template_name = 'blog/post_list.html' # 페이징 기능 활성화 paginate_by = 1 # 한 페이지당 요소 갯수 page_kwarg = 'p' \"\"\" setup() dispatch() get_queryset() get_context_data() render_to_response() \"\"\" # ListView FBVdef postList(request, page): # 페이지 번호 얻기 page = page if page else 1 page = int(page) queryset = Post.objects.all() # CBV : get_queryset # post으로 전달된 데이터 중에서 search 변수값 찾기 search_keyword = request.POST.get('search', request.GET.get('search', None)) context_data = &#123;&#125; if search_keyword: q = Q(text__icontains=search_keyword) q |= Q(title__icontains=search_keyword) queryset = queryset.filter(q) context_data.update(&#123;'search_keyword': search_keyword&#125;) # 페이징 처리 paginator = Paginator(queryset, 1) page = paginator.page(page) context_data.update(&#123;'object_list': page.object_list, 'paginator': paginator, 'page_obj': page, 'is_paginated': True&#125;) return render(request, 'blog/post_list.html', context_data)# DetailView CBVclass PostDetail(DetailView): model = Post template_name = 'blog/post_detail.html' # pk의 이름을 post_id로 바꾸기 pk_url_kwarg = 'post_id' \"\"\" setup() dispatch() get() get_object() - get_queryset() get_context_data() render_to_response() \"\"\"# DetailView FBVdef postDetail(request, pk): try: object = Post.objects.get(pk=pk) except: raise Http404(\"Post does not exists\") return render(request, 'blog/post_detail.html', &#123;'object': object&#125;)# CreateView CBVclass PostCreate(CreateView): model = Post fields = ['category', 'title', 'text'] # appname/model_form.html template_name = 'blog/post_create.html' # success_url이 있는 Create, Update, Delete의 경우 # 클래스의 속성값을 사용해서 URL을 만들 수 있다. # success_url = 'pattern/&#123;변수명&#125;/' def form_valid(self, form): form.instance.author_id = self.request.user.id return super().form_valid(form) \"\"\" setup() dispatch() get() post() - 저장처리 get_context_data() render_to_response() \"\"\"# CreateView FBVdef postCreate(request): # form_factory : 폼을 쉽게 생성하기 위해 사용하는 클래스, Factory 패턴 # 기존에 Form Class를 별도로 만드는 방식보다 간단하게 폼을 만들어서 처리할 수 있다는 장점이 있다. form_class = modelform_factory(Post, fields=['category', 'title', 'text']) if request.method == \"POST\": form = form_class(request.POST) form.instance.author_id = request.user.id if form.is_valid(): instance = form.save() return redirect(instance) else: form = form_class() return render(request, 'blog/post_create.html', &#123;'form': form&#125;)# UpdateView CBVclass PostUpdate(UpdateView): model = Post fields = ['category', 'title', 'text'] template_name = 'blog/post_update.html' \"\"\" setup() dispatch() get() post() - 저장처리 get_object() get_context_data() render_to_response() \"\"\"# UpdateView FBVdef postUpdate(request, pk): object = get_object_or_404(Post, pk=pk) form_class = modelform_factory(Post, fields=['category', 'title', 'text']) if request.method == \"POST\": # 수정시에는 instance 필히 지정 form = form_class(request.POST, instance=object) if form.is_valid(): instance = form.save() return redirect(instance) else: # 수정시에는 instance 필히 지정 form = form_class(instance=object) return render(request, 'blog/post_update.html', &#123;'form': form&#125;)# DeleteView CBVclass PostDelete(DeleteView): model = Post template_name = 'blog/post_delete.html' success_url = reverse_lazy('blog:post_list_cbv')# DeleteView FBVdef postDelete(request, pk): post = get_object_or_404(Post, pk=pk) if request.method == \"POST\": post.delete() return redirect(reverse('blog:post_list_cbv')) else: return render(request, 'blog/post_delete.html') URL 만들기 reverse 가장 일반적으로 활용하는 메서드 URLConf에 있는 패턴 이름과 URL에 들어갈 매개변수 전달12345from django.shortcuts import reversereverse('blog:list')reverse('blog:update', args=[1])reverse('blog:update', kwargs=&#123;'pk':1&#125;) reverse_lazy 클래스형 뷰에서 success_url을 설정할 때 reverse를 사용하면 URLConf가 로드되기 전에 동작하므로 오류 발생 이럴 경우, reverse_lazy를 사용12345from django.url import reverse_lazyreverse_lazy('blog:list')reverse_lazy('blog:update', args=[1])reverse_lazy('blog:update', kwargs=&#123;'pk':1&#125;) resolve_url reverse의 간략화 버전12345678from django.shortcuts import resolve_urlresolve_url('blog:list')resolve_url('blog:update', 1)resolve_url('blog:update', pk=1)# object의 get_absolute_url을 호출하고 싶은 경우resolve_url(object) redirect URL을 생성하고 해당 URL로 이동하는 redirect response 메세지 생성12345678from django.shortcuts import redirectredirect('blog:list')redirect('blog:update', 1)redirect('blog:update', pk=1)# object의 get_absolute_url을 호출하고 싶은 경우redirect(object) resolve 주어진 URL로부터 URLConf 정보를 찾아냄12345678from django.urls import resolveurl = resolve(request.path)url.routeurl.view_nameurl.url_nameurl.funcurl.kwargs","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.28 Django Study","slug":"190528-Django-Study","date":"2019-05-28T07:19:49.000Z","updated":"2019-06-05T07:20:34.237Z","comments":true,"path":"2019/05/28/190528-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/28/190528-Django-Study/","excerpt":"","text":"blog Project github로 협업하여 진행 Social Login 이용하기(Facebook) Facebook login을 사용하기 위해서는 HTTPS URL을 사용해야 한다. 따라서 SSL을 적용해야 한다. openssl로 인증서 만들기 openssl의 버전을 확인한다. 1234$ openssl version# version이 나타나지 않는다면 설치해야 한다.$ sudo apt-get install openssl 키 파일을 생성한다. 1$ openssl genrsa 1024 &gt; stunnel.key cert 파일을 생성한다. 1openssl req -new -x509 -nodes -sha256 -days 365 -key django.key &gt;django.cert 만든 해당 파일을 현재 진행중인 프로젝트 폴더로 복사해 넣는다. ssl runserver 사용하기 django-sslserver를 설치한다. 1$ pip install django-sslserver settings.py의 INSTALLED_APPS에 추가한다. 1234INSTALLED_APPS = [ #... 'sslserver',] 다음 명령어를 실행해본다. 123# 둘 중에 어떤 것으로 시작해도 된다.$ python manage.py runsslserver --certificate django.cert --key django.key$ python manage.py runsslserver django allauth 사용하기(Facebook login) django-allauth를 설치한다. 1$ pip install django-allauth settings.py의 INSTALLED_APPS에 추가한다. 12345678INSTALLED_APPS = [ #... 'django.contrib.sites', 'allauth', 'allauth.account', 'allauth.socialaccount', 'allauth.socialaccount.providers.facebook',] settings.py에 다음 항목을 추가한다. 123456AUTHENTICATION_BACKENDS = [ 'django.contrib.auth.backends.ModelBackend', 'allauth.account.auth_backends.AuthenticationBackend',]SITE_ID = 1 urls.py에 allauth 관련 urlpatterns를 추가한다. 1234urlpatterns = [ #... path('accounts/', include('allauth.urls')),] migrate를 한다. 1$ python manage.py migrate Facebook 개발자 사이트로 이동한다. https://developers.facebook.com/ 로그인 한 후, 내 앱에서 새 앱 추가를 누른다. 적당한 앱 이름과 이메일을 입력하고 앱 ID 만들기를 누른다. 보안 확인 창이 나타나면 보안 확인을 완료하고 제출을 누른다. 앱 기능 중 Facebook 로그인 통합에 체크하고 확인을 누른다. 앱 생성이 완료되면 화면 하단의 내 제품 목록에서 Facebook 로그인의 설정을 누른다. 유효한 OAuth 리디렉션 URI에 다음과 같은 서버 주소를 입력한다. 123https://127.0.0.1:8000# &apos;accounts&apos;는 다른 이름으로 변경할 수 있다.https://127.0.0.1:8000/accounts/facebook/login/callback/ 앱 기본 설정 페이지로 이동하여 앱 ID와 시크릿 코드를 확인한다. 관리자 페이지로 접속하여 Social applications에 설정을 추가한다. 12345- Provider : Facebook- Name : Facebook login- Client id : [Facebook 개발자 사이트에 있는 앱 ID]- Secret key : [Facebook 개발자 사이트에 있는 시크릿 코드]- Sites에 있는 example.com 선택 로그인 페이지에 접속하여 Facebook을 누른다. ex) https://127.0.0.1:8000/accounts/login/ Facebook 창이 나타나면 계속을 누른다. 관리자 페이지에서 소셜 계정이 등록되었는지 확인한다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.27 Django Study","slug":"190527-Django-Study","date":"2019-05-27T07:10:44.000Z","updated":"2019-06-05T07:19:21.511Z","comments":true,"path":"2019/05/27/190527-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/27/190527-Django-Study/","excerpt":"","text":"editor Project WYSIWYG 사용하기 WYSIWYG(What you see is what you get) 웹 브라우저에서 사용할 수 있는 HTML 편집기 django-ckeditor 모듈을 다운받아 설치한다. 1$ pip install django-ckeditor settings.py의 INSTALLED_APPS에 추가한다. 1234INSTALLED_APPS = [ #... 'ckeditor',] models.py를 작성한다. 12345from django.db import modelsfrom ckeditor.fields import RichTextFieldclass Post(models.Model): content = RichTextField() migrate를 진행한다. 123$ python manage.py makemigrations [앱 이름]$ python manage.py migrate [앱 이름] 관리자 페이지에서 해당 필드가 에디터 형태로 나타나는지 확인한다. template 파일을 통해 폼을 출력할 때는 필수로 form.media를 사용하도록 한다.123456&lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123;form.media&#125;&#125; &#123;&#123;form.as_p&#125;&#125; &lt;input type=\"submit\" value=\"Write\"&gt;&lt;/form&gt; CKEditor 이미지 파일 업로더 설정하기 django-ckeditor 모듈을 다운받아 설치한다. 1$ pip install django-ckeditor settings.py의 INSTALLED_APPS에 추가한다. 12345INSTALLED_APPS = [ #... 'ckeditor', 'ckeditor_uploader',] settings.py에 MEDIA_ROOT를 꼭 지정한다. 12345678# Amazon AWS S3를 사용할 경우, 지정할 필요가 없다.MEDIA_ROOT = os.path.join(BASE_DIR, 'media')# MEDIA_ROOT 하위 폴더에 전용 경로를 설정하고 싶다면CKEDITOR_UPLOAD_PATH = 'upload/'# 에디터를 사용하는 유저별로 자신이 올린 파일드란 사용할 수 있게 하려면CKEDITOR_RESTRICT_BY_USER = True models.py를 작성한다. 12345from django.db import modelsfrom ckeditor_uploader.fields import RichTextUploadingFieldclass Post(models.Model): content = RichTextUploadingField() migrate를 진행한다. 123$ python manage.py makemigrations [앱 이름]$ python manage.py migrate [앱 이름] urls.py에 업로더 내용을 추가한다. 123456urlpatterns = [ #... path('ckeditor/', include('ckeditor_uploader.urls')), # Amazon AWS S3를 사용하지 않는 경우, media 파일 서빙하기 re_path(r'^media/(?P&lt;path&gt;.*)$', serve, &#123;'document_root':settings.MEDIA_ROOT&#125;),] 파일을 업로드하여 확인한다. Media 파일 서빙하기 Amazon AWS S3를 사용할 수 없을 경우, serve view를 사용하여 서빙할 수 있다. settings.py에 media 관련 경로를 추가한다. 12MEDIA_URL = '/media/'MEDIA_ROOT = os.path.join(BASE_DIR, 'media') 디버그 모드일 경우, 다음과 같이 url pattern을 추가하여 사용할 수 있다. 12345from django.conf import settingsif settings.DEBUG: from django.conf.urls.static import static urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 라이브 상태일 경우, serve view를 사용하여 연결해준다. 1234567from django.views.static import servefrom django.urls import re_pathurl_patterns = [ #... re_path(r'^media/(?P&lt;path&gt;.*)$', serve, &#123;'document_root': settings.MEDIA_ROOT&#125;),] settings.py에서 DEBUG를 False로 변경한다. 123DEBUG = FalseALLOWED_HOSTS = ['*'] 이미지를 업로드해보고 출력되는지 확인한다. Static 파일 서빙하기 디버그 모드일 때만 load static %&#125;```을 이용하여 static 태그를 이용해 리소스를 사용할 수 있다.12345- Amazon AWS S3를 사용할 수 없을 경우, serve view를 사용하여 서빙할 수 있다.1. whitenoise를 설치한다.```bash# whitenoise는 static 파일들을 collectstatic 명령 수행시 지정 경로에 파일을 모아준다.$ pip install whitenoise settings.py의 MIDDLEWARE에 추가하고 static 경로를 추가한다. 1234567MIDDLEWARE = [ #... 'whitenoise.middleware.WhiteNoiseMiddleware',]STATIC_URL = '/static/'STATIC_ROOT = os.path.join(BASE_DIR, 'static') settings.py에서 DEBUG를 False로 변경한다. 123DEBUG = FalseALLOWED_HOSTS = ['*'] collectstatic 명령어를 실행한다. 123# 아래 명령어를 실행하지 않고 관리자 페이지를 접속할 경우, 폼이 깨져서 나온다.# whitenoise는 STATIC_URL이 포함된 리소스를 STATIC_ROOT를 통해 찾아 전달한다.$ python manage.py collectstatic 관리자 페이지로 접속하여 확인한다. Nginx를 사용한 리소스 파일 서빙하기 Nginx 설정 파일에 다음과 같은 내용을 추가한다. ex) vim /etc/nginx/sites-available/default 12345678910# 최대 업로드 용량client_max_body_size 75Mlocation /media &#123; alias /var/www/django/media;&#125;location /static &#123; alias /var/www/django/static;&#125; 서버 설정 적용을 위해 Nginx를 재시작한다. 1$ sudo systemctl restart nginx FTP로 파일 업로드 하기 FTP 프로그램을 이용하여 서버에 직접 소스 코드를 업로드하는 방식을 알아보자. Filezilla를 이용한다. filezilla를 설치한다. 1$ sudo apt-get install filezilla filezilla를 실행하여 왼쪽 상단 탭에서 사이트 관리자로 들어간다. 새로운 사이트를 추가하고 접속 정보를 설정한다. 12345- 프로토콜 : SFTP- 호스트 : EC2의 접속 주소- 로그온 유형 : 키 파일- 사용자 : ubuntu- 키 파일 : 키 페어 파일 경로 지정 고급 탭에서 기본 로컬 디렉터리와 기본 리모트 디렉터리를 지정한다. 12기본 로컬 디렉터리 = pycharm으로 만든 프로젝트 폴더기본 리모트 디렉터리 = 소스 코드를 업로드할 폴더 설정이 완료되었다면 연결을 누른다. 처음 접속 시, 알 수 없는 호스트 창이 나타나면 캐시에 등록을 체크하고 확인을 누른다. 접속이 성공했다면, 소스 코드를 업로드한다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.23 Django Study","slug":"190523-Django-Study","date":"2019-05-23T03:56:59.000Z","updated":"2019-05-30T07:59:12.783Z","comments":true,"path":"2019/05/23/190523-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/23/190523-Django-Study/","excerpt":"","text":"Django Project EC2에 장고 서버 셋팅하기 EC2에 SSH로 접속한다. 12345678# 퍼블릭 DNS 주소를 가지고 있다면$ ssh -i ~/.ssh/[키페어 파일 이름] ubuntu@[EC2의 퍼블릭 DNS]# 탄력적 IP를 가지고 있다면$ ssh -i ~/.ssh/[키페어 파일 이름] ubuntu@[할당받은 탄력적 IP]# Route53을 통해 도메인을 연결했다면$ ssh -i ~/.ssh/[키페어 파일 이름] ubuntu@[연결한 도메인 주소] 장고를 위한 계정을 추가한다. 1234567$ cd /var/www# -g : 현재 그룹에 바로 추가# -b : 홈 폴더 지정# -m : 유저의 홈 폴더 생성# -s : 기본으로 사용할 쉘 지정$ sudo useradd -g www-data -b /home -m -s /bin/bash django 소스 코드를 업로드할 폴더를 만든다. 1$ sudo mkdir /var/www/django 소스 코드 폴더의 소유자를 변경한다. 1$ sudo chown django:www-data /var/www/django 파일 업로드를 위해 ubuntu 계정을 www-data 그룹에 추가한다. 123# -a : 추가 명령# -G : 그룹 추가 명령$ sudo usermod -a -G www-data ubuntu 파이썬 관련 패키지를 설치한다. 1$ sudo apt-get install python3-dev python3-venv python3-pip 소스 코드 폴더 밑에 파이썬 가상 환경을 만든다. 1$ sudo python3 -m venv /var/www/django/venv 관리자 모드로 변경한다. 12$ sudo -s# ubuntu에서 root로 바뀌는지 확인한다. 가상 환경을 활성화한다. 1$ source venv/bin/activate 가상 환경에 장고를 설치한다. 1$ pip install django 장고 프로젝트를 생성하고 migrate한다. 12345678910$ django-admin startproject config .$ python manage.py migrate# 장고에서 서버를 실행해서 동작을 확인한다.# 인스턴스 보안에서 테스트를 위해 인바운드 규칙에 포트 번호 8000을 추가한 것을 이용# 0:8000에서 0은 외부 트래픽에서도 받아보겠다는 의미$ python manage.py runserver 0:8000# 반드시 장고에서 서버 동작을 확인하도록 하자. uwsgi 모듈을 설치한다.(WSGI 모듈 중 하나) 1$ pip install uwsgi uwsgi가 동작하는지 아래 명령어를 입력한 후, 웹 브라우저로 접속해본다. 12$ uwsgi --http :8000 --home /var/www/django/venv/ --chdir /var/www/django/ --module config.wsgi# 웹 브라우저에 [ssh 접속 시 사용한 주소]:8000으로 접속해본다. 관련 폴더를 만들고 설정해본다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# run과 logs 폴더를 만든다.$ sudo mkdir run logs# 폴더의 소유권을 변경한다.$ sudo chown django:www-data run$ sudo chown django:www-data logs# ini 폴더를 만든다.$ sudo mkdir ini# ini 폴더 안에 uwsgi.ini 파일을 작성한다.$ sudo vim ini/uwsgi.ini# uwsgi.ini 내용[uwsgi]uid = djangobase = /var/www/djangohome = %(base)/venvchdir = %(base)module = config.wsgi:applicationenv = DJANGO_SETTINGS_MODULE=config.settingsmaster = trueprocesses = 5socket = %(base)/run/uwsgi.socklogto = %(base)/logs/uwsgi.logchown-socket = %(uid):www-datachmod-socket = 660vacuum = true# uwsgi.service 파일을 만든다.$ sudo vim /etc/systemed/system/uwsgi.service# uwsgi.service 내용[Unit]Description=uWSGI Emperor service[Service]ExecStart=/var/www/django/venv/bin/uwsgi --emperor /var/www/django/iniUser=djangoGroup=www-dataRestart=on-failureKillSignal=SIGQUITType=notifyNotifyAccess=allStandardError=syslog[Install]WantedBy=multi-user.target# uwsgi.service를 시작하고 시작 프로그램으로 등록한다.$ sudo systemctl start uwsgi$ sudo systemctl enable uwsgi 사이트 설정 파일을 변경하여 장고 애플리케이션이 구동되도록 한다. 12345678910111213141516171819202122# 기존에 만들어두었던 staticweb 파일을 사용한다.$ sudo vim /etc/nginx/sites-available/staticweb# staticweb 내용upstream django &#123; server unix:/var/www/django/run/uwsgi.sock;&#125;server &#123; listen 80; charset utf-8; access_log /var/www/django/logs/access.log; error_log /var/www/django/logs/error.log; server_name [Route53으로 연결한 도메인 주소] location = /favicon.ico &#123; access_log off; log_not_found off; &#125; location / &#123; include /etc/nginx/uwsgi_params; uwsgi_pass django; &#125;&#125; 웹 브라우저에 도메인 주소를 입력하고 구동되는지 확인한다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.22 Django Study","slug":"190522-Django-Study","date":"2019-05-22T14:40:10.000Z","updated":"2019-05-29T02:41:51.972Z","comments":true,"path":"2019/05/22/190522-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/22/190522-Django-Study/","excerpt":"","text":"Django Project EC2에 웹 서버 설정하기 EC2에 SSH로 접속한다. 1$ ssh -i ~/.ssh/[키페어 파일 이름] ubuntu@[EC2의 퍼블릭 DNS] 접속이 성공했다면 패키지를 최신으로 업데이트한다. 1$ sudo apt-get update Nginx를 설치한다. 12# apt-get 사용$ sudo apt-get install nginx nginx가 잘 동작하는지 다음 명령어를 통해 확인한다. 1234567891011$ systemctl status nginx# nginx를 설치했다면...# status 명령어를 통해 상태를 확인한다.(active)# 웹 브라우저에서 퍼블릭 DNS 주소를 입력하여 확인한다.(Welcome to nginx 화면)# 아래 명령어를 알아두자.$ sudo systemctl stop nginx$ sudo systemctl start nginx$ sudo systemctl restart nginx$ systemctl status nginx Nginx는 한 서버 컴ㅍ퓨터에서 여러 사이트를 운영할 수 있다. 사이트 별로 설정 파일을 만들어야 한다. 여기서는 staticweb이라는 이름을 예시로 사용해본다.123# default 파일을 복사하여 staticweb 파일 생성# 파일 이름은 자유롭게 생성하자.$ sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/staticweb 생성한 설정 파일을 수정한다. 12345678910111213141516171819$ sudo vim /etc/nginx/sites-available/staticweb# staticweb# default 파일을 복사했기 때문에 아래와 같이 내용을 수정한다.# server_name에는 퍼블릭 DNS 주소를 기입한다.server &#123; listen 80; listen [::]:80; root /var/www/staticweb; index index.html index.htm index.nginx-debian.html; server_name [퍼블릭 DNS] location / &#123; try_files $uri $uri/ =404; &#125;&#125; 설정 파일을 Nginx에 활성화시킨다. 123# 심볼릭 링크를 사용하여 sites-enabled에 링크 파일을 생성한다.# site-enabled에 파일이 위치해야 사이트가 동작한다.$ sudo ln -s /etc/nginx/sites-available/staticweb /etc/nginx/sites-enabled 테스트를 위해 staticweb이라는 폴더를 만든다. 12$ cd /var/www/$ sudo mkdir staticweb staticweb 폴더 안에 index.html을 생성한다. 12$ cd /var/www/staticweb$ vim index.html 12345&lt;html&gt; &lt;body&gt; hello &lt;/body&gt;&lt;/html&gt; 웹 브라우저에서 퍼블릭 DHS 주소를 입력하여 hello가 출력되는지 확인한다. EC2 인스턴스에 고정 IP 설정하기 퍼블릭 DNS의 IP는 동적으로 변하는 상태이기 때문에 연결이 끊기는 상황이 발생할 수 있다. Elastic IP 서비스를 사용하여 고정 IP를 할당받을 수 있다. EC2 화면 좌측 메뉴에서 네트워크 및 보안 / 탄력적 IP를 선택한다. 새 주소 할당을 누른다. IP의 사용은 무료이지만, IP를 할당받고 사용하지 않으면 비용이 청구된다. 따라서 사용하지 않는다면 삭제하자. 할당을 누르고 새 주소 요청 성공이 보이면 닫기를 누른다. IP 목록에서 할당받은 IP를 마우스 오른쪽 버튼으로 클릭한다. 주소 연결을 누르고 인스턴스 항목에 사용할 인스턴스를 선택하고 연결을 누른다. 주소 연결 요청 성공이 보이면 닫기를 누른다. 인스턴스 목록으로 가서 사용할 인스턴스에 설정이 되었는지 확인한다. 퍼블릭 DNS 주소 대신에 탄력적 IP가 나타나는지 확인한다. [서비스] 메뉴에서 네트워킹 및 콘텐츠 전송/Route53으로 이동한다. 호스팅 영역으로 이동하여 사용중인 도메인을 누른다. 레코드 세트 생성을 누른다. 원하는 이름을 설정한다. 유형은 A-IPv4 주소를 선택한다. 값에 할당받은 탄력적 IP를 기입하고 생성한다. 이제 ssh로 접속할 때 설정한 도메인 이름으로 접속할 수 있다. staticweb 설정 파일에서 server_name을 설정한 도메인 주소로 바꾸자.123456789101112131415161718$ sudo vim /etc/nginx/sites-available/staticweb # staticweb# server_name에 연결한 도메인 주소를 기입한다.server &#123; listen 80; listen [::]:80; root /var/www/staticweb; index index.html index.htm index.nginx-debian.html; server_name [Route53을 통해 연결한 도메인 주소] location / &#123; try_files $uri $uri/ =404; &#125;&#125; 커스텀 유저 모델 만들기 생성한 장고 프로젝트에서 account 앱을 생성한다. 1$ python manage.py starapp account settings.py의 INSTALLED_APPS에 앱을 추가한다. 1234 INSTALLED_APPS = [ #... 'account',] models.py를 작성한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344from django.db import models# 기존에 있던 User 모델을 확장해서# 내가 원하는 추가 필드를 만드는 것# 커뮤니티 사이트 - 프로필 사진, 자기소개\"\"\"기존에 모델을 확장(필드를 추가)하려면 모델 소스코드를 변경하는데,애시당초 모델을 만들 때는 models.Model을 상속받는다.* 모델은 어떤 모델을 상속받아서 확장할 수도 있다.기존 User 모델은 AbstractUser라는 모델을 상속받아서 구현된다.AbstractUser모델은 AbstractBaseUser라는 모델을 상속받아서 구현된다.* Abstract : 추상이라고 해석되는 단어인데, 모델의 설정값에 Abstract라는 값을 설정할 수 있다.abstract가 설정되어 있으면 실제 모델로 사용 불가1) 기존 User 모델은 AbstractUser라는 모델을 상속받아서 필수 필드들이 이미 구현이 되어있는 상태다.- 우리가 익히 보던 기본 필드들과 권한 관련 기능 등 장고에서 유저에게 기본적으로 필요한 기능이 구현이 되어있다.- 추가 필드가 필요한 경우에는 AbstractUser 모델을 상속받아서 구현하는 것이 제일 편하다.2) AbstractBaseUser로 구현해야 되는 경우- 모든 필드 구조를 변경할 필요가 있을 때- 퍼미션 기능 등 장고에서 사용하는 유저 기본 기능 전체를 뜯어 고치고 싶을 때- Backend를 새로 구현해줘야 한다.3) 기존 User 모델을 상속받거나, 확장해서 사용하는 경우- User + AdditionalInfo(생일, 주소, 주민번호)-&gt; 회원 수정 페이지 AdditionalInfoForm을 추가로 입력1번을 제일 권장하는 확장 방식 - 프로젝트 시작 시점에 고려, (* 기존 데이터 유지 불가)3번은 사이트를 운영 중에 확장을 고려해야 할 때 선택 가능, 기존 User 데이터 그대로 존재, + 추가 테이블* OneToOne 필드swappable은 AUTH_USER_MODEL 값에 설정된 모델과 교체가 가능하다라고 미리 설정해둔 것class User(AbstractUser): class Meta(AbstractUser.Meta): swappable = 'AUTH_USER_MODEL'\"\"\"from django.contrib.auth.models import AbstractUserclass User(AbstractUser): message = models.TextField(blank=True) profile = models.ImageField(upload_to='user_images/profile/%Y/%m/%d', blank=True) settings.py에 아래 항목을 추가한다. 1AUTH_USER_MODEL = 'account.User' 새로 만든 유저 모델의 데이터베이스 생성을 위해 아래 명령어를 실행한다. 123456# 모델에 이미지 필드가 있으므로 pillow 모듈 설치$ pip install pillow$ python manage.py makemigrations account$ python manage.py migrate 관리자 계정을 생성한다. 1$ python manage.py createsuperuser admin.py에 유저 모델을 등록해준다. 등록하지 않으면 관리자 페이지에서 볼 수 없다. 1234from django.contrib import adminfrom .models import Useradmin.site.register(User) 관리자 페이지에 접속하여 유저 모델을 수정해보면 기존 유저 모델 화면과 다른 것을 확인할 수 있다. UserAdmin 클래스 옵션을 등록하여 기존 유저 모델과 같이 보이게 할 수 있다.12345from django.contrib import adminfrom .models import Userfrom django.contrib.auth.admin import UserAdminadmin.site.register(User, CustomUserAdmin) 모델에서 만든 추가 필드 값에 대한 클래스를 새로 만들어서 등록해줘야 한다. message와 profile의 필드 값이 나타나지 않는 것을 확인할 수 있다. admin.py를 다음과 같이 수정한다.12345678910111213141516from django.contrib import adminfrom .models import Userfrom django.contrib.auth.admin import UserAdminclass CustomUserAdmin(UserAdmin): # fieldsets - 상세 화면에서 출력될 수정 폼 설정 # add_fieldsets - 추가 화면에 출력될 입력 폼의 설정 UserAdmin.fieldsets[1][1]['fields']+=('profile','message') UserAdmin.add_fieldsets += ( (('Additional Info'), &#123;'fields':('profile','message')&#125;), )# CustomUserAdmin으로 옵션 클래스 수정admin.site.register(User, CustomUserAdmin) 관리자 페이지로 접속하여 추가 필드 값이 출력되는지 확인한다. 추가 필드에 값이 정상적으로 입력되는지 확인하자. Email 로그인 기능 추가하기 로그인 기능을 제어하는 것은 AUTHENTICATION_BACKENDS에 설정된 모델 백엔드를 통해 이뤄진다. 커스텀 모델 백엔드를 추가하여 username과 email 모두 가능한 로그인 기능을 만든다. account 앱에 backends.py를 추가하고 다음과 같이 입력한다. 1234567891011121314151617181920212223242526from django.contrib.auth import get_user_modelclass CustomUserBackend(ModelBackend): def authenticate(self, request, username=None, password=None, **kwargs): user = super().authenticate(request, username, password, **kwargs) if user: return user # id 로그인 실패 상황 # email 로그인 시도 UserModel = get_user_model() # 원래 id 로그인 처리를 할 때 username이 넘어왔을 경우 # email 변수에 새로 값을 할당하려고 email = username if email is None: email = kwargs.get(UserModel.EMAIL_FIELD, kwargs.get('email')) try: user = UserModel._default_manager.get(email=email) except UserModel.DoesNotExist: # Run the default password hasher once to reduce the timing # difference between an existing and a nonexistent user (#20760). UserModel().set_password(password) else: if user.check_password(password) and self.user_can_authenticate(user): return user settings.py에 아래 항목을 추가한다. 123AUTHENTICATION_BACKENDS = [ 'account.backends.CustomUserBackend',] 관리자 페이지를 접속하여 이메일로 접속되는지 확인한다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.21 Django Study","slug":"190521-Django-Study","date":"2019-05-21T14:40:04.000Z","updated":"2019-07-10T11:43:54.316Z","comments":true,"path":"2019/05/21/190521-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/21/190521-Django-Study/","excerpt":"","text":"Django Project debug tool bar 설치하기 debug tool bar를 설치한다. 1$ pip install django-debug-toolbar settings.py에 해당 관련 항목을 추가한다. 1234567891011# INSTALLED_APPS에 항목 추가INSTALLED_APPS = [ #... 'debug_toolbar',]# MIDDLEWARE에 항목 추가MIDDLEWARE = [ #... 'debug_toolbar.middleware.DebugToolbarMiddleware',] settings.py에 아래 항목을 추가한다. 1234567891011121314151617# debug = True, internal_ipsINTERNAL_IPS = ['127.0.0.1']DEBUG_TOOLBAR_PANELS = [ 'debug_toolbar.panels.versions.VersionsPanel', 'debug_toolbar.panels.timer.TimerPanel', 'debug_toolbar.panels.settings.SettingsPanel', 'debug_toolbar.panels.headers.HeadersPanel', 'debug_toolbar.panels.request.RequestPanel', 'debug_toolbar.panels.sql.SQLPanel', 'debug_toolbar.panels.staticfiles.StaticFilesPanel', 'debug_toolbar.panels.templates.TemplatesPanel', 'debug_toolbar.panels.cache.CachePanel', 'debug_toolbar.panels.signals.SignalsPanel', 'debug_toolbar.panels.logging.LoggingPanel', 'debug_toolbar.panels.redirects.RedirectsPanel',] config/urls.py에 아래 소스 코드를 추가한다. 12345678from django.urls import path, includefrom django.conf import settingsif settings.DEBUG: import debug_toolbar urlpatterns = [ path('debug/', include(debug_toolbar.urls)), ] + urlpatterns 관련 static 파일 업로드를 위해 collectstatic 명령어를 입력한다. 1$ python manage.py collecstatic 관리자 페이지로 접속하여 debug tool bar가 작동하는지 확인한다. django extensions 설치하기 extensions 모듈을 설치한다. 1$ pip install django-extensions settings.py에 해당 관련 항목을 추가한다. 12345# INSTALLED_APPS에 항목 추가INSTALLED_APPS = [ #... 'django_extensions',] settings.py에 아래 항목을 추가한다. 1234GRAPH_MODELS = &#123; 'all_applications': True, 'group_models': True&#125; 그래프 출력 기능을 위해 아래 모듈을 설치한다. 123$ sudo apt-get install python3-dev graphviz libgraphviz-dev pkg-config$ pip install pygraphviz 그래프 생성 명령어를 입력해본다. 1234567# 전체 모델에 대한 그래프 출력$ python manage.py graph_models -a -g -o model_graph.png# 특정 앱에 대한 그래프 출력# [앱 이름]에는 현재 앱 이름을 기입하면 된다.# 여러 앱의 이름을 쓸 경우 콤마가 아닌 띄워쓰기로 기입하면 된다.$ python manage.py graph_models [앱 이름] -o models.png 다음 명령어를 통해 데이터베이스를 삭제하고 새로 생성할 수 있다. 1$ python manage.py reset_db EC2 인스터스 만들기 EC2(Elastic Cloud Computing) 아마존 서버 인스턴스 서비스 아마존 AWS 홈페이지로 접속해 [콘솔에 로그인]한다. [서비스] 메뉴에서 컴퓨팅/EC2를 누른다. EC2 화면에서 인스턴스 시작을 누른다. 운영체제 중에서 Ubuntu Server 18.04 64Bit를 선택한다. 인스턴스 유형에서는 프리티어 유형의 t2.micro를 선택한다. 인스턴스 세부 정보 구성 단계에서는 변경하는 것이 없이 넘어간다. 스토리지 추가 단계에서는 서버의 저장 공간을 20Gib로, 볼륨 유형은 범용 SSD를 선택한다. 태그 추가 단계에서는 변경하는 것 없이 넘어간다. 보안 그룹 구성 단계에서는 다음과 같이 설정한다. 보안 그룹 이름 및 설명을 기입한다. SSH, HTTP를 추가한다. 포트 번호 8000번도 테스트용으로 추가한다. 검토 및 시작 단계에서는 내용을 확인하고 시작하기를 누른다. 인스턴스가 추가되면 인스턴스에 접속하기 위해 키페어를 생성하거나 선택해야 한다. 새 키 페어 생성을 선택하고 키 페어 이름을 입력한 후 키 페어 다운로드를 누른다. 다시 다운받을 수 없으므로, 키 페어 파일이 다운로드된 것을 확인하자. 다운로드가 되면 인스턴스 시작 버튼이 활성화되고 누르도록 한다. 인스턴스 보기를 누르고 인스턴스 목록에서 방금 생성한 인스턴스를 확인한다. 인스턴스 이름 부분에 있는 연필 아이콘을 누르고 이름을 설정하자. 이름을 설정한 후, 하단에 퍼블릭 DNS를 확인하자. 퍼블릭 DNS는 고정 IP가 아니다. 터미널을 열고 SSH로 접속하여 서버를 셋팅한다. 다음 명렁어를 입력하여 키 페어 파일의 권한을 변경한다. 1$ chmod 400 [키 페어 파일 이름] 키 페어 파일을 .ssh 폴더에 보관하기 위해 파일을 이동시킨다. 1$ mv [키 페어 파일 이름] ~/.ssh/ ssh 명령어를 사용하여 서버에 접속해본다. 123$ ssh -i ~/.ssh/[키페어 파일 이름] ubuntu@[EC2의 퍼블릭 DNS]# 신규 접속 시 정말로 접속할지 물어보면 yes를 입력하면 된다. 접속에 성공하면 ubuntu shell이 나타난다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.20 Django Study","slug":"190520-Django-Study","date":"2019-05-20T10:54:33.000Z","updated":"2019-06-03T09:00:04.778Z","comments":true,"path":"2019/05/20/190520-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/20/190520-Django-Study/","excerpt":"","text":"Django Project 복습 프로젝트 만들기 가상 환경 만들기 데이터베이스 설정하기 S3 파일서버 설정하기 S3에 도메인 연결하기 PyCharm을 실행하여 새로운 프로젝트를 생성한다. “sample_project”로 생성 django 설치 1$ pip install django django 프로젝트 생성 1$ django-admin startproject config . 의존성 리스트 생성 1$ pip freeze &gt; requirements.txt 가상 환경을 만든다. 프로젝트 생성 시, 가상환경을 자동으로 생성해준다. 자동으로 생성되지 않았을 때를 가정한다. 가상 환경 생성 1$ python3 -m virtualenv venv 가상 환경 활성화 1234$ source venv/bin/activate# 가상 환경 비활성화$ deactivate 의존성 리스트를 이용한 패키지 설치 1$ pip install -r requirements.txt 소스에서 모듈 명령어에 빨간줄이 있다면 File/Settings/Project:[현재 프로젝트]/Project Interpreter로 이동 오른쪽 끝 톱니바퀴 버튼을 누름 Show All을 선택하고 “+”를 눌러서 Virtualenv Environment/Existing environment 선택 자동으로 현재 프로젝트 폴더에 있는 가상 환경을 찾아줌 추가된 가상 환경을 선택하고 OK 버튼을 누름 선택한 인터프리터 이름과 설치된 모듈 목록들이 올바른지 확인 데이터베이스를 설정한다. 아마존 AWS 홈페이지로 접속해 [콘솔에 로그인]한다. [서비스] 메뉴에서 데이터베이스/RDS를 누른다. RDS에서 데이터베이스 생성을 누른다. PostgreSQL 선택 및 화면 하단의 RDS 프리티어에 적용되는 옵션만 사용에 체크 DB 엔진 버전은 PostgreSQL 10.6-R1 선택 DB 인스턴스 식별자와 사용자 계정 설정 마스터 사용자 이름은 추후 확인할 방법이 없으므로 꼭 기억해야함 퍼블릭 엑세스 가능성은 [예]로 선택 실습 환경에서는 [예]를 선택하고, 프로덕션 환경에서는 꼭 [아니오]로 변경 데이터베이스 이름 설정 및 백업 보존 기간 0일 설정 실습 환경에서는 백업 비용을 없애기 위해 0일로 설정 대부분의 경우 1~2일 정도를 보관 실수로 인스턴스가 삭제되는 것을 막기 위해 삭제 방지 활성화 체크 데이터베이스 생성 DB 인스턴스 세부 정보 보기/VPC 보안 그룹으로 이동하여 인바운드를 설정한다. 인바운드 : 외부에서 들어오는 접속에 대한 설정 아웃바운드 - 해당 인스턴스가 외부 어디에 접근할 수 있는지에 대한 설정 인바운드에서 편집/규칙 추가하여 포트 번호 입력 및 위치 무관 선택 후 저장 프로덕션 환경에서는 절대 위치 무관을 선택해서는 안된다. 네트워크는 폐쇄적일수록 안전하다. PyCharm 프로젝트에서 settings.py에 DATABASE 항목을 수정한다. 12345678910111213141516# Database# https://docs.djangoproject.com/en/2.2/ref/settings/#databases# backends는 장고와 데이터베이스 어답터 사이를 연결해주는 역할# psycopg2-binary : 어답터 - 드라이버 -&gt; 실제로 데이터베이스에 접속해서 명령을 수행하는 모듈DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': '데이터베이스 이름', 'USER':'마스터 사용자 이름', 'PASSWORD':'마스터 사용자 비밀번호', 'HOST':'아마존 RDS의 엔드포인트', 'POST':'데이터베이스 접속 포트번호', &#125;,&#125;# web service에서 가장 병목이 데이터베이스. 데이터베이스에서 가장 시간을 많이 사용한다. 어답터 모듈 설치 1$ pip install psycopg2-binary 데이터베이스 초기화 1$ python manage.py migrate 관리자 계정 생성 1$ python manage.py createsuperuser S3 파일서버를 설정한다. 아마존 AWS 홈페이지에서 [서비스] 메뉴에서 스토리지/S3를 누른다. S3에서 버킷 만들기를 누른다. 버킷 이름을 입력하는데 도메인과 연결할 것이기 때문에 다음과 같이 설정한다. 123[저장할 대상 이름].[프로젝트 이름].[도메인 이름]ex) static.sample.jinukk.meex) media.sample.jinukk.me 리전은 [아시아 태평양(서울)] 선택 퍼블릭 엑세스 차단 부분에서는 모든 퍼블릭 엑세스 차단의 체크를 해제 클라이언트가 S3에 직접 접속해 파일을 받아가도록 할 것이기 때문 퍼블릭 엑세스가 가능한 상태이어야 함 버킷을 만들고 생성된 버킷 확인 django 프로젝트에서 S3를 이용하려면 아마존 사용 권한이 있어야 함 [서비스] 메뉴에서 보안, 자격 증명 및 규정 준수/IAM을 누른다. 왼쪽 사용자 메뉴에서 사용자 추가를 눌러서 사용자 이름을 입력한다. AWS 액세스 유형은 프로그래밍 방식 액세스를 선택한다. 권한 설정 부분에서는 그룹 생성을 누른 후, 그룹 이름을 입력한다. 정책 필더에는 AmazonS3FullAccess를 검색하여 체크하고 그룹을 생성한다. 태그와 검토 부분은 생략하고 사용자 만든다. 사용자 추가가 끝난 뒤 나오는 액세스 키는 다시 확인할 수 없다. 반드시 [.csv 다운로드]를 눌러서 액세스 키를 다운받아 놓는다. PyCharm 프로젝트에서 settings.py에 설정을 추가한다. 1234567891011121314151617181920212223242526272829AWS_ACCESS_KEY_ID = '아마존 AWS 액세스 키'AWS_SECRET_ACCESS_KEY = '아마존 AWS 비밀 액세스 키'AWS_REGION = 'ap-northeast-2'AWS_STORAGE_BUCKET_NAME = 'static.sample.jinukk.me'AWS_S3_CUSTOM_DOMAIN = 's3.%s.amazonaws.com/%s' % (AWS_REGION, AWS_STORAGE_BUCKET_NAME)AWS_S3_FILE_OVERWRITE = False# True일 경우 같은 파일을 올렸을 때 덮어씌워진다.# False를 하면 같은 파일이 올라와도 덮어씌워지지 않게 파일 이름을 자동으로 바꿔줌# 브라우저가 해당 파일에 접속 했을 때 나타나는 파라미터 값AWS_S3_OBJECT_PARAMETERS = &#123;'CacheControl': 'max-age=86400',&#125;# 지금올리는 파일의 권한을 지정해줌AWS_DEFAULT_ACL = 'public-read'AWS_LOCATION = ''STATIC_URL = 'https://%s/%s/' % (AWS_S3_CUSTOM_DOMAIN, AWS_LOCATION)STATICFILES_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'# S3Boto와 S3Boto3는 지금 같이 사용할 수 있지만 S3Boto는 곧 사라지기 떄문에 S3Boto3를 사용# 쓰던 방식을 계속 쓰는 것이 문제 - 의존성 패키지 목록 관리# Django 1.8이 LTS# Django 2.2 -&gt; LTS -&gt; Long Tern Service# 로거를 사용해서 로그를 s3에 있는 파일에 업로드 장고 프로젝트에서 S3를 사용하기 위해 모듈 설치 123$ pip install django-storages$ pip install boto3 프로젝트에 포함된 스테틱 파일들을 S3에 업로드 1$ python manage.py collectstatic AWS 홈페이지의 S3에서 static 파일이 업로드되었는지 해당 버킷에서 확인 미디어 파일도 설정하기 위해 settings.py에 설정 추가 123# storages.backends.s3boto3.S3Boto3Storage를 사용할 수 있지만# static 파일과 같은 경로에서 관리되기 때문에 미디어 파일을 별도로 분리하고 싶다면 스토리지 모듈을 별도로 상속받아 변경한다.DEFAULT_FILE_STORAGE = 'config.s3media.MediaStorage' config/s3media.py를 생성 1234567891011121314151617from storages.backends.s3boto3 import S3Boto3Storage# 기본 설정값을 오버라이드 하기 위해서 S3Boto3Storage를 상속한다.class MediaStorage(S3Boto3Storage): # 업로드될 버킷 bucket_name = 'media.sample.jinukk.me' # 업로드될 버킷 하위의 폴더이름 location = '' # 버킷이 존재하는 리전 region_name = 'ap-northeast-2' # 실제로 파일에 접속할 때 사용할 주소 # 직접 파일을 올려보고 주소를 확인하자. custom_domain = 'https://%s/%s/' % (region_name, bucket_name) file_overwrite = False 미디어 파일 테스트를 위해 간단한 모델을 만들고 관리자 페이지에서 이미지 업로드 123456789101112131415# models.pyfrom django.db import modelsclass Sample(models.Model): image = models.ImageField(upload_to='sample/%Y/%m/%d', blank=True)# admin.pyfrom django.contrib import admin# Register your models here.from .models import Sampleadmin.site.register(Sample) 관리자 페이지에서 이미지를 업로드해보고 AWS에서 해당 버킷에 업로드되었는지 확인 S3에 도메인을 연결한다. 파일 주소에 S3임이 노출되기 때문에 도메인을 연결하여 사용한다. 반드시 버킷 이름과 도메인이 동일해야 한다. 버킷을 처음 만들 때부터 도메인을 염두에 두고 만들자. [서비스] 메뉴에서 스토리지/S3로 이동하여 설정할 버킷 이름을 누른다. 속성 탭을 클릭하여 정적 웹 사이트 호스팅을 활성화 상태로 변경한다. [이 버킷을 사용하여 웹 사이트를 호스팅합니다.]를 누름 index.html과 error.html을 입력하고 저장을 누름 버킷 호스팅이 활성화되었는지 확인 [서비스] 메뉴에서 네트워크 및 콘텐츠 전송/Route 53으로 이동한다. DNS 관리에서 호스팅 영역을 누른다. S3에서 사용할 도메인을 누르고 레코드 세트 생성을 누른다. 레코드 세트 생성 창에서 S3 버킷과 동일한 이름으로 설정한다. 유형은 [A - IPv4] 주소를 선택한다. 별칭은 [예]를 선택하고 별칭 대상 목록에 나타난 S3 버킷을 선택하고 생성한다. static과 media 모두 생성하도록 한다. 레코드 목록에 잘 나타나는지 확인한다. PyCharm 프로젝트에서 settings.py에 설정을 변경한다. 주소 자체가 버킷 이름과 같아지기 때문에 버킷 이름을 변경한다. S3 단독으로는 https를 사용할 수 없기 때문에 http로 변강하는 설정값을 추가한다.123AWS_S3_CUSTOM_DOMAIN = AWS_STORAGE_BUCKET_NAME# https가 아니라 http로 주소를 노출하기 위해 사용AWS_S3_SECURE_URLS = False config/s3media.py도 수정 1custom_domain = bucket_name 이미지 주소를 입력하여 잘 나오는지 확인","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.17 Django Study","slug":"190517-Django-Study","date":"2019-05-17T11:26:06.000Z","updated":"2019-05-17T11:27:01.207Z","comments":true,"path":"2019/05/17/190517-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/17/190517-Django-Study/","excerpt":"","text":"[ Board project ] AJAX 비동기식 JavaScript와 XML(Asynchronos Javascript And XML) JavaScript를 통해서 서버에 데이터를 요청 서버에 로딩된 데이터를 페이지에 보여주기 위해 새로운 HTML 페이지로 가지 않음 ajax를 통해 주로 주고 받는 형태가 XML이나 JSON 댓글 기능에 AJAX 적용하기 버튼을 통해 데이터 가져오기 1234567891011121314151617181920# views.py에 추가\"\"\"일반적인 경우 데이터를 전송하기 위해 json 사용\"\"\"from django.http import JsonResponsedef get_data_ajax(request): data = &#123; \"name\":'Jake', \"age\":100, \"bloodtype\":\"0\", &#125; return JsonResponse(data)# urls.py에 추가from .views import get_data_ajaxurlpatterns = [ path('ajax/get_data/', get_data_ajax, name='get_data_ajax'),] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!--// board_project/layout/base.html //--&gt;&lt;!--// bootstrap JS 적용에서 3개의 Script 중에 첫번째 Script 교체 적용jQuery.com - Download - google CDN - jQuery/3.x snippet의 내용 작성//--&gt;&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\" integrity=\"sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\" integrity=\"sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;!--// board_project/board/templates/board/document_list.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Document List&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-12\"&gt; &lt;table class=\"table table-striped\"&gt; &#123;% for object in object_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;object.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;object.title&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;object.author.username&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;object.updated&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt; &lt;!--// 데이터가 표시될 곳 지정 //--&gt; &lt;div class=\"data_area\"&gt; 데이터가 입력될 곳 &lt;/div&gt; &lt;!--// url 연결 //--&gt; &lt;a href=\"&#123;% url 'board:get_data_ajax' %&#125;\" class=\"btn_get_data btn btn-primary\"&gt;데이터 가져오기&lt;/a&gt; &lt;nav aria-label=\"Page navigation example\"&gt; &lt;ul class=\"pagination justify-content-center\"&gt; &#123;% for page in page_range %&#125; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" href=\"&#123;% url 'board:list' %&#125;?page=&#123;&#123;page&#125;&#125;\"&gt;&#123;&#123;page&#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/nav&gt; &lt;form action=\"\" method=\"get\" id=\"search_form\" class=\"\"&gt; &#123;%csrf_token%&#125; &lt;div class=\"form-row align-items-center justify-content-center\"&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"checkbox\" name=\"search_type\" id=\"inlineCheckbox1\" value=\"author\"&gt; &lt;label class=\"form-check-label\" for=\"inlineCheckbox1\"&gt;작성자&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"checkbox\" name=\"search_type\" id=\"inlineCheckbox2\" value=\"title\"&gt; &lt;label class=\"form-check-label\" for=\"inlineCheckbox2\"&gt;제목&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"checkbox\" name=\"search_type\" id=\"inlineCheckbox3\" value=\"text\"&gt; &lt;label class=\"form-check-label\" for=\"inlineCheckbox3\"&gt;본문&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-row align-items-center justify-content-center\"&gt; &lt;div class=\"col-sm-3 my-1\"&gt; &lt;input type=\"text\", class=\"form-control\" placeholder=\"Search Keyword\" name=\"search_key\"&gt; &lt;/div&gt; &lt;div class=\"col-auto my-1\"&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;Search&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&#123;% block extra_script %&#125;&lt;script type=\"text/javascript\"&gt;// 1. 버튼을 누르면 페이지 이동이 안되도록// 2. 데이터를 가져오기$(function()&#123; // 페이지 로딩이 끝나면 할일들 $('.btn_get_data').click(function(e)&#123; e.preventDefault(); // 버튼을 클릭하면 이동 못하게 기본 기능 취소 //alert('clicked'); // 확인을 위해 알림창 띄우기 url = $(this).attr('href'); $.ajax(&#123; // ajax 호출이 사용할 매개변수 url:url &#125;).done(function(data)&#123; // 호출이 끝나면 받은 데이터를 처리하는 부분 name = data.name; age = data.age; bloodtype = data.bloodtype //alert(data.bloodtype); html = \"&lt;ul&gt;&lt;li&gt;\"+name+\"&lt;/li&gt;&lt;li&gt;\"+age+\"&lt;/li&gt;&lt;li&gt;\"+bloodtype+\"&lt;/li&gt;&lt;/ul&gt;\"; $('.data_area').html(html); &#125;); &#125;);&#125;);&lt;/script&gt;&#123;% endblock %&#125; 댓글 기능에 ajax 적용 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# views.py에 추가from django.template.loader import render_to_stringdef comment_create(request, document_id): # ajax 기능에 의해 호출된 것인지 구분하기 위한 값 is_ajax = request.POST.get('is_ajax') document = get_object_or_404(Document, pk=document_id) comment_form = CommentForm(request.POST) comment_form.instance.author_id = request.user.id comment_form.instance.document_id = document_id if comment_form.is_valid(): comment = comment_form.save() # 만약 ajax에 의해 호출되었다면 redirection없이 Json 형태로 응답 if is_ajax: # 데이터를 만들어서 던져주기 html = render_to_string('board/comment/comment_single.html',&#123;'comment':comment&#125;) return JsonResponse(&#123;'html':html&#125;) return redirect(document)from django.contrib import messagesdef comment_update(request, comment_id): # GET과 POST를 구분 is_ajax, data = (request.GET.get('is_ajax'), request.GET) if 'is_ajax' in request.GET \\ else (request.POST.get('is_ajax', False), request.POST) comment = get_object_or_404(Comment, pk=comment_id) document = get_object_or_404(Document, pk=comment.document.id) if request.user != comment.author: messages.warning(request, \"권한 없음\") return redirect(document) # ajax에 의해 호출될 때 응답 if is_ajax: form = CommentForm(data, instance=comment) if form.is_valid(): form.save() return JsonResponse(&#123;'works':True&#125;) if request.method == \"POST\": form = CommentForm(request.POST, instance=comment) if form.is_valid(): form.save() return redirect(document) else: form = CommentForm(instance=comment) return render(request, 'board/comment/update.html', &#123;'form':form&#125;)def comment_delete(request, comment_id): # GET과 POST를 구분 is_ajax = request.GET.get('is_ajax') if 'is_ajax' in request.GET else request.POST.get('is_ajax', False) comment = get_object_or_404(Comment, pk=comment_id) document = get_object_or_404(Document, pk=comment.document.id) if request.user != comment.author and not request.user.is_staff and request.user != document.author: messages.warning(request, \"권한 없음\") return redirect(document) # ajax에 의해 호출될 때 응답 if is_ajax: comment.delete() return JsonResponse(&#123;'works':True&#125;) if request.method == \"POST\": comment.delete() return redirect(document) else: return render(request, 'board/comment/delete.html', &#123;'object':comment&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;!--// board_project/board/templates/board/document_detail.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Document Detail&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &#123;&#123;object.title&#125;&#125; &#123;&#123;object.text&#125;&#125; &#123;&#123;object.image.url&#125;&#125; &#123;&#123;object.author.username&#125;&#125;&lt;br&gt; &lt;hr&gt; &lt;!--// form에 id 추가 //--&gt; &lt;form action=\"&#123;% url 'board:comment_create' object.id %&#125;\" method=\"post\" id=\"comment_form\"&gt; &#123;% csrf_token %&#125; &lt;input type=\"hidden\" name=\"is_ajax\" value=\"\"&gt; &#123;&#123;comment_form.as_p&#125;&#125; &lt;input type=\"submit\" value=\"Comment\" class=\"btn btn-outline-primary\"&gt; &lt;/form&gt; &lt;div id=\"docs_comment_list_area\"&gt; &#123;% include 'board/comment_list.html' %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&#123;% block extra_script %&#125;&lt;script type=\"text/javascript\"&gt;// 댓글의 생성, 수정, 삭제에 대한 script 추가 $(function() &#123; // 1. 누구한테 이벤트를 설정할 것인가? // 2. 어떤 이벤트를 설정할 것인가? $('#comment_form').submit(function(e) &#123; // alert('댓글 쓰기 완료'); // 댓글 남기기 $('input[name=\"is_ajax\"]').val(\"1\"); url = $(this).attr('action'); params = $(this).serialize(); // 전달해주는 데이터들을 하나로 합침 $.ajax(&#123; url:url, method:\"POST\", data:params &#125;).done(function(data) &#123; // 댓글 입력창 내용 비우기 $('#id_text').val(\"\"); $('#comment_list tbody').prepend(data.html); // tbody 시작 지점에 요소 끼워넣기 // $('#comment_list tbody').append(tr); // tbody 끝 지점에 요소 끼워넣기 // is_ajax 값 초기화 $('input[name=\"is_ajax\"]').val(\"\"); &#125;); return false; &#125;); $('.btn_comment_delete').click(function(e) &#123; e.preventDefault(); var input = confirm('댓글을 삭제하시겠습니까?'); if (input==true) &#123; alert('댓글을 삭제하였습니다.'); // ajax 호출 comment = $(this).parents('tr'); url = $(this).attr('href')+\"?is_ajax=1\"; $.ajax(&#123; url:url &#125;).done(function(data) &#123; if(data.works) &#123; comment.remove(); // 해당 객체 지우기 &#125; &#125;); &#125; &#125;); $('.btn_comment_update').click(function(e) &#123; e.preventDefault(); url = $(this).attr('href')+\"?is_ajax=1\"; comment = $(this).parent().siblings('.comment_text'); // 원래 댓글을 찾음 //text = prompt('수정될 댓글 내용을 입력하세요.', comment.text()); // 원래 댓글을 프롬프트로 보여줌 //if(text==null) return false; // 입력 취소면 함수 종료 input = \"&lt;input type='text' class='update_text' value='\"+comment.text()+\"'&gt;\"; comment.html(input); $('.update_text').keypress(function(e)&#123; if(e.keyCode==13) &#123; // 키보드 Enter에 대한 키 값 설정 text = $(this).val(); $.ajax(&#123; url:url, data:&#123; text:text &#125; &#125;).done(function(data) &#123; // 댓글 수정이 끝나면 할 일 if(data.works) &#123; comment.text(text); &#125; &#125;); &#125; &#125;); &#125;); &#125;);&lt;/script&gt;&#123;% endblock %&#125;&lt;!--// board_project/board/templates/board/comment_list.html //--&gt;&lt;!--// table에 id 추가//--&gt;&lt;table class=\"table table-strped\" id=\"comment_list\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th colspan=\"3\" class=\"align-left\"&gt;댓글 목록&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for comment in comments %&#125; &lt;!--// include를 통해 겹치는 구문 제거 //--&gt; &#123;% include 'board/comment/comment_single.html' %&#125; &#123;% endfor %&#125; &lt;/tbody&gt;&lt;/table&gt;&lt;!--// board_project/board/templates/board/comment_list.html //--&gt;&lt;!--// tr 문에 class 이름 추가 //--&gt;&lt;tr class=\"comment_row\"&gt; &lt;!--// 해당 td 문에 class 이름 추가 //--&gt; &lt;td colspan=\"3\" class=\"comment_text\"&gt;&#123;&#123;comment.text&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;comment.author.username&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;comment.created&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=\"&#123;% url 'board:comment_update' comment.id %&#125;\" class=\"btn btn-outline-dark btn-sm btn_comment_update\"&gt;Update&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"&#123;% url 'board:comment_delete' comment.id %&#125;\" class=\"btn btn-outline-danger btn0sm btn_comment_delete\"&gt;Delete&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.16 Django Study","slug":"190516-Django-Study","date":"2019-05-16T12:45:36.000Z","updated":"2019-05-16T12:46:23.890Z","comments":true,"path":"2019/05/16/190516-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/16/190516-Django-Study/","excerpt":"","text":"[ Board project ] 댓글 기능 적용 models.py에 comment 모델 작성 123456789101112131415161718class Comment(models.Model): # Todo : 댓글 남기기를 위해서 Form # Todo : 뷰 처리는 Documents의 뷰 # 해당 게시글의 댓글이기 때문에 document라는 ForeignKey 적용 document = models.ForeignKey(Document, on_delete=models.CASCADE, related_name='comments') author = models.ForeignKey(get_user_model(), on_delete=models.SET_NULL, null=True, blank=True, related_name='comments') text = models.TextField() created = models.DateTimeField(auto_now_add=True) updated = models.DateTimeField(auto_now=True) like = models.IntegerField(default=0) # ManyToMany dislike = models.IntegerField(default=0) def __str__(self): return (self.author.username if self.author else \"무명\") +\"의 댓글\"# makemigrations와 migrate를 실행하자. forms.py 작성 123456789101112class CommentForm(forms.ModelForm): # text = forms.TextInput(label=\"댓글\") class Meta: model = Comment fields = ['text'] def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.fields['text'].label = \"댓글\" self.fields['text'].widget = forms.TextInput() self.fields['text'].widget.attrs = &#123;'class': \"form-control\", 'placeholder':\"댓글을 입력하세요\"&#125; views.py 작성 페이지에 접근했을 때 구동되는 로직들 함수형 뷰(Function Based View) 해당 객체가 있는지 확인(get_object_or_404, object.filter.exists) 객체에 대한 권한 체크 - 작성자, 관리자 get, post get : 해당 페이지에 필요한 값 입력 받기 post : 입력받은 값에 대한 처리 -&gt; 삭제, 업데이트 처리 후 페이지 이동 클래스형 뷰(Class Based View) 객체에 대한 권한 체크(dispatch) - 작성자, 관리자 해당 객체가 있는지 확인(get_object, get_queryset) get, post get : 해당 페이지에 필요한 값 입력 받기 post : 입력 받은 값에 대한 처리 -&gt; 삭제, 업데이트 처리 후 페이지 이동 함수형 뷰와 클래스형 뷰의 로직이 다른 것은 아니다.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# Comment 모델 추가from .models import Board, Category, Document, PhoneNumber, Comment# 접근 권한의 메시지 출력을 위한 messages 모듈 추가from django.contrib import messages# comment 생성 뷰 추가# detail 부분에서 comment를 생성하는 부분을 나눔def comment_create(request, document_id): document = get_object_or_404(Document, pk=document_id) comment_form = CommentForm(request.POST) # 작성자 = 현재 로그인 사용자 comment_form.instance.author_id = request.user.id # 댓글을 달고 있는 게시글 = 현재 보고 있는 게시글 comment_form.instance.document_id = document_id if comment_form.is_valid(): comment = comment_form.save() # redirect(reverse('board:detail', args=[document_id])) # models.py의 document에서 get_absolute_url()을 지정 return redirect(document)# comment 수정 뷰 추가def comment_update(request, comment_id): # 수정할 comment comment = get_object_or_404(Comment, pk=comment_id) # 수정할 cooment의 게시글 document = get_object_or_404(Document, pk=comment.document.id) # user.is_staff # user.is_superuser # 현재 로그인 사용자가 comment의 작성자가 아니라면 if request.user != comment.author: # '권한 없음'이라는 메시지 출력 messages.warning(request, \"권한 없음\") return redirect(document) if request.method == \"POST\": # instance를 추가해야 새로 생성하는 것이 아닌 update인 것을 알 수 있다. form = CommentForm(request.POST, instance=comment) if form.is_valid(): form.save() return redirect(document) else: form = CommentForm(instance=comment) return render(request, 'board/comment/update.html', &#123;'form':form&#125;)# comment 삭제 뷰 추가def comment_delete(request, comment_id): comment = get_object_or_404(Comment, pk=comment_id) document = get_object_or_404(Document, pk=comment.document.id) # 조건 # 1. 현재 로그인한 사용자가 comment 작성자가 아님 # 2. 현재 로그인한 사용자가 관리자 권한이 아님 # 3. 현재 로그인한 사용자가 게시글의 작성자가 아님 if request.user != comment.author and not request.user.is_staff and request.user != document.author: messages.warning(request, \"권한 없음\") return redirect(document) if request.method == \"POST\": comment.delete() return redirect(document) else: return render(request, 'board/comment/delete.html', &#123;'object':comment&#125;)# detail 페이지에서 comment 동작 처리# comment 생성을 처리할 수 있으나, comment_create라는 함수형 뷰를 따로 작성# detail와 연결된 tmplate 파일 안에서 comment를 생성하는 template 파일 부분을 나눔def document_detail(request, document_id): # document = Document.objects.get(pk=document_id) document = get_object_or_404(Document, pk=document_id) # 만약 post일 때만 댓글 입력에 관한 처리를 더한다. # if request.method == \"POST\": # comment_form = CommentForm(request.POST) # comment_form.instance.author_id = request.user.id # comment_form.instance.document_id = document_id # if comment_form.is_valid(): # comment = comment_form.save() comment_form = CommentForm() # 현재 보고 있는 게시글의 comments들을 모두 불러옴 comments = document.comments.all() # document 입장에서의 comments return render(request, 'board/document_detail.html', &#123;'object':document, 'comments':comments, 'comment_form':comment_form&#125;) board/urls.py 작성 123456789urlpatterns = [ # 아래 항목 추가 # comment 생성 관련 path('create/&lt;int:document_id&gt;/', comment_create, name='comment_create'), # comment 수정 관련 path('comment/update/&lt;int:comment_id&gt;/', comment_update, name='comment_update'), # comment 삭제 관련 path('comment/delete/&lt;int:comment_id&gt;/', comment_delete, name='comment_delete'),] template 파일 작성 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!--// templates/board/document_detail.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Photo Detail&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &#123;&#123;object.title&#125;&#125; &#123;&#123;object.text&#125;&#125; &#123;&#123;object.image.url&#125;&#125; &#123;&#123;object.author.username&#125;&#125;&lt;br&gt; &lt;hr&gt; &lt;!--// action에 comment_create 지정 //--&gt; &lt;form action=\"&#123;% url 'board:comment_create' object.id %&#125;\" method=\"post\" enctype=\"multipart/form-data\"&gt; &#123;% csrf_token %&#125; &#123;&#123;comment_form.as_p&#125;&#125; &lt;input type=\"submit\" value=\"Comment\" class=\"btn btn-outline-primary\"&gt; &lt;/form&gt; &lt;!--// comment_list.html 적용 //--&gt; &lt;div id=\"docs_comment_list_area\"&gt; &#123;% include 'board/comment_list.html' %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&lt;!--// templates/board/comment_list.html //--&gt;&lt;table class=\"table table-strped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th colspan=\"3\" class=\"align-left\"&gt;댓글 목록&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &#123;% for comment in comments %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;comment.text&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;comment.author.username&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;comment.created&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=\"&#123;% url 'board:comment_update' comment.id %&#125;\" class=\"btn btn-outline-primary\"&gt;Update&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"&#123;% url 'board:comment_delete' comment.id %&#125;\" class=\"btn btn-outline-danger\"&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125;&lt;/table&gt;&lt;!--// templates/board/comment/update.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Board Create&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &#123;% csrf_token %&#125; &#123;&#123;form.as_p&#125;&#125; &lt;input type=\"submit\" value=\"Update\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&lt;!--// templates/board/comment/delete.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Board Create&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;div class=\"alert alert-info\"&gt;Do you want to delete &#123;&#123;object&#125;&#125;?&lt;/div&gt; &#123;% csrf_token %&#125; &lt;input type=\"submit\" value=\"Delete\" class=\"btn btn-outline-danger\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; admin.py 작성 12345678910111213# Comment 추가from .models import Board,Category,Document,PhoneNumber, Comment# TabularInline 적용class CommentInline(admin.TabularInline): model = Comment# 관리자 페이지에서 ForeinKey로 연결된 데이터를 쉽게 관리하기 위해 추가# 현재 게시글 안에서 댓글 데이터 관리 용이class DocumentOption(admin.ModelAdmin):list_display = ['id', 'category', 'author', 'title', 'slug', 'created', 'updated']prepopulated_fields = &#123;'slug':('title',)&#125;inlines = [CommentInline]","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.15 Django Study","slug":"190515-Django-Study","date":"2019-05-15T07:56:18.000Z","updated":"2019-05-16T10:05:10.309Z","comments":true,"path":"2019/05/15/190515-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/15/190515-Django-Study/","excerpt":"","text":"[ Board project ] F() 객체 모델의 필드 값을 참조하여 데이터베이스 작업을 수행할 수 있다.12345678from django.db.models import Q, Ffrom board.models import * # Board, Category, Document# 'title'이라는 문자열을 검색Document.objects.filter(title__icontains='title')# 필드 값인 title을 참조하여 검색Document.objects.filter(title__icontains=F('title')) selet_related() Join Query를 만들어서 한 큐에 데이터를 불러온다. Join을 사용하기 때문에 ForeignKey와 같이 single valued relationships에서만 사용 가능하다. prefetch_related() 모델 객체들을 불러서 코드 단에서 병합한다. ManyToMany를 포함해서 모든 relationships에서 사용 가능하다. select_related()와 prefetch_related()를 사용하지 않는 경우 참조 테이블에 대한 데이터 질의를 항상 수행한다. QuerySet Cache Query는 마지막까지 지연된다. 123456789from django.db.models import Q, Ffrom board.models import *# 아래 코드를 실행해도 DB에 쿼리는 수행되지 않는다.object_list = Document.objects.all()# 아래와 같이 쿼리셋을 순회해야 쿼리가 수행된다.for object in object_list: print(object.author.username) DB에 레코드들을 실제로 와서 Django model로 변환되는 것을 평가(evaluation)라고 한다. 평가된 모델들은 쿼리셋의 내장 캐시에 저장된다. 따라서 같은 쿼리셋을 재순회하더라도 DB에 전달하지 않는다.123456789101112131415161718192021# 여기는 쿼리가 실행되지 않은 부분object_list = Document.objects.all()# 캐싱이 일어나지 않음object_list[4]# 캐싱이 일어나지 않음object_list[5]object_list = Document.objects.all()[object.title for object on object_list]# 캐싱이 일어남object_list[4]# 캐싱이 일어남object_list[5]# 캐싱이 일어나지 않는다.# Document.object.all()을 변수에 담아놓고 실행해야 한다.for object in Document.object.all(): print(object.title) exclude() 특정 조건을 제외한 나머지 데이터들을 가져오기 위해 사용한다. 여러 조건들을 묶을 때에는 사용되지 않는다. 정렬 QuerySet의 기본 정렬값 = 모델에서 설정값 123Model: class Meta: orderng = ['field name'] 기본 정렬값은 pk 오름차순(asc) 1Document.objects.all().order_by('title') 내림차순(desc) 1Document.objects.all().order_by('-title') 삭제 1Document.objects.get(pk=1).delete() 갱신 123456Document.objects.get(pk=1).update(title=\"example\")# 전체 레코드에 대한 갱신Document.objects.all().update(title=\"example\")Document.objects.filter(title__icontain='word').update(title=\"example\") logging 사용하기 setting.py에 추가한다. 터미널 창에서 쿼리문 출력을 확인한다.12345678910111213141516171819202122LOGGING = &#123; 'version':1, 'disable_existing_loggers':False, 'handlers': &#123; 'console':&#123; 'class':'logging.StreamHandler', &#125; &#125;, 'loggers':&#123; 'django':&#123; 'handlers':['console'], 'level':'DEBUG', &#125; &#125;&#125;\"\"\"import loggingl = logging.getLogger('django.db.backends')l.setLevel(logging.DEBUG)l.addHandler(logging.StreamHandler())\"\"\" 소셜 미디어 로그인 연동하기 Django-allauth 사용 django-allauth 문서 홈페이지로 이동하여 참고 네이버 이용 해당 모듈을 설치한다. 1$ pip install django-allauth settings.py를 수정한다. 1234567891011121314151617181920212223242526272829INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'board', 'storages', # 항목 추가 'django.contrib.sites', 'allauth', 'allauth.account', 'allauth.socialaccount', # 네이버를 이용하기 위해 추가 'allauth.socialaccount.providers.naver',]# 항목 추가AUTHENTICATION_BACKENDS = ( 'django.contrib.auth.backends.ModelBackend', 'allauth.account.auth_backends.AuthenticationBackend',)# 추가SITE_ID = 1# 로그인 후에 이동할 경로 추가LOGIN_REDIRECT_URL = '/' config/urls.py에 경로를 추가한다. 1path('accounts/', include('allauth.urls')), migrate를 한다. 1$ python manage.py migrate django-allauth 문서 홈페이지에서 providers 탭에서 네이버 항목으로 이동한다. https://developers.naver.com/appinfo 로 이동한다. 애플리케이션을 등록한다. 애플리케이션 이름을 작성한다. 사용 API는 네아로(네이버 아이디로 로그인)를 선택한다. 필수 항목에 회원이름과 이메일만 체크한다. 나머지는 추가 항목으로 넣을 수 있다. 환경은 PC웹을 선택하고 URL을 다음과 같이 설정한다.123456- 서비스 URL&gt;&gt; http://127.0.0.1:8000- Callback URL- django-allauth 문서 홈페이지에서 providers 탭의 네이버 항목에 있다.&gt;&gt; http://127.0.0.1:8000/accounts/naver/login/callback/ 서버를 실행하고 관리자 사이트로 접속하고, 소셜 어플리케이션을 추가한다. 소셜 계정/소셜 어플리케이션/소셜 어플리케이션 추가12345제공자 : Naver이름 : 네이버 로그인클라이언트 아이디 : 네이버 API 등록 시 발급되는 Client ID비밀 키 : 네이버 API 등록 시 발급되는 Client Secretsites : example.com 선택 http://127.0.0.1:8000/account/login 에 접속하여 naver를 누르고 로그인한다. admin으로 접속되어 있다면 로그아웃하자. base.html에 로그인/로그아웃 URL을 추가하자.123456789&lt;!--// base.html //--&gt;&#123;% if user.is_authenticated %&#125;&lt;!--// django-allauth 문서 홈페이지/Views 탭에서 로그인, 로그아웃 URL 이름 확인 //--&gt;&lt;a href=\"&#123;% url 'account_logout' %&#125;\"&gt;Logout&lt;/a&gt;&#123;% else %&#125;&lt;a href=\"&#123;% url 'account_login' %&#125;\"&gt;Login&lt;/a&gt;&#123;% endif %&#125; 다시 관리자 페이지를 접속하여 소셜 계정에 등록되어 있는지 확인한다. 회원가입을 할 때 사용자 이름 등록하기 django-allauth 문서 홈페이지/Signals 탭에서 관련 명령어를 확인할 수 있다. 1234567891011121314# views.pyfrom allauth.account.signals import user_signed_upfrom allauth.socialaccount.models import SocialAccount# 시그널이 발생했을 때 실행될 함수def naver_signup(request, user, **kwargs): social_user = SocialAccount.objects.filter(user=user) if social_user.exists(): user.last_name = social_user[0].extra_data['name'] user.save()# 시그널과 해당 함수를 connect# 시그널 연결 방법 2가지 receiver 쓰는 방법, connect 쓰는 방법user_signed_up.connect(naver_signup) 관리자 페이지에서 인증 및 권한/사용자(들)에서 계정을 삭제하고 다시 만들어보자. 이름이 등록되어 있는지 확인하자.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.14 Django Study","slug":"190514-Django-Study","date":"2019-05-14T10:38:43.000Z","updated":"2019-05-14T10:46:15.416Z","comments":true,"path":"2019/05/14/190514-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/14/190514-Django-Study/","excerpt":"","text":"[ Board project ] get_object_or_404, get_list_or_404 데이터가 하나도 없다면 에러 발생 views.py 수정123456789101112131415161718192021222324252627282930313233343536# 해당 모듈 추가from django.shortcuts import render, get_object_or_404, redirect, get_list_or_404# document_list의 documents 수정# get_list_or_404 사용def document_list(request): # documents = Document.objects.all() documents = get_list_or_404(Document) # objects.all()을 포함하는 코드 return render(request, 'board/document_list.html',&#123;'object_list':documents&#125;)# document_update의 documents 수정# get_object_or_404 사용def document_update(request, document_id): # 객체를 불러와서, 데이터를 수정 if request.method == \"POST\": # document = Document.objects.get(pk=document_id) document = get_object_or_404(Document, pk=document_id) form = DocumentForm(request.POST, request.FILES, instance=document) if form.is_valid(): document = form.save() return redirect(document) else: # document = Document.objects.get(pk=document_id) document = get_object_or_404(Document, pk=document_id) form = DocumentForm(instance=document) return render(request, 'board/document_update.html',&#123;'form':form&#125;)# document_detail의 documents 수정# get_object_or_404 수정def document_detail(request, document_id): # document = Document.objects.get(pk=document_id) document = get_object_or_404(Document, pk=document_id) return render(request, 'board/document_detail.html', &#123;'object':document&#125;) paging 기능 추가 기능 구현 포인트 현재 페이지가 몇 페이지인지 생각한다. 페이지 당 개수를 몇으로 할 것인지 생각한다. views.py의 document_list(request) 수정 123456789101112131415161718192021222324252627282930313233# 모듈 추가import mathdef document_list(request): # QuerySet # 1. 객체를 선택 # 2. 객체 생성 # 3. 객체 필터링 # 4. 객체 삭제 page = int(request.GET.get('page', 1)) # 페이징 기능을 구현 # 페이지 당 개수 paginated_by = 3 # QuerySet 객체 슬라이싱 할 때 [시작번호:끝번호] # 1 = 0 부터 ===== page*paginated_by # 2 = paginated_by*(page-1) ==== 6 # 3 = paginated_by*(page-1) ==== 9 total_count = len(documents) total_page = math.ceil(total_count/paginated_by) page_range = range(1, total_page+1) # 전체 개수 = 전체 페이지 수 start_index = paginated_by * (page - 1) end_index = paginated_by * page documents = get_list_or_404(Document) documents = documents[start_index:end_index] return render(request, 'board/document_list.html',&#123;'object_list':documents, 'total_page':total_page, 'page_range':page_range&#125;) document_list.html 수정 12345678910111213141516171819202122232425262728293031&#123;% extends 'base.html' %&#125; &#123;% block title %&#125; Photo List &#123;% endblock %&#125; &#123;% block content %&#125; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-12\"&gt; &lt;table class=\"table table-striped\"&gt; &#123;% for object in object_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;object.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;object.title&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;object.author.username&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;object.updated&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt; &lt;!--// Pagination 적용 //--&gt; &lt;nav aria-label=\"Page navigation example\"&gt; &lt;ul class=\"pagination justify-content-center\"&gt; &#123;% for page in page_range %&#125; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" href=\"&#123;% url 'board:list' %&#125;?page=&#123;&#123;page&#125;&#125;\"&gt;&#123;&#123;page&#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% endblock %&#125; 검색 기능 추가 검색 기능을 구별하는 위치 DB 질의문 - like 구문 코드 레벨 검색(python 구문) 검색 기능을 구현 순서 먼저 검색어를 제대로 받았는지 확인 filter 적용 어떤 항목으로 할 것인가? - ex) 작성자, 제목, 내용 어떤 옵션으로 할 것인가? - ex) 내용 중에 단어를 시작, 중간, 끝에서 검색 views.py의 document_list(request) 수정 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103 # 모듈 추가 from django.db.models import Q def document_list(request): # QuerySet # 1. 객체를 선택 # 2. 객체 생성 # 3. 객체 필터링 # 4. 객체 삭제 page = int(request.GET.get('page', 1)) paginated_by = 3 \"\"\" username =&gt; Q(author__username__icontains=search_key) title =&gt; Q(title__icontains=search_key) text =&gt; Q(text__icontains=search_key) q1|q2|q3 if search_key and search_type: documents = get_list_or_404(Document, q1|q2|q3) \"\"\" \"\"\" 필드명 = \"값\" 매칭 필드명__exact = \"값\" 매칭 필드명__iexact = \"값\" 대소문자 구분없이 매칭 __startswith, __istartswitch 값으로 시작 __endswith, __iendswith 값으로 끝 __contains, __icontains 값을 포함하는지 ForeignKey 매칭 필드명__해당모델의필드명 매칭 필드명__해당모델의 필드명__옵션 위와 동일하게 동작 __gt=값, __gte=크다, 크거나 같다. ex) created__gt = 오늘 =&gt; 작성일이 오늘보다 크다. __lt=값, __lte=작다, 작거나 같다. ex) created__lt = 오늘 =&gt; 작성일이 오늘보다 이전 ex) 판매시작일__lte = 오늘 =&gt; 판매시작일 설정값이 오늘보다 작거나 같으면 판매 시작 \"\"\" \"\"\" objects.filter() : filter 메서드에 들어가는 매개변수들은 항상 and 연산을 한다. or 연산을 하고 싶어서 Q 객체를 사용한다. 사용법은 filter에 들어가는 매개변수의 작성법과 똑같다. Q() | Q() = or Q() &amp; Q() = and ~Q() = notQ 객체를 쓰려면 맨뒤에 일반 필터를 써야한다. Q 객체 앞으로 일반필터를 사용하면 안된다.ex) Document.objects.filter(third_q , default_q | second_q) -&gt; third_q와 default_q | second_q의 and라는 의미 \"\"\" # 검색 사용방법 # documents = Document.objects.filter(title__icontains='검색어') # ex) documents = get_list_or_404(Document,title__icontains='검색어') # request.METHOD.get -&gt; 아이템 1개 # request.METHOD.getlist -&gt; 리스트형태로 search_type = request.GET.getlist('search_type', None) search_key = request.GET.get('search_key', None) if search_key and search_type: q1 = Q(author__username__icontains=search_key) if 'author' in search_type else Q() q2 = Q(title__icontains=search_key) if 'title' in search_type else Q() q3 = Q(text__icontains=search_key) if 'text' in search_type else Q() documents = get_list_or_404(Document, q1|q2|q3) else: documents = get_list_or_404(Document) # 다른 방법 # search_q = None # # if search_key and search_type: # if 'author' in search_type: # temp_q = Q(author__username__icontains=search_key) # search_q = search_q | temp_q if search_q else temp_q # if 'title' in search_type: # temp_q = Q(title__icontains=search_key) # search_q = search_q|temp_q if search_q else temp_q # if 'text' in search_type: # temp_q = Q(text__icontains=search_key) # search_q = search_q | temp_q if search_q else temp_q # # documents = get_list_or_404(Document, search_q) # else: # documents = get_list_or_404(Document) total_count = len(documents) total_page = math.ceil(total_count/paginated_by) page_range = range(1, total_page+1) start_index = paginated_by * (page - 1) end_index = paginated_by * page documents = documents[start_index:end_index] return render(request, 'board/document_list.html',&#123;'object_list':documents, 'total_page':total_page, 'page_range':page_range&#125;) document_list.html 수정 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Photo List&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-12\"&gt; &lt;table class=\"table table-striped\"&gt; &#123;% for object in object_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;object.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;object.title&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;object.author.username&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;object.updated&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt; &lt;nav aria-label=\"Page navigation example\"&gt; &lt;ul class=\"pagination justify-content-center\"&gt; &#123;% for page in page_range %&#125; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" href=\"&#123;% url 'board:list' %&#125;?page=&#123;&#123;page&#125;&#125;\"&gt;&#123;&#123;page&#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/nav&gt; &lt;!--// checkbox 적용 //--&gt; &lt;form action=\"\" method=\"get\" id=\"search_form\" class=\"\"&gt; &#123;%csrf_token%&#125; &lt;div class=\"form-row align-items-center justify-content-center\"&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"checkbox\" name=\"search_type\" id=\"inlineCheckbox1\" value=\"author\"&gt; &lt;label class=\"form-check-label\" for=\"inlineCheckbox1\"&gt;작성자&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"checkbox\" name=\"search_type\" id=\"inlineCheckbox2\" value=\"title\"&gt; &lt;label class=\"form-check-label\" for=\"inlineCheckbox2\"&gt;제목&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"checkbox\" name=\"search_type\" id=\"inlineCheckbox3\" value=\"text\"&gt; &lt;label class=\"form-check-label\" for=\"inlineCheckbox3\"&gt;본문&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--// search 기능 추가 //--&gt; &lt;div class=\"form-row align-items-center justify-content-center\"&gt; &lt;div class=\"col-sm-3 my-1\"&gt; &lt;input type=\"text\", class=\"form-control\" placeholder=\"Search Keyword\" name=\"search_key\"&gt; &lt;/div&gt; &lt;div class=\"col-auto my-1\"&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;Search&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; python shell로 검색을 연습해보자. 1$ python manage.py shell 123456789101112131415161718192021222324252627282930313233343536373839from board.models import *Document.objects.filter(pk=1)Document.objects.filter(pk=2)Document.objects.filter(pk=2, title='Image Test 2')Document.objects.filter(pk=2, title='Image Test 3')Document.objects.filter(title__startswith='Image')Document.objects.filter(title__endswith='12')Document.objects.filter(title__iexact='image')Document.objects.filter(title__iexact='ima')Document.objects.filter(title__istartswith='image')Document.objects.filter(title__icontains='ge')Document.objects.filter(title__icontains='es')Document.objects.filter(category__name='Cosmetic Question')Document.objects.filter(category__name__endswith='Question')from django.db.models import QQ(title__icontains='1')default_q = Q(title__icontains='1')second_q = Q(text__icontains='1')default_q | second_qDocument.objects.filter(default_q | second_q)","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.13 Django Study","slug":"190513-Django-Study","date":"2019-05-13T12:00:22.000Z","updated":"2019-05-13T12:06:49.659Z","comments":true,"path":"2019/05/13/190513-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/13/190513-Django-Study/","excerpt":"","text":"2019.05.13 Django Study[ Board project ] url이 있는 형태로 S3 버킷 만들기(media 파일용) board.[도메인 주소]로 버킷 이름을 설정한다. 퍼블릭 ACL 관리 체크 항목을 모두 해제한다. 버킷이 생성되면 속성 탭에서 정적 웹 사이트 호스팅을 활성화한다. AWS ROUTE53에서 레코드를 생성한다. pycharm project의 settings.py에 다음과 같이 추가한다. 12# settings.pyDEFAULT_FILE_STORAGE = 'config.asset_storage.MediaStorage' config/asset_storage.py를 생성하고 작성한다. 12345678from storages.backends.s3boto3 import S3Boto3Storageclass MediaStorage(S3Boto3Storage): location = '' # 오버라이드하는 방법을 항상 찾아보고 별도로 추가해보자. bucket_name = 'images.jinukk.me' custom_domain = 'images.jinukk.me' file_overwrite = False ‘board’ 앱을 만들고 모델 설계하기 ‘board’라는 이름의 앱을 생성한다. 1$ python manage.py startapp board settings.py에 앱을 등록한다. 1234567891011INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'storages', # board 앱 등록 'board',] models.py를 작성한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from django.db import models\"\"\"Category - slug, nameDocument - author, category, title, slug, text, image, created, updated\"\"\"# User 모델을 커스텀한 경우 불러다가 써야하기 때문에 사용from django.contrib.auth import get_user_modelfrom django.urls import reverse# class Board(models.Model): # Board 모델을 만들어서 Category나 Document에 참조하여 사용하는 방법도 있다.# passclass Category(models.Model): # CharField vs TextField의 차이 = 글자 수 제한 name = models.CharField(max_length=20) # DB에는 index라는 키 값이 걸려있다. # 대량의 데이터를 입력, 수정, 삭제, 검색 등을 잘 수행하기 위해 설계한 것이 DB # -&gt; file 형태 대신 DB를 쓰는 이유 # 미리 검색과 정렬에 적합하도록 설계하는 것이 index # allow_unicode = 한글 처리 가능 slug = models.SlugField(max_length=30, db_index=True, unique=True, allow_unicode=True) description = models.CharField(max_length=200, blank=True) # 검색 엔진에게 제공해주는 것이 meta_description meta_description = models.CharField(max_length=200, blank=True) class Meta: # DB에 기본적으로 설정될 정렬값 ordering = ['slug'] def __str__(self): return self.nameclass Document(models.Model): category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True, blank=True, related_name='documents') author = models.ForeignKey(get_user_model(), on_delete=models.CASCADE, related_name='documents') title = models.CharField(max_length=100) slug = models.SlugField(max_length=120, db_index=True, unique=True, allow_unicode=True) text = models.TextField() # upload_to 동적으로 경로 설정 가능 image = models.ImageField(upload_to='board_images/%Y/%m/%d') created = models.DateTimeField(auto_now_add=True) updated = models.DateTimeField(auto_now=True) def __str__(self): return self.title def get_absolute_url(self): return reverse('board:detail', args=[self.id])# 작성이 끝나면 makemigrantions와 migrate를 한다.# AWS DB에 저장되지 않는다면 ip가 변경된 것일 수도 있다.# AWS RDS에서 해당 데이터베이스의 인바운드를 확인한다. views.py를 작성한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from django.shortcuts import render, get_object_or_404, redirect# QuerySet은 모델의 디폴트 매니저를 통해 실행한다.from .models import Documentdef document_list(request): # QuerySet # 1. 객체를 선택 # 2. 객체 생성 # 3. 객체 필터링 # 4. 객체 삭제 # Models.objects -&gt; 매니저 -&gt; 도와주는 객체 # 1. 모델의 전체 데이터 불러오기 documents = Document.objects.all() return render(request, 'board/document_list.html',&#123;'object_list':documents&#125;)from .forms import DocumentFormfrom django.contrib.auth.decorators import login_requiredfrom django.urls import reverse@login_requireddef document_create(request): # Document.objects.create() - 실행과 동시에 DB에 삽입을 한다. # 분기 - post, get if request.method == \"POST\": # 처리 # request.POST : 폼에서 입력한 텍스트 데이터가 넘어온다. # request.FILES : 파일 form = DocumentForm(request.POST, request.FILES) form.instance.author_id = request.user.id if form.is_valid(): document = form.save() return redirect(document) else: # 입력 창 form = DocumentForm() return render(request, 'board/document_create.html', &#123;'form':form&#125;)def document_update(request, document_id): # 객체를 불러와서, 데이터를 수정 if request.method == \"POST\": document = Document.objects.get(pk=document_id) # 모델폼을 사용할 때 instance를 넘겨주면, 해당 인스턴스 값으로 초기화가 되고 # 만약 pk가 있는 instance라면 update를 수행한다. # request.POST와 instance가 같이 전달되면, POST 데이터가 우선순위가 높다. form = DocumentForm(request.POST, request.FILES, instance=document) # instance가 매개변수로 있어야 create가 아닌 update로 인식한다. if form.is_valid(): document = form.save() return redirect(document) else: document = Document.objects.get(pk=document_id) # modelform init with instance(model object) form = DocumentForm(instance=document) # instance 매개변수 사용 return render(request, 'board/document_update.html',&#123;'form':form&#125;)def document_detail(request, document_id): document = Document.objects.get(pk=document_id) return render(request, 'board/document_detail.html', &#123;'object':document&#125;)def document_delete(request, document_id): # 객체를 불러와서 delete만 호출 return render(request, 'board/document_delete.html',&#123;'object':document&#125;) admin.py를 작성한다. 12345678910111213from django.contrib import adminfrom .models import Category,Documentclass CategoryOption(admin.ModelAdmin): list_display = ['id', 'name', 'slug'] prepopulated_fields = &#123;'slug':('name',)&#125;class DocumentOption(admin.ModelAdmin): list_display = ['id', 'author', 'title', 'slug', 'created', 'updated'] prepopulated_fields = &#123;'slug':('title',)&#125;admin.site.register(Category, CategoryOption)admin.site.register(Document, DocumentOption) config/urls.py를 작성한다. 1234567from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('site_config/', admin.site.urls), path('', include('board.urls')),] board/urls.py를 생성하고 작성한다. 1234567891011121314from django.urls import pathfrom django.contrib.auth.views import LoginView, LogoutViewfrom .views import document_list, document_create, document_update, document_delete, document_detailapp_name = 'board'urlpatterns = [ path('delete/&lt;int:document_id&gt;', document_delete, name='delete'), path('update/&lt;int:document_id&gt;', document_update, name='update'), path('create/', document_create, name='create'), path('detail/&lt;int:document_id&gt;/',document_detail, name='detail'), path('', document_list, name='list'),] templates 파일을 생성하여 작성한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;!--//board_project/layout/base.htmlsettings.py의 TEPLATES에서 DIRS를 수정하는 것을 잊지 말자. //--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" crossorigin=\"anonymous\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt;&#123;% block content %&#125;&#123;% endblock %&#125;&lt;/div&gt;&lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\" integrity=\"sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\" integrity=\"sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--//board/templates/board/document_list.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Photo List&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &#123;% for object in object_list %&#125; &#123;&#123;object.title&#125;&#125; &#123;&#123;object.text&#125;&#125; &#123;&#123;object.image.url&#125;&#125; &#123;&#123;object.author.username&#125;&#125;&lt;br&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&lt;!--//board/templates/board/document_detail.html//--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Photo Detail&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &#123;&#123;object.title&#125;&#125; &#123;&#123;object.text&#125;&#125; &#123;&#123;object.image.url&#125;&#125; &#123;&#123;object.author.username&#125;&#125;&lt;br&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&lt;!--//board/templates/board/document_create.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Board Create&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &lt;!--// 파일을 보내는 경우 enctype를 추가해야 한다. //--&gt; &lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &#123;% csrf_token %&#125; &lt;table&gt; &#123;&#123;form.as_table&#125;&#125; &lt;/table&gt; &lt;input type=\"submit\" value=\"Write\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&lt;!--//board/templates/board/document_update.html//--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Photo Update&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &#123;% csrf_token %&#125; &lt;table&gt; &#123;&#123;form.as_table&#125;&#125; &lt;/table&gt; &lt;input type=\"submit\" value=\"Update\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; 서버를 실행하여 이미지 파일을 올려보고 S3에 업로드되는지 확인하자. jQuery Practice html 파일을 생성한다. jQuery.com - Download - google CDN - jQuery/3.x snippet의 내용을 html 파일에 작성한다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; 내용&lt;/div&gt;&lt;a href=\"#\"&gt;내용 토글&lt;/a&gt;&lt;a href=\"#\" class=\"btn_menu\"&gt;MENU&lt;/a&gt;&lt;ul class=\"main_menu\" style=\"display:none;\"&gt; &lt;li&gt;메뉴1&lt;/li&gt; &lt;li&gt;메뉴2&lt;/li&gt; &lt;li&gt;메뉴3&lt;/li&gt; &lt;li&gt;메뉴4&lt;/li&gt;&lt;/ul&gt;&lt;textarea class=\"contents\"&gt;&lt;/textarea&gt;&lt;button class=\"btn_change\"&gt;내용바꾸기&lt;/button&gt;&lt;br&gt;&lt;form method=\"post\" action=\"\" id=\"register_form\"&gt; username : &lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt; 주소 : &lt;input type=\"text\" name=\"address\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"회원가입\"&gt;&lt;/form&gt;&lt;!--// jQuery : 액션에 대해서 리액션 액션 : 마우스 클릭, 롤오버, 롤아웃, 키 프레스, 키 다운, 키 업, 스크롤 리액션 : 어떤 요소를 보여준다. 감춘다. 변경한다. 어떤 버튼을 클릭하면 - 메뉴가 나타난다. 어떤 키를 누르면 - 페이지를 이동한다. 들여쓰기를 따로 하지 않아도 동작에는 문제가 없다.//--&gt;&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; // 기본 코드 : 읽자마자 실행 $(function() &#123; // 초기화 코드 &#125;); $(document).ready(function() &#123; // 문서 로드가 끝난 후에 실행 // 어떤 액션에 대해서 무슨 리액션을 할 것인지 연결 목록 // 액션 : a태그 클릭 - 어떤 요소 + 어떤 이벤트 // 리액션 : div태그 보이기/숨기기 - 어떤 함수 $('a').click(function() &#123; $('div').toggle(); // $('div').hide(); - 사라지게 하고 싶다면 // $('div').show(); - 보이게 하고 싶다면 &#125;); $('.btn_menu').click(function() &#123; //$('.main_menu').toggle(); if ($('.main_menu').is(\":visible\")) &#123; $('.main_menu').hide(1000); &#125; else &#123; $('.main_menu').show(1000); &#125; &#125;); $('.btn_change').click(function() &#123; // 요소.html() - 요소 안에 있는 html 코드 불러오기 // 요소.html(내용) - 요소 안에 있는 html 코드를 내용으로 교체한다. $('.contents').html(\"내용채우기 실습!\"); &#125;); $('#register_form').submit(function() &#123; // 위에서 validation을 하고 // val() - 비어있으면 값 읽기 // val(값) - 값이 있으면 값 할당 username = $('input[name=\"username\"]').val(); $('input[name=\"address\"]').val(username+\"@nate.com\"); // validation이 실패했다면 return false; 성공했다면 return true; return false; &#125;); &#125;); /* - 기명함수 function [함수이름]([매개변수])&#123; &#125; - 무기명함수, 일회용 function([매개변수])&#123; &#125; - 셀렉터 만드는 법 tag : tag이름 class : .class이름 id : #id */&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.10 Django Study","slug":"190510-Django-Study","date":"2019-05-10T12:00:09.000Z","updated":"2019-05-13T12:01:40.739Z","comments":true,"path":"2019/05/10/190510-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/10/190510-Django-Study/","excerpt":"","text":"2019.05.10 Django Study[ Dstargram project ]aws S3를 이용하여 이미지 파일을 저장하고해당 글을 삭제했으나, S3에는 이미지가 삭제되지 않음signal을 사용하여 S3에도 이미지가 삭제되도록 변경 signal ~하기 전에, ~한 후에 발생하는 일들을 말함 후속 조치를 하는 것 대표적인 signal 종류 pre_save : 저장하기 전 post_save : 저장한 후 pre_delete : 지우기 전 post_delete : 지운 후 어떤 시그널이 발생했을 때 반응할 것인지 생각해야 한다. 그 시그널이 발생한 것을 어떻게 알았는지 생각해야 한다. views.py에 추가1234567891011121314151617181920212223from django.db.models.signals import post_deletefrom django.dispatch import receiverimport boto3from django.conf import settings# @receiver(어떤 시그널이 발생했는가?, 누가 발생시켰는가?)# sender가 없다면 모든 경우에 post_delete가 발생# sender=Photo를 해줌으로써 Photo가 있는 경우에만 발생@receiver(post_delete, sender=Photo)def post_delete(sender, instance, **kwargs): session = boto3.Session( aws_access_key_id=settings.AWS_ACCESS_KEY_ID, aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY, region_name=settings.AWS_REGION ) # s3.Objects는 s3에 업로드된 파일 객체를 얻어오는 클래스 # arg1 = 버킷네임 # arg2 = 파일 경로 - Key s3 = session.resource('s3') # s3 권한 가져오기 image = s3.Object(settings.AWS_STORAGE_BUCKET_NAME, \"media/\"+str(instance.image)) image.delete() [ Board project ] DB는 AWS RDS - postgreSQL로 만들기(Postgre 10.x ver.) url이 있는 형태로 S3 버킷 만들기(static 파일용) 장고 프로젝트 생성 pycharm에서 board_project를 생성 후, 진행 123$ pip install djangodjango-admin startproject config . 관련 모듈을 미리 설치하자. 12345$ pip install psycopg2-binary$ pip install boto3$ pip install django-storages AWS RDS에 DB 만들기(Postgre 10.7 사용) 파라미터 그룹은 Postgre 10으로 새로 생성하여 사용한다. DB 세부 정보를 지정할 때만 DB 엔진 버전을 PostgreSQL 10.7을 선택한다. 나머지는 dstagram_project와 동일하게 진행했다. pycharm project의 settings.py를 수정한다. 123456789101112131415161718# config/settings.py# 기존 데이터베이스 항목을 수정DATABASES = &#123; 'default': &#123; # psycopg2 - binary 이용 'ENGINE': 'django.db.backends.postgresql_psycopg2', # Amazon 해당 DB의 구성 - DB 이름 'NAME': 'board', # Amazon database 생성 때 작성한 마스터 사용자 이름 'USER': 'amazon master user name', # Amazon database 생성 때 작성한 마스터 암호 'PASSWORD': 'amazon master password', # Amazon 해당 DB의 연결&amp;보안 - 엔드포인트 'HOST': 'wps10-board.cnuxbldx8kex.ap-northeast-2.rds.amazonaws.com', # # Amazon database 생성 때 포트 'POST': '5432', &#125;&#125; DB를 초기화하고 관리자 계정을 생성하여 확인한다. 12345$ python manage.py migrate$ python manage.py createsuperuser$ python manage.py runserver AWS S3에 static 파일용 버킷 만들기 board.[도메인 주소]로 버킷 이름을 설정한다. 퍼블릭 ACL 관리 체크 항목을 모두 해제한다. 버킷이 생성되면 속성 탭에서 정적 웹 사이트 호스팅을 활성화한다. AWS ROUTE53에서 레코드를 생성한다. pycharm project의 settings.py를 수정한다. 1234567891011121314AWS_ACCESS_KEY_ID = 'Amazon User Access Key ID 값' # 반드시 지우고 github에 올려야한다.AWS_SECRET_ACCESS_KEY = 'Amazon User Secret Key 값' # # 반드시 지우고 github에 올려야한다.AWS_REGION = 'ap-northeast-2'AWS_STORAGE_BUCKET_NAME = 'board.jinukk.me'AWS_S3_CUSTOM_DOMAIN = '%s' % AWS_STORAGE_BUCKET_NAMEAWS_S3_SECURE_URLS = False # https -&gt; httpAWS_S3_OBJECT_PARAMETERS = &#123;'CacheControl': 'max-age=86400',&#125;AWS_DEFAULT_ACL = 'public-read'AWS_LOCATION = 'static'STATIC_URL = 'https://%s/%s/' % (AWS_S3_CUSTOM_DOMAIN, AWS_LOCATION)STATICFILES_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage' 다음 명렁어를 통해 Amazon S3에 static 관련 파일을 옮긴다. 12$ python manage.py collectstatic# 명령어 입력 후, yes를 한번 더 입력한다. Amazon S3의 해당 버킷에 static 파일이 옮겨졌는지 확인하자.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.09 Django Study","slug":"190509-Django-Study","date":"2019-05-09T11:53:26.000Z","updated":"2019-05-13T12:06:18.492Z","comments":true,"path":"2019/05/09/190509-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/09/190509-Django-Study/","excerpt":"","text":"2019.05.09 Django StudyAmazon S3 사용하기 도메인을 이용한 버킷 사용하기 media 파일 적용하기 도메인을 구입한다. Amazon - S3에서 버킷을 생성한다. 버킷 이름은 media.[도메인 주소]로 한다. 권한 설정에서 다음과 같이 설정한다. 퍼블릭 ACL 관리 체크 항목을 모두 해제한다. 퍼블릭 버킷 정책 관리 체크 항목을 모두 해제한다. 시스템 권한 관리에서 ‘엑세스 권한 부여함’을 선택한다. 버킷이 생성되면 속성 탭에서 정적 웹 사이트 호스팅을 활성화한다. index.html, error.html은 그대로 입력하고 진행한다. Amazon - Route53에서 설정한다. 호스팅 영역 생성을 누르고 구입한 도메인 이름을 입력한다. 생성을 누른 후, NS 유형의 값을 확인한다. 도메인을 구입한 페이지로 이동하여 도메인 관리로 이동한다. 네임서버에 NS 유형의 값으로 수정한다. whois.kisa.or.kr의 WHOIS 조회를 통해 네임서버가 바뀌었는지 확인한다. 다시 Amazon - Route53에서 레코드 편집 생성을 누른다. 이름에는 media를 입력한다. 별칭을 ‘예’로 선택한다음 media.[도메인 주소] (s3-website)를 선택하고 생성한다. 해당 pycharm project에서 settings.py를 수정한다. 1234567891011AWS_STORAGE_BUCKET_NAME = '도메인 주소으로 만든 버킷 이름'AWS_S3_CUSTOM_DOMAIN = '%s' % AWS_STORAGE_BUCKET_NAMEAWS_S3_SECURE_URLS = False# https에서 http로 수정# http를 사용함STATIC_URL = 'http://%s/%s/' % (AWS_S3_CUSTOM_DOMAIN, AWS_LOCATION)STATICFILES_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'# media 관련DEFAULT_FILE_STORAGE = 'config.asset_storage.MediaStorage' config/asset_storage.py를 생성하고 작성한다. 1234567# config/asset_storage/pyfrom storages.backends.s3boto3 import S3Boto3Storageclass MediaStorage(S3Boto3Storage):location = 'media'file_overwrite = False config/urls.py를 수정한다. 12# 주석 처리# urlpatterns += static(settings.MEDIA_URL, document_root = settings.MEDIA_ROOT) 서버를 실행한 후, 이미지 파일을 업로드해본다. 이미지 출력이 잘 되는지 확인하자. Amazon - S3의 해당 버킷에 파일이 저장되어있는지 확인하자. Amazon - RDS 사용하기 Amazon Database 사용하기 Amazon - RDS에서 데이터베이스를 생성한다. 오른쪽 항목의 파라미터 그룹으로 이동하여 파라미터 그룹을 생성한다. 그룹 세부 정보에서 파라미터 그룹 패밀리는 postgres9.6을 선택하고 생성한다. 파라미터 그룹에서는 편집을 통해 파라미터를 수정할 수 있다. 1ex) encoding을 검색하고 편집을 누르면 해당 값인 UTF-8을 변경할 수있다. 데이터베이스 생성을 누른다. 엔진 선택 PostgreSQL 선택 RDS 프리 티어에 적용되는 옵션만 적용 DB 세부 정보 지정 DB 엔진 버전을 PostgreSQL 9.6.12-R1을 선택 DB 인스턴스 식별자를 작성 마스터 사용자 이름을 작성 마스터 암호를 작성 고급 설정 구성 네트워크 및 보안에서 퍼블릭 엑세스 가능성을 ‘예’로 체크 데이터베이스 옵션에서 DB 파라미터 그룹을 생성한 파라미터 그룹으로 선택 백업은 0일로 설정 삭제 방지 활성화 생성 데이터베이스 목록에서 해당 데이터베이스가 ‘사용 가능’이 될 때까지 기다린다. 해당 데이터베이스를 클릭한다. 보안 - VPC 보안 그룹 - 하단 인바운드에서 IP를 추가할 수 있다. 연결&amp;보안 - 엔드포인트와 구성 - DB 이름을 알아둔다. pycharm project의 settings.py를 수정한다. settings.py를 수정한다.123456789101112131415161718# config/settings.py# 기존 데이터베이스 항목을 수정DATABASES = &#123; 'default': &#123; # psycopg2 - binary 이용 'ENGINE': 'django.db.backends.postgresql_psycopg2', # Amazon 해당 DB의 구성 - DB 이름 'NAME': 'dstagram', # Amazon database 생성 때 작성한 마스터 사용자 이름 'USER': 'amazon master user name', # Amazon database 생성 때 작성한 마스터 암호 'PASSWORD': 'amazon master password', # Amazon 해당 DB의 연결&amp;보안 - 엔드포인트 'HOST': 'wps10-dstagram.cnuxbldx8kex.ap-northeast-2.rds.amazonaws.com', # # Amazon database 생성 때 포트 'POST': '5432', &#125;&#125; pycharm project의 DB를 초기화한다. 1$ python manage.py migrate 관리자 계정을 생성하고 서버를 실행하여 확인한다. 123$ python manage.py createsuperuser$ python manage.py runserver","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.08 Django Study","slug":"190508-Django-Study","date":"2019-05-08T10:38:31.000Z","updated":"2019-05-09T11:55:03.266Z","comments":true,"path":"2019/05/08/190508-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/08/190508-Django-Study/","excerpt":"","text":"2019.05.08 Django StudyIP LAN과 WAN LAN = Local WAN = Wide LAN이 여러개 묶여서 WAN이 된다. WAN이 여러개 묶여서 더 큰 WAN이 된다. 인터넷도 WAN에 한 일종 일반적으로 Server는 데이터를 내어주는 쪽이고 client는 데이터를 받는 쪽이다. DNS Domain Name Service 1IP &lt;--DNS--&gt; Domain DNS는 하나만 두지 않는다. 서버의 이상 발생으로 인해 여러개를 둔다.(1, 2, 3, 4차 등등)12345네이버에 접속하는 과정1. naver.com 주소를 입력하게 되면2. hosts 파일을 검색하게 되고3. DNS 검색을 한 뒤,4. naver.com에 접속하게 된다. 도메인 구성 123456ex) https://search.naver.com/search.naver?sm=top_hty&amp;fbm=1&amp;ie=utf8&amp;query=%EC%98%81%ED%99%94https - 스키마, 프로토콜search.naver.com - 도메인/search.naver - Path?sm=top_hty&amp;fbm=1&amp;ie=utf8&amp;query=%EC%98%81%ED%99%94 - Query String http와 https http Hypertext(문서끼리 링크로 연결되어 있는 것) Transfer Protocol https 공개키 암호화 공개키 = 암호화 개인키 = 복호화 웹 브라우저가 공개키를 받아서 암호화를 한다. 회원가입, 결제 등 정보 입력은 모두 https server와 client 데이터 처리 과정 123CDN --- LB --- EC2 --- DB | --- S3 CDN 사용자와 가까운 위치에서 요청에 응답 cache 개념 LB(Load Balancer) 여러대의 서버가 적절히 분산 처리할 수 있도록 해결해주는 서비스 분산 처리하기 이전에 인증서(https)를 설치 EC2와는 http로 통신 EC2 server web server cache DB Database DB cache 확장 방법 Master와 Slave Sharding(샤딩) S3 파일을 저장하기 위한 스토리지 이미지와 같은 파일 저장 서버의 동시접속자가 늘어날 경우 Upscaling 서버 컴퓨터의 샤양을 높이는 것 서버를 사용하고 있는 입장에서는 하기 힘들다. 처음 서버 컴퓨터를 만들 때 사용하는 방법 Outscaling 서버 컴퓨터의 수를 늘리는 것 서버를 사용하고 있는 입장에서 사용하는 방법 멀티 리전 물리적 거리가 존재하기 때문에 다른 나라 간에는 속도가 느리다. 따라서 해당 위치에 서버를 따로 구축 AWS Amazon S3 사용하기 dstagram의 이미지 파일을 로컬이 아닌 클라우드 스토리지에 저장하기 위해 사용 AWS Amazon에 가입한다. AWS - IAM에서 사용자를 추가한다. ‘AmazonS3FullAccess’ 권한을 추가한다. Access key와 Secret key를 확인한다. 해당 페이지를 끄면 다시 볼 수 없으므로 csv로 저장해둔다. AWS- S3에서 버킷을 만든다. 버킷 이름을 작성하고, 리전은 ‘아시아 태평양(서울)’을 선택한다. 권한 설정에서 퍼블릭 ACL 관리 체크 항목을 모두 해제한다. dstagra_project에서 다음 모듈을 설치한다. 12345# boto3 : Amazon S3를 사용할 수 있게 하는 모듈$ pip install boto3# 장고 프로젝트에서 특정 storage를 사용하게 하는 모듈$ pip install django-storages dstagram_project에서 settings.py를 수정한다. 12345678910111213141516171819202122232425262728293031323334# dstagram_project# settings.py# 'storages' 추가INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'accounts', 'photo', 'disqus', 'django.contrib.sites', 'storages',]AWS_ACCESS_KEY_ID = 'Amazon User Access Key ID 값'AWS_SECRET_ACCESS_KEY = 'Amazon User Secret Key 값'AWS_REGION = 'ap-northeast-2'AWS_STORAGE_BUCKET_NAME = 'S3에서 만든 버킷 이름'AWS_S3_CUSTOM_DOMAIN = '%s.s3.%s.amazonaws.com' % (AWS_STORAGE_BUCKET_NAME,AWS_REGION)AWS_S3_OBJECT_PARAMETERS = &#123; 'CacheControl': 'max-age=86400',&#125;AWS_DEFAULT_ACL = 'public-read'AWS_LOCATION = 'static'STATIC_URL = 'http://%s/%s/' % (AWS_S3_CUSTOM_DOMAIN, AWS_LOCATION)STATICFILES_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'# STATIC_URL = '/static/'# STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles') 다음 명렁어를 통해 Amazon S3에 static 관련 파일을 옮긴다. 12$ python manage.py collectstatic# 명령어 입력 후, yes를 한번 더 입력한다. Amazon S3의 해당 버킷에 static 파일이 옮겨졌는지 확인한다. 서버를 실행하고 웹페이지에 static 관련 이미지가 정상적으로 출력되는지 확인한다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.07 Django Study","slug":"190507-Django-Study","date":"2019-05-07T07:59:41.000Z","updated":"2019-05-07T08:01:33.767Z","comments":true,"path":"2019/05/07/190507-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/07/190507-Django-Study/","excerpt":"","text":"[ Dstargram project ] 회원가입(Sign Up) 만들기 accounts/views.py 추가 작성 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# accounts/views.py# 기존에 입력받는 뷰 - CreateView 상속 받아서# 상속받아서 만들면 커스텀이 힘들다.# 회원가입 -&gt; User 모델에 값을 입력받는다.-&gt; CreateView# 회원가입시 모델 필드 외에 추가 입력이 필요하다.# 커스텀 뷰를 하려면 함수형 뷰가 적절하겠다.from .forms import SignUpFormdef signup(request): # 함수형 뷰에서는 매개변수 request가 꼭 있어야 한다. # Class Based View였다면 dispatch -&gt; get, post if request.method == \"POST\": # Todo : 입력 받은 내용을 이용해서 회원 객체 생성 # 입력받은 내용 확인하기 # 모델 폼을 이용해서 코드를 간결하게 바꾼다. # validation - 아이디가 중복되는지, 아이디가 한글은 아닌지 signup_form = SignUpForm(request.POST) # 폼에 내용이 채워져 있는 형태로 출력됨 # form validation이 진행되지 않은 채로 저장하게 되기 때문에... if signup_form.is_valid(): # 1. 저장하고 인스턴스 생성 user_instance = signup_form.save(commit=False) # 해당 입력받은 정보를 가지고 인스턴스를 만들어줌 # commit=False 옵션을 통해 데이터베이스에는 저장이 안되도록 함 # 2. 패스워드 암호화 -&gt; 저장 # 폼이 가지고 있는 cleaned_data는 무엇인가? : 유효한 문자만 남긴 상태로 처리 과정을 거친 데이터 # request.POST.get('password') &lt;- 이런 방법으로 받지 않는다. user_instance.set_password(signup_form.cleaned_data['password']) user_instance.save() return render(request, 'accounts/signup_complete.html', &#123;'username':user_instance.username&#125;) # username을 던져줌. 'username'이 html에서 쓰일 이름/ 뒤에 user_instance.username이 html로 넘기는 값 # username = request.POST.get('username') # password = request.POST.get('password') # first_name = request.POST.get('first_name') # last_name = request.POST.get('last_name') # email = request.POST.get('email') # print(username, password, first_name, last_name, email) # # 회원 객체 생성하기 # user = User() # user.username = username # # user.password = password # set_password()를 쓰지 않고 저장하면 암호화되지 않은채 저장된다. # user.set_password(password) # 비밀번호를 비밀번호화 시켜주는 메서드 # user.first_name = first_name # user.last_name = last_name # user.email = email # user.save() else: # form 객체를 만들어서 전달 # form에는 username, password만 입력 받으면 된다. signup_form = SignUpForm() # 1. 템플릿 불러오기 # 2. 템플릿 렌더링하기 # 3. HTTP Response하기 return render(request, 'accounts/signup.html', &#123;'form':signup_form&#125;) # 변수값 전달 방법 accounts/forms.py 생성 및 작성 1234567891011121314151617181920212223242526272829303132# accounts/forms.py# 모델 폼을 만드려면 2가지 필요하다.# 제네릭 뷰: 제네릭 뷰, 모델# 모델 폼 : 모델, 폼from django.contrib.auth.models import Userfrom django import formsclass SignUpForm(forms.ModelForm): password = forms.CharField(label='Password', widget=forms.PasswordInput) # 추가 필드 password2 = forms.CharField(label='Repeat Password', widget=forms.PasswordInput) class Meta: model = User # fields에는 해당 모델에 대해 입력받을 필드들을 나열한다. # + 추가 필드도 포함될 수 있다. -&gt; 필드 목록과 추가 필드가 겹치면 오버라이드(추가 필드의 우선순위가 높다.) # fields에 써준 순서대로 출력한다. fields = ['username','password','password2','first_name','last_name','email'] # 입력받을 필드명을 입력 # fields = '__all__' # 전체 다 부르고 싶을 경우 # Todo : 필드의 기본값, Placeholder 설정법, css Class 설정법법, validator 설정법법, help text 설정 # Todo : 커스텀 필드 만드는 법 # 비밀번호가 일치하지 않을 경우 def clean_password2(self): cd = self.cleaned_data if cd['password'] != cd['password2']: raise forms.ValidationError('비밀번호가 일치하지 않습니다.') # 항상 해당 필드의 값을 리턴한다. return cd['password2'] accounts/urls.py 추가 작성 1234567891011121314151617181920# accounts/urls.pyfrom django.urls import pathfrom django.contrib.auth.views import LoginView, LogoutView# 함수형 뷰 signup 추가from .views import UserList, FollowerList, FollowingList, FollowButton, signupapp_name = 'accounts'urlpatterns = [ path('user/list/', UserList.as_view(), name='user_list'), path('follow/&lt;int:user_id&gt;/', FollowButton.as_view(), name='follow_button'), path('follower/list/', FollowerList.as_view(), name='follower_list'), path('following/list/', FollowingList.as_view(), name='following_list'), path('singin/', LoginView.as_view(template_name='accounts/signin.html'), name='signin'), path('signout/', LogoutView.as_view(template_name='accounts/signout.html'), name='signout'), # signup 경로 추가 path('signup/', signup, name='signup'), # 함수형 뷰는 이름만 쓴다.] templates 수정 및 작성 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--// base.html //--&gt;&lt;li class=\"nav-item\"&gt; &lt;!--// signup에 대한 경로 추가 //--&gt; &lt;a class=\"nav-link\" href=\"&#123;% url 'accounts:signup' %&#125;\"&gt;Sign-up&lt;/a&gt; &lt;/li&gt;&lt;!--// signup.html //--&gt;&lt;!--// 회원가입 페이지 //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Sign Up&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;div class=\"alert alert-info\"&gt;Please enter your account information&lt;/div&gt; &#123;% csrf_token %&#125; &#123;&#123;form.as_p&#125;&#125; &lt;input type=\"submit\" value=\"Sign Up\" class=\"btn btn-outline-info\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&lt;!--// signup_complete //--&gt;&lt;!--// 회원가입 완료 페이지 //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;SignUp Complete&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &lt;div class=\"alert alert-success\"&gt;&#123;&#123;username&#125;&#125; suceessfully signed up&lt;/div&gt; &lt;a href=\"&#123;% url 'accounts:signin' %&#125;\" class=\"btn btn-outline-info\"&gt;Move to Sign in&lt;/a&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; heroku를 이용한 배포 heroku 회원가입 heroku.com 접속 heroku CLI 설치 1$ sudo snap install --classic heroku 추가 모듈 설치 1234567891011# 데이터베이스 관련 옵션을 변수로 쉽게 접근할 수 있게 해주는 유틸리티$ pip install dj-database-url# wsgi용 미들웨어 - 웹서버와 장고 사이에 다리$ pip install gunicorn# static 파일 서빙용 미들웨어$ pip install whitenoise# postgreSQL용 드라이버$ pip install psycopg2-binary 의존성 리스트 생성 1$ pip freeze &gt; requirements.txt heroku 로그인 1234$ heroku login# 아무 키나 누르고 heroku 웹사이트로 이동해서 로그인하면 된다.&gt;&gt; heroku: Press any key to open up the browser to login or q to exit: 모듈 설정 - settings.py 12345678910111213141516171819202122# settings.pyDEBUG = False # True에서 False로 수정ALLOWED_HOSTS = ['*']# whitenoise 항목 추가MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'whitenoise.middleware.WhiteNoiseMiddleware',]# dj_database_url 항목 추가import dj_database_urlDATABASES['default'].update(dj_database_url.config(conn_max_age=500))# static root 추가STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles') 파일 생성 및 추가 프로젝트 최상단에서 만들기 Procfile(확장자 없음) 생성 1web: gunicorn config.wsgi runtime.txt 생성 1python-3.7.0 .gitignore(확장자 없음) 생성 12345*pyc*~/venv__pycache__db.sqlite3 git 설정 12345$ git init$ git add -A .$ git commit -m \"message\" heroku app 만들기 1$ heroku create [app_name] 업로드 1$ git push heroku master DB 초기화 1$ heroku run python manage.py migrate 관리자 계정 생성 1$ heroku run python manage.py createsuperuser heroku 웹사이트로 이동하여 생성한 앱 이름을 클릭 후, Open app을 누른다. 웹사이트가 잘 실행되는지 확인한다. 관리자 사이트도 잘 실행되는지 확인한다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.03 Django Study","slug":"190503-Django-Study","date":"2019-05-03T12:40:20.000Z","updated":"2019-05-03T12:41:31.335Z","comments":true,"path":"2019/05/03/190503-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/03/190503-Django-Study/","excerpt":"","text":"[ Dstargram project ] 저장한 페이지 목록 불러오기 models.py 수정 12345678class Photo(models.Model):# save라는 변수를 사용하면 안되는 이유# 예약어를 필드명을 사용하면 안된다.# save라는 변수를 사용해서 예약어와 충돌이나 오류가 났다.# favorite로 수정# makemigrations 및 migrate 적용favorite = models.ManyToManyField(User, related_name='save_post', blank=True) views.py 수정 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from django.urls import reversefrom urllib.parse import urlparse# 뷰를 실행하기 전에 특정한 로직을 추가로 실행하고 싶다면?# 로그인 여부, csrf 체크를 수행할 것인가?# 믹스인 : 클래스형 뷰# 데코레이터 : 함수형 뷰from django.contrib.auth.mixins import LoginRequiredMixin# LoginRequiredMixin : 로그인을 해야만 실행할 수 있게 해준다.# 로그인되지 않았다면 로그인할 수 있는 페이지로 갈 수 있게 수정class PhotoList(ListView):model = Phototemplate_name = 'photo/photo_list.html' # 파일 이름 전체를 지정def dispatch(self, request, *args, **kwargs): if not request.user.is_authenticated: return HttpResponseRedirect(reverse('accounts:signin')) else: return super(PhotoList, self).dispatch(request, *args, **kwargs)# models.py의 필드에서 설정한 related_name을 통해 쉽게 해당 리스트를 불러옴# get_queryset()을 통해 반환# 좋아요를 한 페이지 목록 불러오기class PhotoLikeList(LoginRequiredMixin, ListView): model = Photo template_name = 'photo/photo_list.html' def get_queryset(self): # 로그인한 유저가 좋아요를 클릭한 글을 찾아서 반환 user = self.request.user queryset = user.like_post.all() return queryset# 저장한 페이지 목록 불러오기class PhotoSaveList(LoginRequiredMixin, ListView): model = Photo template_name = 'photo/photo_list.html' def get_queryset(self): user = self.request.user queryset = user.save_post.all() return queryset# 로그인한 유저가 작성한 페이지 목록 불러오기class PhotoMyPageList(LoginRequiredMixin, ListView): Model = Photo template_name = 'photo/photo_list.html' def get_queryset(self): user = self.request.user queryset = user.photos.all() return queryset# 좋아요와 저장을 하는 버튼은 리스트 페이지와 디테일 페이지에서 모두 가능하다.# 좋아요와 저장을 눌러도 해당 페이지에서 계속 머물러야 하기 때문에 경로 부분을 수정한다.class PhotoLike(View):def get(self, request, *args, **kwargs): if not request.user.is_authenticated: return HttpResponseForbidden() else: if 'photo_id' in kwargs: photo_id = kwargs['photo_id'] photo = Photo.objects.get(pk=photo_id) user = request.user if user not in photo.like.all(): photo.like.add(user) else: photo.like.remove(user) # 수정한 부분 # 도메인 주소 필요없이 경로만 필요하다. referer_url = request.META.get('HTTP_REFERER') path = urlparse(referer_url).path return HttpResponseRedirect(path)class PhotoSave(View): def get(self, request, *args, **kwargs): if not request.user.is_authenticated: return HttpResponseForbidden() else: if 'photo_id' in kwargs: photo_id = kwargs['photo_id'] photo = Photo.objects.get(pk=photo_id) user = request.user if user not in photo.favorite.all(): photo.favorite.add(user) else: photo.favorite.remove(user) # 수정한 부분 referer_url = request.META.get('HTTP_REFERER') path = urlparse(referer_url).path return HttpResponseRedirect(path) settings.py 수정 123# 로그인 페이지로 이동할 수 있도록 경로 지정from django.urls import reverse_lazyLOGIN_URL = reverse_lazy('accounts:signin') photo/urls.py 수정 123456789101112131415161718192021from django.urls import path# 좋아요와 저장한 페이지 목록을 가져오기 위해 모듈 추가from .views import PhotoList, PhotoCreate, PhotoUpdate, PhotoDelete, PhotoDetail, \\ PhotoLike, PhotoLikeList, PhotoSave, PhotoSaveList, PhotoMyPageListapp_name = 'photo'# 경로 추가urlpatterns = [ path('like/&lt;int:photo_id&gt;/', PhotoLike.as_view(), name='like'), path('save/&lt;int:photo_id&gt;/', PhotoSave.as_view(), name='save'), path('like/', PhotoLikeList.as_view(), name='like_list'), path('save/', PhotoSaveList.as_view(), name='save_list'), path('mypage/', PhotoMyPageList.as_view(), name='mypage_list'), path('', PhotoList.as_view(), name = 'index'), path('create/', PhotoCreate.as_view(), name = 'create'), path('update/&lt;int:pk&gt;', PhotoUpdate.as_view(), name = 'update'), path('delete/&lt;int:pk&gt;', PhotoDelete.as_view(), name = 'delete'), path('detail/&lt;int:pk&gt;', PhotoDetail.as_view(), name = 'detail'),] templates 수정 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!--// MyPage, Like, Saved 추가중요한건 로그인한 상태에서만 보이기 위해 조건문 이용//--&gt; &#123;% if user.is_authenticated %&#125; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"&#123;% url 'photo:mypage_list' %&#125;\"&gt;MyPage&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"&#123;% url 'photo:like_list' %&#125;\"&gt;Like&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"&#123;% url 'photo:save_list' %&#125;\"&gt;Saved&lt;/a&gt; &#123;% else %&#125; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"&#123;% url 'accounts:signin' %&#125;\"&gt;Sign-in&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Sign-up&lt;/a&gt; &lt;/li&gt; &#123;% endif %&#125;&lt;!--// 스크립트 부분 주석 처리//--&gt;&lt;script type=\"text/javascript\"&gt;$(function() &#123;$('.btn-like').click(function(e) &#123; //e.preventDefault(); //$(this).toggleClass('active'); //$(this).blur();&#125;);$('.btn-save').click(function(e) &#123; //e.preventDefault(); //$(this).toggleClass('active'); //$(this).blur();&#125;);&#125;);&lt;/script&gt;&lt;!--// photo_list.html 좋아요가 눌린 수를 출력하기 위해 수정 //--&gt;&lt;a href=\"&#123;% url 'photo:like' object.id %&#125;\" class=\"float-left btn-like &#123;% if user in object.like.all %&#125; active &#123;% endif %&#125;\"&gt;Like&lt;/a&gt;&lt;!--// 좋아요가 눌린 수 출력 //--&gt;&#123;% if object.like.all.count %&#125;&lt;span class=\"float-left badge badge-danger\" style=\"margin-left:0.5em;\"&gt; &#123;&#123;object.like.all.count&#125;&#125;&lt;/span&gt;&#123;% endif %&#125;&lt;a href=\"&#123;% url 'photo:save' object.id %&#125;\" class=\"float-right btn-save &#123;% if user in object.favorite.all %&#125; active &#123;% endif %&#125;\"&gt;Save&lt;/a&gt;&lt;!--// photo_detail.html디테일 페이지도 리스트 페이지와 같으므로 같게 수정//--&gt;&lt;a href=\"&#123;% url 'photo:like' object.id %&#125;\" class=\"float-left btn-like &#123;% if user in object.like.all %&#125; active &#123;% endif %&#125;\"&gt;Like&lt;/a&gt;&lt;!--// 좋아요가 눌린 수 출력 //--&gt;&#123;% if object.like.all.count %&#125;&lt;span class=\"float-left badge badge-danger\" style=\"margin-left:0.5em;\"&gt; &#123;&#123;object.like.all.count&#125;&#125;&lt;/span&gt;&#123;% endif %&#125;&lt;a href=\"&#123;% url 'photo:save' object.id %&#125;\" class=\"float-right btn-save &#123;% if user in object.favorite.all %&#125; active &#123;% endif %&#125;\"&gt;Save&lt;/a&gt; 팔로우 기능 추가하기 models.py 작성 123456789101112131415from django.db import models# 중간 모델 착성from django.contrib.auth.models import Userclass Follow(models.Model): # 2개 필드 = ForeignKey # A가 B를 팔ㄹ우 하고 있다. # on_delete = 연관된 객체가 삭제된다면 어떻게 할 것인가? # related_name은 참조 객체의 입장에서 필드명, 속성값 me = models.ForeignKey(User, on_delete=models.CASCADE, related_name='following') # 내가 팔로잉한 사람들 you = models.ForeignKey(User, on_delete=models.CASCADE, related_name='follower') # 나를 팔로워한 사람들 def __Str__(self): return self.me.username + \" follow \" + self.you.username admin.py 작성 12345678910111213from django.contrib import admin# Register your models here.from .models import Follow# 옵션 추가# raw_id_fields 적용class FollowOption(admin.ModelAdmin): list_display = ['id','me','you'] raw_id_fields = ['me', 'you']admin.site.register(Follow, FollowOption) views.py 작성 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111from django.shortcuts import render# 유저 목록이 출력되는 뷰# + Follow라는 기능 추가# 중간 테이블을 직접 생성 - 모델# 유저 모델을 커스터마이징해야 한다. -&gt; 1. 커스터마이징 하는 방법을 배운다.# 확장하는 방법에 따라서# 1) 새로운 유저 모델을 만드는 방법 - 기존 유저 데이터를 유지할 수가 없다.# 2) 기존 모델을 확장하는 방법 - DB 다운 타임 alter table을 하면 table lock이 걸린다.# -&gt; 두 방법 다 운영하는 중간 입장에서는 위험한 방법이다.# 유저 모델(나)# 나를 팔로우한 사람 필드# 내가 팔로우한 사람 필드# 하지만 커스터마이징 할 수 없다면?# 새로운 모델을 추가하는 방법# 사진 모델# 사진을 좋아요한 사람 필드# 사진을 저장한 사람 필드\"\"\"팔로우 기능 구현1. 유저 목록 혹은 유저 프로필에서 팔로우 버튼1-1. 전체 유저 목록을 출력하는 뷰 - User 모델에 대한 ListView2. 팔로우 정보를 저장하는 뷰\"\"\"from django.views.generic.list import ListViewfrom django.views.generic.base import Viewfrom django.contrib.auth.models import Userfrom django.http import HttpResponseRedirectfrom django.http import HttpResponseForbiddenfrom django.contrib import messagesfrom django.urls import reversefrom urllib.parse import urlparsefrom django.shortcuts import redirectfrom django.contrib.auth.mixins import LoginRequiredMixinfrom .models import Followclass UserList(ListView): model = User template_name = 'accounts/user_list.html' def dispatch(self, request, *args, **kwargs): if not request.user.is_authenticated: return HttpResponseRedirect(reverse('accounts:signin')) else: return super(UserList, self).dispatch(request, *args, **kwargs)# get_queryset()을 통해 반환되는 object는 Follow object이다.# 그래서 user object의 정보를 가져오지 않아 화면에 출력이 되지 않았다.# 따라서 리스트에 user object를 받아 넘겼다.class FollowerList(LoginRequiredMixin, ListView): Model = User template_name = 'accounts/user_list.html' def get_queryset(self): user = self.request.user queryset = user.follower.all() user_list = [] for idx in queryset: user_list.append(idx.me) return user_list# 위와 같은 방법class FollowingList(LoginRequiredMixin, ListView): Model = User template_name = 'accounts/user_list.html' def get_queryset(self): user = self.request.user queryset = user.following.all() user_list = [] for idx in queryset: user_list.append(idx.you) return user_list# user_id를 받아와서 filter를 통해 로그인한 유저가 팔로우한 대상을 찾아냄# 있다면 언팔로우를, 있다면 팔로우를 함# 나 자신을 팔로우할 수 없게 조건문 적용class FollowButton(View): def get(self, request, *args, **kwargs): if not request.user.is_authenticated: return HttpResponseForbidden() else: if 'user_id' in kwargs: user_id = kwargs['user_id'] follow_user = User.objects.get(pk=user_id) login_user = request.user if not login_user == follow_user: follow_filter = Follow.objects.filter(me=login_user, you=follow_user) if follow_filter: follow_filter[0].delete() else: Follow(me=login_user, you=follow_user).save() referer_url = request.META.get('HTTP_REFERER') path = urlparse(referer_url).path return HttpResponseRedirect(path) accounts/urls.py 123456789101112131415161718from django.urls import pathfrom django.contrib.auth.views import LoginView, LogoutView# 모듈 추가from .views import UserList, FollowerList, FollowingList, FollowButtonapp_name = 'accounts'# 경로 추가# 팔로우 버튼은 user_id를 받음urlpatterns = [ path('user/list/', UserList.as_view(), name='user_list'), path('follow/&lt;int:user_id&gt;/', FollowButton.as_view(), name='follow_button'), path('follower/list/', FollowerList.as_view(), name='follower_list'), path('following/list/', FollowingList.as_view(), name='following_list'), path('singin/', LoginView.as_view(template_name='accounts/signin.html'), name='signin'), path('signout/', LogoutView.as_view(template_name='accounts/signout.html'), name='signout'),] templates 작성 12345678910111213141516171819202122232425262728293031323334353637&lt;!--// user_list.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Photo Create&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &lt;!--// 유저 목록을 테이블로 적용 //--&gt; &lt;table class=\"table\"&gt; &lt;thead&gt; &lt;tr class=\"table-light\"&gt; &lt;th scope=\"col\"&gt;username&lt;/th&gt; &lt;th scope=\"col\"&gt;name&lt;/th&gt; &lt;th scope=\"col\"&gt;follower&lt;/th&gt; &lt;th scope=\"col\"&gt;following&lt;/th&gt; &lt;th scope=\"col\"&gt;button&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for object in object_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;object.username&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;object.firstname&#125;&#125; &#123;&#123;object.lastname&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;object.follower.all.count&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;object.following.all.count&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=\"&#123;% url 'accounts:follow_button' object.id %&#125;\" class=\"btn btn-xs btn-sm btn-primary\"&gt;Follow&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; 커스텀 템플릿 필터 사용하여 버튼 이름 변경하기 팔로우일 때는 언팔로우 버튼이 표시되도록 한다. 팔로우가 아닐 때는 팔로우 버튼이 표시되도록 한다. 해당 앱 폴더에서 templatetags 폴더를 생성한다. templatetags 폴더 안에 init.py를 생성한다.(파이썬 패키지라는 것을 명시) 소스 파일을 생성해서 작성한다. 123456789101112131415# follow_filter.pyfrom django import templateregister = template.Library()# index라는 매개변수에 object를 받음# 현재 object의 유저를 팔로워한 유저들을 user__list로 반환@register.filterdef follow_filter(index): user_list = [] for idx in index.follower.all(): user_list.append(idx.me) return user_list templates 파일을 수정한다. 1234567891011121314151617181920&lt;!--//user_list.html작성한 모듈 로드 : follow_filter.py//--&gt;&#123;% load follow_filter %&#125;&lt;!--// 팔로워한 유저 목록안에 지금 로그인한 유저가 있다면 UnFollow 버튼을,그렇지 않다면 Follow 버튼으로 보이도록 조건문을 추가한다.//--&gt;&lt;td&gt;&lt;a href=\"&#123;% url 'accounts:follow_button' object.id %&#125;\" class=\"btn btn-xs btn-sm btn-primary\"&gt;&#123;% if user in object|follow_filter %&#125; Unfollow &#123;% else %&#125; Follow &#123;% endif %&#125;&lt;/a&gt;&lt;/td&gt;","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.02 Django Study","slug":"190502-Django-Study","date":"2019-05-02T11:38:23.000Z","updated":"2019-05-02T11:39:42.727Z","comments":true,"path":"2019/05/02/190502-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/02/190502-Django-Study/","excerpt":"","text":"[ Dstargram project ] 접근 권한 주기 해당 글을 올린 글쓴이가 아니라면 수정이나 삭제를 할 수 없도록 처리 views.py에서 dispatch() 적용 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from django.http import HttpResponseRedirectfrom django.contrib import messagesclass PhotoUpdate(UpdateView): model = Photo fields = ['text', 'image'] template_name = 'photo/photo_update.html' # success_url = '/' def dispatch(self, request, *args, **kwargs): object = self.get_object() if object.author !=request.user: # 삭제 페이지에서 권한이 없다! # 원래 디테일 페이지로 돌아가서 삭제에 실패했다! # 사용자가 선택할 수 없는 기능들은 눈에 안보이게 하는 것이 좋다. messages.warning(request, \"수할 권한이 없습니다.\") return HttpResponseRedirect(object.get_absolute_url()) else: super(PhotoUpdate, self).dispatch(request, *args, **kwargs)class PhotoDelete(DeleteView): model = Photo template_name = 'photo/photo_delete.html' success_url = '/' # Life Cycle - iOS, Android, Vue, React, Django, Rails # Framework는 라이프 사이클이 존재 : 어떤 순서로 구동이 되는가? # URLConf -&gt; View -&gt; Model 순으로 # 어떤 뷰를 구동할 때 그 안에서 동작하는 순서 # 사용자가 접속했을 때, get? post? 등을 결정하고 분기하는 부분 # 로직을 수행하고, 템플릿을 랜더링한다. def dispatch(self, request, *args, **kwargs): object = self.get_object() if object.author !=request.user: # 삭제 페이지에서 권한이 없다! # 원래 디테일 페이지로 돌아가서 삭제에 실패했다! # 사용자가 선택할 수 없는 기능들은 눈에 안보이게 하는 것이 좋다. messages.warning(request, \"삭제할 권한이 없습니다.\") return HttpResponseRedirect(object.get_absolute_url()) else: super(PhotoDelete, self).dispatch(request, *args, **kwargs) # get과 post는 세트 # get과 post는 로직을 수행하고, 템플릿을 렌더링한다. # def get(self, request, *args, **kwargs): # # def post(self, request, *args, **kwargs): # # def get_object(self, queryset=None): # 해당 쿼리셋을 이용해서 현재 페이지에 필요한 object를 인스턴스화 한다. # pass # def get_queryset(self): # 어떻게 데이를 가져올 것인가? # pass base.html 수정 1234567891011121314151617&lt;!--// 접근 권한이 없다는 메세지 위치 설정 및 출력 //--&gt;&lt;div class=\"container\"&gt;&#123;% if messages %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &#123;% for message in messages %&#125; &lt;div class=\"alert alert-danger\"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125;&#123;% block content %&#125;&#123;% endblock %&#125;&lt;/div&gt; photo_detail.html 수정 12345&lt;!--// 해당 글을 올린 사용자가 아니라면 버튼이 보지 않는다. //--&gt;&#123;% if user == object.author %&#125; &lt;a href=\"&#123;% url 'photo:update' object.id %&#125;\" class=\"card-link\"&gt;수정&lt;/a&gt; &lt;a href=\"&#123;% url 'photo:delete' object.id %&#125;\" class=\"card-link\"&gt;삭제&lt;/a&gt;&#123;% endif %&#125; disqus.com을 이용하여 ‘댓글 달기’ 앱 이용 disqus.com 접속 및 가입 후, shortname 지정 장고 프로젝트로 돌아와서 disqus 설치 1$ pip install disqus settings.py 수정 1234567891011121314151617181920# disqus 추가# disqus.contrib.sites 추가INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'accounts', 'photo', 'disqus', 'django.contrib.sites',]# django-disqus : 데이터베이스가 필요없음 -&gt; disqus.com에서 관리함# django.contrib.sites : 우리 프로젝트 사이트 정보 관리 -&gt; python manage.py migrate를 해준다.DISQUS_WEBSITE_SHORTNAME = 'koostargram' # disqus에서 정한 shortnameSITE_ID = 1 detail.html 수정 12345&#123;# load xxx 해당 태그 기능을 지금부터 사용하겠다. #&#125;&#123;% load disqus_tags %&#125;&lt;div class=\"card-body\"&gt; &#123;% disqus_show_comments %&#125;&lt;/div&gt; Instargram을 이용한 ‘좋아요’와 ‘저장’ 기능 구현 Instargram에서 이미지 파일 가져오기 background-image를 통해 이미지 저장 요소 검사를 통해 ‘좋아요’와 ‘저장’ 이미지 위치 및 크기 픽셀 파악 dstargram_project/static/images에 button_image.png로 저장 base.html에서 이미지를 불러오고 스타일 적용 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#123;% load static %&#125;&lt;!--// &lt;img src=\"&#123;% static 'images/button_image.png' %&#125;\"&gt; //--&gt;&lt;style&gt;.btn-like &#123;display:inline-block; /* html 요소의 영역 표시 속성 */width:24px; /* 너비 */height:24px; /* 높이 */background:url(&#123;% static 'images/button_image.png' %&#125;); /* 배경 이미지 */background-position:-231px -130px; /* 배경 이미지 포지션 */text-indent:-9999px; /* 영역 안에 있는 텍스트의 들여쓰기 */overflow:hidden; /* 영역 바같으로 밀려난 컨텐츠의 표시 여부 */border:none; /* 테두리 여부 */&#125;/*어떤 요소를 클릭했을 때, class를 더하거나 빼서 효과를 변경한다.*/.btn-like.active &#123;background-position:-231px -104px;&#125;.btn-save &#123;display:inline-block;/*inline : text 형태 컨텐츠가 있는 만큼 영역을 차지하는 형태, 한줄에 여러 요소가 있을 수 있다.block : 한 줄을 단독으로 차지하고, 크기는 지정할 수 있다.inline-block : text 형태로 한 줄에 여러 요소가 함께 있을 수 있지만, 크기도 지정할 수 있다.*/width:24px;height:24px;background:url(&#123;% static 'images/button_image.png' %&#125;);background-position:-208px -255px;text-indent:-9999px;overflow:hidden;border:none;&#125;.btn-save.active &#123;background-position:-130px -255px;&#125;&lt;/style&gt;&lt;!-- //&lt;div class=\"btn-like\"&gt;&lt;/div&gt;&lt;div class=\"btn-save\"&gt;&lt;/div&gt;//--&gt;&lt;!--// 자바 스크립트를 이용하여 버튼 변경 테스트&lt;script type=\"text/javascript\"&gt;$(function() &#123;$('.btn-like').click(function(e) &#123; //e.preventDefault(); //$(this).toggleClass('active'); //$(this).blur();&#125;);$('.btn-save').click(function(e) &#123; //e.preventDefault(); //$(this).toggleClass('active'); //$(this).blur();&#125;);&#125;);&lt;/script&gt;//--&gt; models.py 수정 1234# Photo class에 필드 추가like = models.ManyToManyField(User, related_name='like_post', blank=True)saved = models.ManyToManyField(User, related_name='save_post', blank=True)# makemigrations 및 migration 적용 views.py 수정 123456789101112131415161718192021222324252627282930313233343536373839404142from django.views.generic.base import Viewfrom django.http import HttpResponseForbiddenclass PhotoLike(View): def get(self, request, *args, **kwargs): # like를 할 정보가 있다면 진행, 없다면 증단 if not request.user.is_authenticated: return HttpResponseForbidden() else: # 1. 어떤 포스팅? # url : www.naver.com/blog/like/?photo_id=1 # request.GET.get('photo_id') # url : www.naver.com/blog/like/1/ # path('blog/like/&lt;int:photo_id&gt;') # kwargs['photo_id'] # 2. 누가? if 'photo_id' in kwargs: photo_id = kwargs['photo_id'] photo = Photo.objects.get(pk=photo_id) user = request.user if user not in photo.like.all(): photo.like.add(user) else: photo.like.remove(user) return HttpResponseRedirect('/')class PhotoSave(View): def get(self, request, *args, **kwargs): # like를 할 정보가 있다면 진행, 없다면 증단 if not request.user.is_authenticated: return HttpResponseForbidden() else: if 'photo_id' in kwargs: photo_id = kwargs['photo_id'] photo = Photo.objects.get(pk=photo_id) user = request.user if user not in photo.saved.all(): photo.saved.add(user) else: photo.saved.remove(user) return HttpResponseRedirect('/') urls.py 수정 1234567891011121314# 모듈에 PhotoLike, PhotoSave 추가from .views import PhotoList, PhotoCreate, PhotoUpdate, PhotoDelete, PhotoDetail, PhotoLike, PhotoSave# urlpatterns에 like, save 경로 추가urlpatterns = [path('like/&lt;int:photo_id&gt;/', PhotoLike.as_view(), name='like'),path('save/&lt;int:photo_id&gt;/', PhotoSave.as_view(), name='save'),path('saved/', PhotoSaved.as_view(), name='saved'),path('', PhotoList.as_view(), name = 'index'),path('create/', PhotoCreate.as_view(), name = 'create'),path('update/&lt;int:pk&gt;', PhotoUpdate.as_view(), name = 'update'),path('delete/&lt;int:pk&gt;', PhotoDelete.as_view(), name = 'delete'),path('detail/&lt;int:pk&gt;', PhotoDetail.as_view(), name = 'detail'),] list.html 수정 1234567&lt;ul class=\"list-group list-group-flush\"&gt; &lt;li class=\"list-group-item\"&gt; &lt;!--// 조건을 이용하여 이미지 변경 적용 //--&gt; &lt;a href=\"&#123;% url 'photo:like' object.id %&#125;\" class=\"float-left btn-like &#123;% if user in object.like.all %&#125; active &#123;% endif %&#125;\"&gt;Like&lt;/a&gt; &lt;a href=\"&#123;% url 'photo:save' object.id %&#125;\" class=\"float-right btn-save &#123;% if user in object.saved.all %&#125; active &#123;% endif %&#125;\"&gt;Save&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; detail.html 수정 123456&lt;ul class=\"list-group list-group-flush\"&gt; &lt;li class=\"list-group-item\"&gt; &lt;a href=\"&#123;% url 'photo:like' object.id %&#125;\" class=\"float-left btn-like &#123;% if user in object.like.all %&#125; active &#123;% endif %&#125;\"&gt;Like&lt;/a&gt; &lt;a href=\"&#123;% url 'photo:save' object.id %&#125;\" class=\"float-right btn-save &#123;% if user in object.saved.all %&#125; active &#123;% endif %&#125;\"&gt;Save&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.05.01 Django Study","slug":"190501-Django-Study","date":"2019-05-01T07:48:49.000Z","updated":"2019-05-01T07:59:47.650Z","comments":true,"path":"2019/05/01/190501-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/05/01/190501-Django-Study/","excerpt":"","text":"[ Dstargram project ] 두 가지 앱을 만들어서 진행 accounts : 로그인, 로그아웃, 회원가입 관련 photo : 사진 업로드 관련 파이썬 프로젝트 생성 장고 설치 1$ pip install django 장고 프로젝트 생성 1$ django-admin startproject config . DB 초기화 1$ python manage.py migrate 관리자 계정 생성 1234$ python manage.py createsuperuser# 비밀번호 변경$ python manage.py changepassword [계정명] 앱 생성 12345# 로그인, 로그아웃, 회원가입 관련$ python manage.py startapp accounts# 사진 업로드 관련$ python manage.py startapp photo config/settings.py에 앱 추가 12345678910INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'accounts', 'photo',] photo 앱 설계 models.py 작성 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from django.db import models# 기본 모델\"\"\"작성자 : author본문글 : text사진 : image작성일 : created수정일 : updated+ tag, like--&gt; comment\"\"\"from django.contrib.auth.models import User# User 모델은 확장 가능# settings.AUTH_USER_MODELfrom django.contrib.auth import get_user_model# url pattern 이름을 가지고 주소를 만들어주는 함수from django.urls import reverseclass Photo(models.Model): # ForeignKey(연결되는 모델, 삭제 시 동작, 연관 이름) author = models.ForeignKey(User, on_delete=models.CASCADE, related_name='photos') # User 모델을 커스텀했을 시에 models.ForeignKey(get_user_model(),)를 쓰는 것이 좋다. # CASCADE : 연속해서 지운다. = 탈퇴하면 사진도 싹 지운다. # PROTECT : 사진을 다 지우지 않으면 탈퇴할 수 없다. = 탈퇴 프로세스에 사진을 우선 삭제하고 탈퇴 시킨다는 메시지를 띄움 # 특정값으로 셋팅하는 방법도 있음 # related_name으로 연관 데이터를 얻을 수 없다면 쿼리를 별도로 실행해야 한다, # 내 프로필 페이지에서 내가 올린 사진만 뜬다. -&gt; related_name을 이용하여 별도의 퀴리없이도 불러올 수 있다. text = models.TextField(blank=True) # 필수 필드가 아닐 수 있기 때문에 blank = True image = models.ImageField(upload_to='timeline_photo/%Y/%m/%d') # %Y = 2019로 표시 # %y = 19로 표시 # upload_to는 함수를 사용해서 폴더를 동적으로 설정할 수 있다. # pip install pillow 설치 created = models.DateTimeField(auto_now_add= True) # 생성 당시에 날짜를 저장 updated = models.DateTimeField(auto_now=True) # 다시 생성할 때마다 날짜 갱신 class Meta: ordering = ['-created'] # 해당 필드값을 내림차순 def get_absolute_url(self): # detail/&lt;int:pk&gt;/ # &lt;int:pk&gt;에 들어갈 값을 아래와 같이 args=[self.id] 방법으로 넣어준다. return reverse('photo:detail', args=[self.id])# models.py를 수정했다면 makemigrations와 migrate를 진행한다. views.py 작성 models.py에서 저장한 이미지를 관리하는 폴더 바꾸기 settings.py에 추가1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# settings.pyMEDIA_URL = '/res/' # 가상 URLMEDIA_ROOT = os.path.join(BASE_DIR, 'media')# 루트 폴더를 만들어줌으로써 앞으로 사진을 찾을 때 MEDIA_ROOT 경로 아래에서만 찾게 할 수 있다.# 이미지 저장 시 해당 이름을 가진 루트 폴더가 자동으로 생성된다.# views.pyfrom django.shortcuts import renderfrom .models import Photofrom django.views.generic.list import ListViewfrom django.views.generic.edit import CreateView,UpdateView,DeleteViewfrom django.views.generic.detail import DetailView# Create your views here.# CRUDL - 이미지를 띄우는 방법# 제네릭 뷰 활용# 쿼리셋 변경하기, context_data 추가하기, 권한 체크# 함수형 뷰 &lt;-&gt; 클래스형 뷰class PhotoList(ListView): model = Photo template_name = 'photo/photo_list.html' # 파일 이름 전체를 지정from django.shortcuts import redirectclass PhotoCreate(CreateView): model = Photo fields = ['text', 'image'] template_name = 'photo/photo_create.html' # template_name_suffix = '_create' # 뒤에 붙는 이름만 바꿈 success_url = '/' def form_valid(self, form): # 입력된 자료가 올바른지 체크 form.instance.author_id = self.request.user.id if form.is_valid(): # 올바르다면 # form : 모델 폼 # form.instance는 model의 객체 form.instance.save() return redirect('/') else: # 올바르지 않다면 return self.render_to_response(&#123;'form':form&#125;)class PhotoUpdate(UpdateView): model = Photo fields = ['text', 'image'] template_name = 'photo/photo_update.html' # success_url를 쓰지 않고, models.py에 get_absolute_url() 이용 # success_url을 지정해주면 get_absolute_url()보다 먼저 적용된다.class PhotoDelete(DeleteView): model = Photo template_name = 'photo/photo_delete.html' success_url = '/'class PhotoDetail(DetailView): model = Photo template_name = 'photo/photo_detail.html' photo/urls.py 작성 12345678910111213from django.urls import pathfrom .views import PhotoList, PhotoCreate, PhotoUpdate, PhotoDelete, PhotoDetailapp_name = 'photo'urlpatterns = [ path('', PhotoList.as_view(), name = 'index'), path('create/', PhotoCreate.as_view(), name = 'create'), path('update/&lt;int:pk&gt;', PhotoUpdate.as_view(), name = 'update'), path('delete/&lt;int:pk&gt;', PhotoDelete.as_view(), name = 'delete'), path('detail/&lt;int:pk&gt;', PhotoDetail.as_view(), name = 'detail'),] config/urls.py 작성 123456789101112131415161718192021from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ # 배포하는 프로젝트에서는 admin 주소의 이름을 바꿔서 사용하도록 하자. # admin 이름을 그대로 쓰게 되면 접근이 쉬워져서 주의가 필요하다. path('admin/', admin.site.urls), path('', include('photo.urls')), # photo 앱 관련 path('accounts/', include('accounts.urls')), # accounts 앱 관련]# 특정 리소스를 static 형태로 응답from django.conf.urls.static import static# 장고의 셋팅 값을 불러다 주는 역할from django.conf import settings# 개발 상태일 때만 사용 -&gt; Deploy, Live 일 때는 사용하지 않는다.# 1) 웹 서버가 해줘야 할 일# 2) 파일 서버를 별도로 셋urlpatterns += static(settings.MEDIA_URL, document_root = settings.MEDIA_ROOT) template 파일 작성 base.html를 작성하여 분기 사용 프로젝트 최상단에서 layout 폴더를 만들고 base.html 생성 및 작성 settings.py에서 TEPLATES의 ‘DIRS’ 수정123456789101112131415TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'layout')], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;, ] CRUDL 관련 html 작성 photo/templates/photo에 CRUDL html 생성 및 작성 bootstrap 적용123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207&lt;!--// dstargram_project/layout/base.html //--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; &lt;!--// CSS 적용 //--&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" crossorigin=\"anonymous\"&gt;&lt;/head&gt;&lt;body&gt;&lt;!--// nav bar 적용 //--&gt;&lt;nav class=\"navbar navbar-expand-lg navbar-light bg-light\"&gt;&lt;a class=\"navbar-brand\" href=\"&#123;% url 'photo:index' %&#125;#\"&gt;Dstargram&lt;/a&gt;&lt;button class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarNav\" aria-controls=\"navbarNav\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"&gt; &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt;&lt;/button&gt;&lt;div class=\"collapse navbar-collapse\" id=\"navbarNav\"&gt; &lt;ul class=\"navbar-nav\"&gt; &lt;li class=\"nav-item active\"&gt; &lt;a class=\"nav-link\" href=\"&#123;% url 'photo:index' %&#125;\"&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Tags&lt;/a&gt; &lt;/li&gt; &lt;!--// user가 로그인되어 있다면 업로드와 로그아웃을 할 수 있게 설정 //--&gt; &#123;% if user.is_authenticated %&#125; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"&#123;% url 'photo:create' %&#125;\"&gt;Upload&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"&#123;% url 'accounts:signout' %&#125;\"&gt;Sign-out&lt;/a&gt; &lt;/li&gt; &#123;% else %&#125; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"&#123;% url 'accounts:signin' %&#125;\"&gt;Sign-in&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Sign-up&lt;/a&gt; &lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt;&lt;/div&gt;&lt;/nav&gt;&lt;!--// grid system 적용 //--&gt;&lt;div class=\"container\"&gt;&#123;% block content %&#125;&#123;% endblock %&#125;&lt;/div&gt;&lt;!--// JS 적용 //--&gt;&lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\" integrity=\"sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\" integrity=\"sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--// photo/templates/photo/photo_list.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Photo List&#123;% endblock %&#125;&#123;% block content %&#125;&lt;!--// grid system 적용 //--&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &#123;% for object in object_list %&#125; &lt;!--// cards 적용 //--&gt; &lt;div class=\"card\" style=\"margin-top:2em;\"&gt; &lt;div class=\"card-header\"&gt; &#123;&#123;object.author.username&#125;&#125; &lt;/div&gt; &lt;img src=\"&#123;&#123;object.image.url&#125;&#125;\" class=\"card-img-top\"&gt; &#123;% if object.text %&#125; &lt;div class=\"card-body\"&gt; &lt;p class=\"card-text\"&gt;&#123;&#123;object.text&#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;ul class=\"list-group list-group-flush\"&gt; &lt;li class=\"list-group-item\"&gt;Like Save&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"card-body\"&gt; &lt;a href=\"&#123;&#123;object.get_absolute_url&#125;&#125;#\" class=\"card-link\"&gt;댓글 달기&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&lt;!--// photo/templates/photo/photo_create.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Photo Create&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &lt;!--// 파일(ex: image file)을 보내는 경우 enctype를 추가하여 인코딩 //--&gt; &lt;!--// form 적용 //--&gt; &lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;!--// alert 적용 //--&gt; &lt;div class=\"alert alert-info\"&gt;Please enter your photo information&lt;/div&gt; &#123;% csrf_token %&#125; &#123;&#123;form.as_p&#125;&#125; &lt;!--// button 적용 //--&gt; &lt;input type=\"submit\" value=\"Create\" class=\"btn btn-outline-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&lt;!--// photo/templates/photo/photo_update.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Photo Update&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &lt;!--// 현재 로그인 사용자가 다른 사용자 글을 수정할 수 없도록 조건 지정 //--&gt; &#123;% if user.id == object.author.id %&#125; &lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;div class=\"alert alert-info\"&gt;Please change your photo information&lt;/div&gt; &#123;% csrf_token %&#125; &#123;&#123;form.as_p&#125;&#125; &lt;input type=\"submit\" value=\"Update\" class=\"btn btn-outline-warning\"&gt; &lt;/form&gt; &#123;% else %&#125; &lt;div class=\"alert alert=primary\"&gt;You don't have access.&lt;/div&gt; &lt;a href=\"&#123;% url 'photo:index' %&#125;\" class=\"btn btn-outline-primary\"&gt;home&lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&lt;!--// photo/templates/photo/photo_delete.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Photo Delete&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &lt;!--// 현재 로그인 사용자가 다른 사용자 글을 삭제할 수 없도록 조건 지정 //--&gt; &#123;% if user.id == object.author.id %&#125; &lt;form action=\"\" method=\"post\"&gt; &lt;div class=\"alert alert-info\"&gt;Do you want to delete &#123;&#123;object&#125;&#125;?&lt;/div&gt; &#123;% csrf_token %&#125; &lt;input type=\"submit\" value=\"Upload\" class=\"btn btn-outline-danger\"&gt; &lt;/form&gt; &#123;% else %&#125; &lt;div class=\"alert alert=primary\"&gt;You don't have access.&lt;/div&gt; &lt;a href=\"&#123;% url 'photo:index' %&#125;\" class=\"btn btn-outline-primary\"&gt;home&lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&lt;!--// photo/templates/photo/photo_detail.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Photo Create&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &lt;!--// cards 적용//--&gt; &lt;div class=\"card\" style=\"margin-top:2em;\"&gt; &lt;div class=\"card-header\"&gt; &#123;&#123;object.author.username&#125;&#125; &lt;/div&gt; &lt;img src=\"&#123;&#123;object.image.url&#125;&#125;\" class=\"card-img-top\"&gt; &#123;% if object.text %&#125; &lt;div class=\"card-body\"&gt; &lt;p class=\"card-text\"&gt;&#123;&#123;object.text&#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;div class=\"card-body\"&gt; &lt;a href=\"&#123;% url 'photo:update' object.id %&#125;\" class=\"card-link\"&gt;수정&lt;/a&gt; &lt;a href=\"&#123;% url 'photo:delete' object.id %&#125;\" class=\"card-link\"&gt;삭제&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; accounts 앱 설계 urls.py 작성 1234567891011from django.urls import pathfrom django.contrib.auth.views import LoginView, LogoutView# 장고에 내장되어 있는 로그인, 로그아웃 기능 이용app_name = 'accounts'# views.py를 작성하지 않고도 적용하는 방법urlpatterns = [ path('singin/', LoginView.as_view(template_name='accounts/signin.html'), name='signin'), path('signout/', LogoutView.as_view(template_name='accounts/signout.html'), name='signout'),] template 파일 작성 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!--// accounts/templates/accounts/signin.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Sign In&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &lt;div class=\"alert alert=primary\"&gt;Please enter your login information&lt;/div&gt; &lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123;form.as_p&#125;&#125; &lt;input type=\"submit\" value=\"Signin\" class=\"btn btn-outline-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&lt;!--// accounts/templates/accounts/signout.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Sign Out&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-6\"&gt; &lt;!--// 로그아웃이 되면 메시지와 함께 로그인 페이지로 이동할 수 있도록 함 //--&gt; &lt;div class=\"alert alert=primary\"&gt;Your successfully sign out.&lt;/div&gt; &lt;a href=\"&#123;% url 'accounts:signin' %&#125;\" class=\"btn btn-outline-success\"&gt;Sign In&lt;/a&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; settings.py 수정 로그인이 완료되면 이동할 경로 지정하기 위해 추가1LOGIN_REDIRECT_URL = '/'","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.30 Django Study","slug":"190430-Django-Study","date":"2019-04-30T10:48:19.000Z","updated":"2019-04-30T10:49:37.501Z","comments":true,"path":"2019/04/30/190430-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/30/190430-Django-Study/","excerpt":"","text":"[ Bookmark project ] Bootstrap 적용 github 업로드 pythonanywhere.com을 이용한 배포 bootstrap 적용하기 base.html에 bootstrap 설치 CDN 스크립트로 설치(리소스 절감 효과, 최신버전 자동 유지, CDN을 사용하면 접속 속도 증가) 다운로드 설치(커스터마이징 가능, 도메인을 넘나들지 않아도 됨) base.html에 레이아웃 각 템플릿 파일에 스타일 적용 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223&lt;!--// base.html //--&gt;&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; &#123;% block extra_css %&#125; &#123;% endblock %&#125; &lt;!--// CSS 적용 //--&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" crossorigin=\"anonymous\"&gt; &lt;/head&gt; &lt;body&gt; &lt;!--// nav bar 적용 //--&gt; &lt;nav class=\"navbar navbar-expand-lg navbar-light bg-light\"&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Bookmark&lt;/a&gt; &lt;button class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarText\" aria-controls=\"navbarText\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"&gt; &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=\"collapse navbar-collapse\" id=\"navbarText\"&gt; &lt;ul class=\"navbar-nav mr-auto\"&gt; &lt;li class=\"nav-item active\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Home &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Features&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;!--// create 기능 추가 //--&gt; &lt;a class=\"nav-link\" href=\"&#123;% url 'bookmark:create' %&#125;\"&gt;Add&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;span class=\"navbar-text\"&gt; Navbar text with an inline element &lt;/span&gt; &lt;/div&gt; &lt;/nav&gt; &lt;!--// bootstrap 적용하기 1) base.html에 bootstrap 설치하기 1-1) CDN 스크립트로 설치하기 : 리소스 절감효과, 최신버전을 자동 유지, CDN을 사용하면 접속 속도가 증가 1-2) 다운로드해서 설치하기 : 커스터마이징 가능, 도메인 넘나들지 않아도 된다. 2) base.html에 레이아웃 잡기 3) 각 템플릿에 스타일 적용하기 //--&gt; &lt;div class=\"container\"&gt; &#123;% block content %&#125; &#123;% endblock %&#125; &lt;/div&gt; &#123;% block extra_script %&#125; &#123;% endblock %&#125; &lt;!--// jQuery Slim 버전은 ajax 기능이 빠져있다. min 버전 : 용량을 최소화하 버전 -&gt; 띄어쓰기 생략, 엔터 생략 -&gt; 한줄로 다 되어있어, 수정하기가 힘듬 beautify : min 버전은 소스코드를 알아보기 힘들기 때문에 beautify해서 다시 보기 좋게 만든다. 모든 static 리소스들은 캐시가 걸린다. -&gt; 수정 사항이 바로 반영되지 않는다. 1) 웹 서버에서 캐시 타임 조절 : 자주 수정되는 경우 캐시 타임을 확 줄인다. -&gt; 이미 정해진 타임은 조절할 수 없다. 2) 스태틱 리소스의 파일명을 변경한다. -&gt; 소스코드 수정이 필요할 수 있다. 3) 스태틱 리소스 뒤에 Query String을 붙인다. -&gt; 아예 캐싱이 안되도록 한다. //--&gt; &lt;!--// JS 적용 //--&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js\" integrity=\"sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js\" integrity=\"sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &lt;!--// bookmark_list //--&gt; &#123;% extends 'base.html' %&#125; &#123;% block title %&#125; Bookmark List &#123;% endblock %&#125; &#123;% block content %&#125; &lt;!--// grid system 적용(반응형) //--&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-12 col-xl-8 col-md-4\"&gt; &lt;a href=\"&#123;% url 'bookmark:create' %&#125;\" class=\"btn btn-success\"&gt;add Bookmark&lt;/a&gt;&lt;br&gt; &#123;# bookmark 목록 출력하기 #&#125; &lt;!--// table 적용 //--&gt; &lt;table class=\"table\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;!--// table column 항목 //--&gt; &lt;th scope=\"col\"&gt;NB&lt;/th&gt; &lt;th scope=\"col\"&gt;Site Name&lt;/th&gt; &lt;th scope=\"col\"&gt;Link&lt;/th&gt; &lt;th scope=\"col\"&gt;Update&lt;/th&gt; &lt;th scope=\"col\"&gt;Delete&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!--// table 내용 //--&gt; &#123;% for object in object_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;object.id&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"&#123;% url 'bookmark:detail' object.id %&#125;\"&gt;&#123;&#123;object.site_name&#125;&#125;&lt;/a&gt; &lt;/td&gt; &lt;td&gt;&lt;a href=\"&#123;&#123;object.url&#125;&#125;\" target=\"_blank\"&gt;&#123;&#123;object.url&#125;&#125;&lt;/a&gt;&lt;/td&gt; &lt;!--// button 적용 //--&gt; &lt;td&gt;&lt;a href=\"&#123;% url 'bookmark:update' object.id %&#125;\" class=\"btn btn-light\"&gt;수정&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"&#123;% url 'bookmark:delete' object.id %&#125;\" class=\"btn btn-danger\"&gt;삭제&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% endblock %&#125; &lt;!--// bookmark_create //--&gt; &#123;% extends 'base.html' %&#125; &#123;% block title %&#125; Bookmark Create &#123;% endblock %&#125; &#123;% block content %&#125; &lt;!--// grid system 적용(반응형) //--&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-12 col-xl-8\"&gt; &lt;!--// alert 적용 //--&gt; &lt;div class=\"alert alert-primary\" role=\"alert\"&gt; Please insert bookmark information. &lt;/div&gt; &lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123;form.as_p&#125;&#125; &lt;input type=\"submit\" value=\"Create\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% endblock %&#125; &lt;!--// bookmark_update //--&gt; &#123;% extends 'base.html' %&#125; &#123;% block title %&#125; Bookmark Update &#123;% endblock %&#125; &#123;% block content %&#125; &lt;!--// grid system 적용(반응형) //--&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-12 col-xl-8\"&gt; &lt;!--// alert 적용 //--&gt; &lt;div class=\"alert alert-secondary\" role=\"alert\"&gt; Please change bookmark information. &lt;/div&gt; &lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123;form.as_p&#125;&#125; &lt;input type=\"submit\" value=\"Update\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% endblock %&#125; &lt;!--// bookmark_delete //--&gt; &#123;% extends 'base.html' %&#125; &#123;% block title %&#125; Bookmark Delete &#123;% endblock %&#125; &#123;% block content %&#125; &lt;!--// grid system 적용(반응형) //--&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-12 col-xl-8\"&gt; &lt;!--// alert 적용 //--&gt; &lt;div class=\"alert alert-danger\" role=\"alert\"&gt; Do you want to delete &#123;&#123;object.url&#125;&#125;? &lt;/div&gt; &lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &lt;input type=\"submit\" value=\"Delete Ok\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% endblock %&#125; &lt;!--// bookmark_detail //--&gt; &#123;% extends 'base.html' %&#125; &#123;% block title %&#125; Bookmark Detail &#123;% endblock %&#125; &#123;% block content %&#125; &lt;!--// grid system 적용(반응형) //--&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;div class=\"col-12 col-xl-8\"&gt; &lt;!--// cards 적용 //--&gt; &lt;div class=\"card\" style=\"width: 18rem;\"&gt; &lt;div class=\"card-body\"&gt; &lt;h5 class=\"card-title\"&gt;&#123;&#123;object.site_name&#125;&#125;&lt;/h5&gt; &lt;h6 class=\"card-subtitle mb-2 text-muted\"&gt;&lt;a href=\"&#123;&#123;object.url&#125;&#125;\"&gt;&#123;&#123;object.url&#125;&#125;&lt;/a&gt;&lt;/h6&gt; &lt;p class=\"card-text\"&gt;&#123;&#123;object.contents&#125;&#125;&lt;/p&gt; &lt;!--// button 적용 //--&gt; &lt;a href=\"&#123;% url 'bookmark:update' object.id %&#125;\" class=\"card-link btn btn-outline-warning\"&gt;수정&lt;/a&gt; &lt;a href=\"&#123;% url 'bookmark:delete' object.id %&#125;\" class=\"card-link btn btn-outline-danger\"&gt;삭제&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col\"&gt;&lt;/div&gt; &lt;/div&gt; &#123;% endblock %&#125; models.py에 text를 담기 위해 필드 추가 123456789101112131415161718from django.db import modelsclass Bookmark(models.Model): site_name = models.CharField(max_length=50) url = models.URLField() # contents 필드 추가 # 내용을 아무것도 안 적을 수 있기 때문에 blank=True 적용 contents = models.TextField(blank=True) created = models.DateTimeField(auto_now_add=True) def __str__(self): return \"Site name : \"+self.site_name+\", URL : \"+self.url class Meta: ordering = ['site_name'] 관리자 페이지를 커스터마이징하기 위해 admins.py 수정 12345678910111213141516171819from django.contrib import admin # Register your models here. # 관리자 페이지에서 관리할 모델을 등록 # 관리자 페이지를 커스터마이징 # 옵션 클래스를 만들어서 추가 from .models import Bookmark class BookmarkOptions(admin.ModelAdmin): list_display = ['id', 'site_name', 'url'] # list_editable = ['site_name', 'url'] # list_filter = ['url'] # 대부분 DateTime 필드가 있을 경우 많이 사용 search_fields = ['site_name', 'url'] # ForeignKey 필드 값 같이 다른 테이블을 참조하는 항목은 X # raw_id_fields : 선택값 -&gt; 입력값 # 관리자 페이지에 커스텀 페이지 추가 # 관리자 페이지에 action 추가 admin.site.register(Bookmark, BookmarkOptions) github 업로드 github 계정에서 Repository를 생성한다. 아무것도 추가 생성하지 않는다.(.gitignore, license) pycharm 프로젝트로 돌아온다. 의존성 리스트를 생성하지 않았다면 생성하도록 한다. 1$ pip freeze &gt; requirements.txt .gitignore 파일을 생성한다. 1234567# bookmark_project/.gitignore# .gitignore 파일 내용*.pyc *~ /venv __pycache__ db.sqlite3 현재 프로젝트를 다음과 같은 순서로 github에 업로드한다. 12345678910$ git init$ git add -A .$ git commit -m \"first commit\"# github에 만든 프로젝트의 주소를 가져옴$ git remote add origin https://github.com/JINUKK/Bookmark.git$ git push -u origin master pythonanywhere.com을 이용한 배포 계정 생성 후, bash 진입 다음과 같은 순서로 github에 업로드한 프로젝트를 가져온다. 123456789101112131415$ git clone https://github.com/JINUKK/Bookmark.git$ cd Bookmark/# 가상 환경 적용$ virtualenv --python=python3.7 venv$ source venv/bin/activate# 의존성 리스트를 불러옴$ pip install -r requirements.txt$ python manage.py migrate$ python manage.py createsuperuser bash 페이지에서 오른쪽 상단에 Web 페이지 열기 Wep app 시작하기(Manual Configuration 및 python3.7 선택) Virtualenv 항목에서 경로 지정 bash 페이지에서 pwd 명령어를 이용하여 경로 보기 /home/[pythonanywhere-id]/Bookmark/venv Code 항목에서 WSGI configuration file 수정 pycharm 프로젝트에서 config/wsgi.py 내용으로 변경 CSS를 다루기 위해 StaticFilesHandler도 추가12345678910111213import osimport syspath='/home/pythonanywhere-id/Bookmark'if path not in sys.path: sys.path.append(path)from django.core.wsgi import get_wsgi_applicationfrom django.contrib.staticfiles.handlers import StaticFilesHandleros.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')application = StaticFilesHandler(get_wsgi_application()) pycharm 프로젝트로 돌아와서 settings.py를 다음과 같이 수정한다. 123DEBUG = False # 디버그를 보여줌. 사용자 입장에서는 안보이게 False로 처리ALLOWED_HOSTS = ['.pythonanywhere.com','localhost','127.0.0.1'] git에 add, commit, push를 진행한다. 12345$ git add -A .$ git commit -m \"second commit\"$ git push origin master pythonanywhere의 bash로 돌아와서 git pull을 진행한다. 1$ git pull Reload id.pythonanywhere.com을 진행한 후, 사이트에 접속해본다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.29 Django Study","slug":"190429-Django-Study","date":"2019-04-29T09:08:44.000Z","updated":"2019-04-30T09:29:44.737Z","comments":true,"path":"2019/04/29/190429-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/29/190429-Django-Study/","excerpt":"","text":"[ Bookmark project ] 프로젝트 생성 장고 설치 1$ pip install django 장고 프로젝트 생성 1django-admin startproject config . DB 초기화 1$ python manage.py migrate 관리자 계정 생성 1$ python manage.py createsuperuser 기본 앱 생성 1$ python manage.py startapp bookmark INSTALLED APPS에 ‘bookmark’ 앱 추가 1234567891011121314# bookmark_project/config/setting.pyINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'bookmark', ] # 템플릿 폴더를 검색, DB 변경 사항 추적 # INSTALLED APPS에 추가된 앱들만 템플릿 폴더를 검색한다. Models.py 작성 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# custom field# DB의 column = 데이터 타입, 제약조건# form.py# 입력받는 대상이 뭔가 특별할 경우 설계# DB에 저장되는 항목이 아닐 경우 ex) 회원가입 시, 패스워드 확인from django.db import models# 모델의 형태 - 클래스# models.Model을 상속받는 이유# 상속 : 어떤 클래스가 부모 클래스를 상속받는다.# ---&gt; 부모 클래스가 가지고 잇는 메서드나 속성값을 사용하기 위해서# models.Model을 상속받은 이유?# models.Model이 가지고 있는 메서드나 속성값을 사용하기 위해서# models.Model: ORM 관련 기능들# ORM 관련 기능 : DB를 추상화해서 코드로 조작할 수 있게 하는 기능# 데이터를 추가, 수정, 검색, 삭제class Bookmark(models.Model): site_name = models.CharField(max_length=50) url = models.URLField() # 작성자 -&gt; 로그인한 유저 정보를 찾아서 추가 # 작성자 != 로그인한 유저다 # -&gt; 모델 저장 직전에 직접 코드로 처리 # 작성일 -&gt; 서버 시간을 읽어서 timestamp 값을 만들어 추가 # 자동 옵션 auto_now(현재날짜로 갱신),auto_now_add(최초 저장시에만 현재날짜 적용) created = models.DateTimeField(auto_now_add=True) # DB에 적용 : makemigrations, migrate # $ python manage.py makemigrations bookmark # $ python manage.py migrate bookmark 0001 # 관리자 페이지 목록에 표시될 내용 # 확인 메시지에 출력되는 내용을 만들기 위해 # __str__을 만들지 않으면 object라는 이름으로 뜸 def __str__(self): return \"Site name : \"+self.site_name+\", URL : \"+self.url # 메타 클레스는 옵션 클래스 - 내가 상속을 받았는데, 속성값에 변경이 필요하다면class Meta: # ordering은 정렬을 의미 # '필드이름' = 필드값 오름차순 # '-필드이름' = 필드값 내림차순 ordering = ['site_name'] # 모델 클래스가 수정됐다고 해서 항상 migrate해야 하는 것은 아니다. # DB에 변경 사항이 반영이 되어야 할 항목들만 migrate를 한다. admin.py 작성 1234567891011from django.contrib import admin# 관리자 페이지에서 관리할 모델을 등록# 관리자 페이지를 커스터마이징# 옵션 클래스를 만들어서 추가from .models import Bookmarkadmin.site.register(Bookmark)# admin 계정으로 접속 후, 데이터를 넣어보자. views.py 작성 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# context processor 작성# 모든 페이지(템플릿 파일 전체)에 출력될 내용# custom template tag# -&gt; 템플릿 엔진에서 지원하는 태그 외에, 개발자가 추가로 필요한 기능from django.shortcuts import render# 뷰 종류# 클래스형 뷰, 함수형 뷰는 서로 상호 기능 제약이 거의 없다.# =&gt; 클래스형 뷰는 함수형 뷰로, 함수형 뷰는 클래스형 뷰로 만들 수 있다.# 함수형# CRUDL에 특별한 처리를 추가해야 되는 경우# 함수형 뷰는 자유도가 클래스형 뷰에 비해서 높다.# def 뷰이름(request[, 추가 인수]):# 처리할 내용# 처리할 코드를 직접 다 개발자가 작성# 클래스형# CRUDL에 관련 기능은 자주 사용하기 때문에 장고에서 제네릭# 클래스형 뷰는 생산성이 함수형 뷰에 비해 높다.# class 뷰이름(제네릭뷰):# 처리할 내용# 제네릭 기능 외에 추가적인 기능을 개발자가 작성# 메서드 방식 - 커스터마이징에 관련된 메서드를 찾아야 한다.# CRUD_Lfrom django.views.generic.list import ListView# 클래스형 뷰의 이름은 자유from .models import Bookmarkfrom django.views.generic.edit import CreateView, UpdateView, DeleteViewfrom django.views.generic.detail import DetailViewclass BookmarkList(ListView): model = Bookmark # _list # 나중에 반영할 옵션들 # 템플릿 종류 # 읽어오는 데이터 # 페이지네이션을 걸거나 # 검색 쿼리를 적용하거나 # 권한 체크# 뷰를 만들었다면 URL 연결# CRUD -&gt; 뷰를 만들고 URL 연결까지class BookmarkCreate(CreateView): model = Bookmark # fields는 사용자가 입력할 모델 필드를 정하는 것 fields = ['site_name', 'url'] template_name_suffix = '_create' # 템플릿 html 기본 이름을 변경할 수 있음 # _form에서 _create로 이름 변경 success_url = '/' # 추가, 수정, 삭제의 경우 해당 기능을 완료한 후에 이동할 페이지가 필요하다. # 1) success_url 이라는 속성값을 지정 # 2) models에 get_absolute_url 이라는 메소드를 만드는 방법도 있다. class BookmarkUpdate(UpdateView): model = Bookmark fields = ['site_name', 'url'] template_name_suffix = '_update' # _form에서 _update로 이름 변경 success_url = '/' class BookmarkDelete(DeleteView): model = Bookmark template_name_suffix = '_delete' # _confirm_delete에서 _delete로 이름 변경 success_url = '/' class BookmarkDetail(DetailView): model = Bookmark # _detail urls.py 작성 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# bookmark/urls.pyfrom django.urls import pathfrom .views import BookmarkList, BookmarkCreate, BookmarkUpdate, BookmarkDelete, BookmarkDetail# app_name =&gt; namespace(이름 공간)# 다른 앱들과 url pattern 이름이 겹치는 것을 방지하기 위해서 사용# namespace라는 인수가 존재app_name = 'bookmark' # 앱 이름과 같지 않아도 된다.urlpatterns = [ # path(url pattern, view, url pattern name), &lt;- 콤마는 습관처럼 넣자 # 함수형 뷰 : 이름만 # 클래스형 뷰 : 이름.as_view() path('create/', BookmarkCreate.as_view(), name='create'), path('update/&lt;int:pk&gt;/', BookmarkUpdate.as_view(), name='update'), path('delete/&lt;int:pk&gt;/', BookmarkDelete.as_view(), name='delete'), path('detail/&lt;int:pk&gt;/', BookmarkDetail.as_view(), name='detail'), # [custom converter] =&gt; path, uuid, slug, int, str # ex) localhost/bookmark/1 =&gt; 글 보기, 수정, 삭제 # ex) localhost/bookmark/create =&gt; 글 쓰기 # 위 두 주소는 bookmark/&lt;value&gt;에 해당되어 구분이 되지 않는다. # bookmark/&lt;int:value&gt;처럼 int(converter)를 붙여줌으로써 구분할 수 있다. # 아무것도 붙이지 않을 경우, str이 된다. # int : 정수 # str : 문자(default) # uuid : application 호출 # slug : SEO로 인해 많이 사용 ex) why-so-serious처럼 '-'로 이어진 형태 # path : 'bookmark/&lt;path:value&gt;/ ex) bookmark/19/04/29/ # 위의 기본 converter를 제외한 형태가 필요하다면 custiom converter를 만든다. path('', BookmarkList.as_view(), name='index'),]# config/urls.pyfrom django.contrib import adminfrom django.urls import path, include # include 등록urlpatterns = [ path('admin/', admin.site.urls), path('', include('bookmark.urls')), # 추가] Templete 작성(분기) 123&lt;!--// block문 이용 //--&gt;&#123;% block [블록이름] %&#125;&#123;% endblock %&#125; bookmark_project/layout(폴더 생성)/base.html(‘base’라는 이름은 관례) 생성 config/settings.py에 TEMPLATES = [‘DIRS’: [os.path.join(BASE_DIR, ‘layout’)],] 추가 1234567891011121314151617&lt;!--// base.html //--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; &#123;% block extra_css %&#125; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt;&#123;% block content %&#125;&#123;% endblock %&#125;&#123;% block extra_script %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; bookmark_project/bookmark/templates/bookmark에 html 생성 views.py에 설계한 class형 뷰 템플릿 파일 생성 base.html과 겹치는 부분 제거 후, block문으로 대체 C(Create) : 객체를 생성하는 곳 R(Read) : 단일 객체(object) U(Update) : 단일 객체(object) D(Delete) : 단일 객체(object) L(List) : 복수 객체(object_list)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!--// bookmark_list.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Bookmark List&#123;% endblock %&#125;&#123;% block content %&#125;&#123;# bookmark 목록 출력하기 #&#125;&#123;% for object in object_list %&#125;&lt;a href=\"&#123;% url 'bookmark:detail' object.id %&#125;\"&gt;&#123;&#123;object.id&#125;&#125; &#123;&#123;object.site_name&#125;&#125;&lt;/a&gt; &lt;a href=\"&#123;&#123;object.url&#125;&#125;\"&gt;&#123;&#123;object.url&#125;&#125;&lt;/a&gt;&lt;br&gt;&#123;% endfor %&#125;&#123;% endblock %&#125;&lt;!--// bookmark_create.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Bookmark Create&#123;% endblock %&#125;&#123;% block content %&#125; &lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123;form.as_p&#125;&#125; &lt;input type=\"submit\" value=\"Create\"&gt; &lt;/form&gt;&#123;% endblock %&#125;&lt;!--// bookmark_update.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Bookmark Update&#123;% endblock %&#125;&#123;% block content %&#125; &lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &#123;&#123;form.as_p&#125;&#125; &lt;input type=\"submit\" value=\"Update\"&gt;&lt;/form&gt;&#123;% endblock %&#125;&lt;!--// bookmark_delete.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Bookmark Delete&#123;% endblock %&#125;&#123;% block content %&#125; &lt;form action=\"\", method=\"post\"&gt; &#123;% csrf_token %&#125; &lt;input type=\"submit\" value=\"Delete Ok\"&gt;&lt;/form&gt;&#123;% endblock %&#125;&lt;!--// bookmark_detail.html //--&gt;&#123;% extends 'base.html' %&#125;&#123;% block title %&#125;Bookmark Detail&#123;% endblock %&#125;&lt;!--//url을 쓸 때 app name이 존재한다면즉, namespace가 있다면 namespace를 붙여줘야 한다. ex) bookmark:update //--&gt;&#123;% block content %&#125;&#123;&#123;object.id&#125;&#125;&lt;br&gt;&#123;&#123;object.site_name&#125;&#125;&lt;br&gt;&#123;&#123;object.url&#125;&#125;&lt;br&gt;&lt;a href=\"&#123;&#123;object.url&#125;&#125;\"&gt;링크&lt;/a&gt;&lt;br&gt;&lt;a href=\"&#123;% url 'bookmark:update' object.id %&#125;\"&gt;수정&lt;/a&gt;&lt;br&gt;&lt;a href=\"&#123;% url 'bookmark:delete' object.id %&#125;\"&gt;삭제&lt;/a&gt;&#123;% endblock %&#125;","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.26 Django Study","slug":"190426-Django-Study","date":"2019-04-26T08:49:31.000Z","updated":"2019-04-26T09:03:40.028Z","comments":true,"path":"2019/04/26/190426-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/26/190426-Django-Study/","excerpt":"","text":"HTTP Server 브라우저를 통해 사용자가 HTTP Request Messsage를 보낸다. 서버는 그 Message를 해석하고 Request Message를 보낸다.2-1. 어느 페이지로 접속했는가?2-2. Query String은 어떤 페이지를 가지고 있는가?2-3. 특정 스크립트 요청이 있는가?2-4. 최종 응답을 어떤 방식으로 할 것인가?( HTML or 다운로드 ) HTTP Request만 하는 서버 123456789101112import http.serverimport socketserverPORT = 8000 # 서버에 접속하는 포트# 요청이 들어오면 어느 객체가 요청을 해석하고 처리할 것인가?# 문제에 대해 누가 처리할 것인가? = HandlerHandler = http.server.SimpleHTTPRequestHandlerwith socketserver.TCPServer((\"\",PORT), Handler) as httpd: print(\"serving at PORT\", PORT) httpd.serve_forever() GET 방식을 통해 Query String 정보 받기 form 형식을 사용하여 POST Method 사용하기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788from http.server import BaseHTTPRequestHandler, HTTPServerfrom urllib.parse import parse_qs, urlparseimport requestsfrom bs4 import BeautifulSoupimport jsonPORT = 8000class Handler(BaseHTTPRequestHandler): # django는 한 페이지에서 접속 Method에 따라 기능을 분기 # 회원 가입 페이지 domain.com/signup/ # Get : 회원가입 양식 보여주기 # Post : 전달받은 데이터를 처리해서 회원가입 진행하기(데이터베이스에 저장하기) def do_GET(self): self.send_response(200) self.send_header('Content-type', 'text/html') self.end_headers() # urlparse가 주소를 분석해주고 쿼리문을 가져옴 query_text = urlparse(self.path).query print(query_text) # 딕셔너리 형태로 바꿔줌 # 변수명은 하나지만 값이 여러개일수 있어서 value 값이 리스트 형태로 나옴 query_vars = parse_qs(query_text) print(query_vars) message = \"Welcome\" form_html = \"\"\" &lt;form action='' method='post'&gt; &lt;label&gt;Weight:&lt;input type='text' name='weight'&gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;Height:&lt;input type='text' name='height'&gt;&lt;/label&gt;&lt;br&gt; &lt;input type='submit' value='Calc'&gt; &lt;/form&gt; \"\"\" # query string으로 키와 몸무게를 전달받아서 # bmi를 계산해서 message로 출력하시오. # 1. 딕셔너리를 다룰 수 있는가? # 2. 변수형에 대해 인지하고 있는가? # 3. 연산에 대해 알고 있는가? # 먼저 데이터가 있는지 없는지 항상 확인해야 한다. if 'weight' in query_vars and 'height' in query_vars: print('data') weight = float(query_vars['weight'][0]) height = float(query_vars['height'][0]) bmi = round(weight / (height/100)**2, 2) message += \"BMI :\"+str(bmi) message += form_html self.wfile.write(bytes(message, 'utf-8')) return def do_POST(self): content_length = int(self.headers.get('Content-Length')) post_body = self.rfile.read(content_length) queries = parse_qs(post_body.decode('utf-8')) print(queries) message = \"POST Test&lt;br&gt;Result:\" if 'weight' in queries and 'height' in queries: print('data') weight = float(queries['height'][0]) height = float(queries['weight'][0]) bmi = round(weight / (height/100)**2, 2) message += \" BMI= \"+str(bmi) self.send_response(200) self.send_header('Content-type', 'text/html') self.end_headers() self.wfile.write(bytes(message, 'utf-8')) return# method &lt;-&gt; with문으로 바꿀 수 있어야 함def run(): server_address = ('127.0.0.1', PORT) # IP 주소를 직접 설정 가능 httpd = HTTPServer(server_address, Handler) print(\"serving at PORT\", PORT) httpd.serve_forever()run() 최종 응답을 엑셀 파일로 저장하기 -&gt; xlsxwriter 1234567891011121314151617181920212223242526272829303132333435363738# $ pip install xlsxwriter # 모듈 설치import http.serverimport socketserverimport ioimport xlsxwriterfrom tempfile import NamedTemporaryFilePORT = 8000class Handler(http.server.SimpleHTTPRequestHandler): def do_GET(self): # flush 방식 # io.BytesIO()가 시작되는 지점부터 화면에 출력되는 것들을 다 잡아줌 output = io.BytesIO() # xlsxwriter로 만든 데이터를 BytesIO라는 데이터스트림으로 변환해서 출력 # 실시간 데이터를 저장할 수 있음 workbook = xlsxwriter.Workbook(output, &#123;'in_memory':True&#125;) worksheet = workbook.add_worksheet() # openpyxl과 달리 셀번호가 0번부터 시작한다. worksheet.write(0,0, \"EXCEL TEST\") workbook.close() output.seek(0) self.send_response(200) self.send_header('Content-Disposition','attachment; filename=test.xlsx') self.send_header('Content-type','application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') self.end_headers() self.wfile.write(output.read()) returnprint(\"serving at port\",PORT)httpd = socketserver.TCPServer(('',PORT),Handler)httpd.serve_forever() 최종 응답을 엑셀 파일로 저장하기 -&gt; openpyxl 123456789101112131415161718192021222324252627282930313233import http.serverimport socketserverimport ioimport xlsxwriterfrom tempfile import NamedTemporaryFilefrom openpyxl.workbook import Workbookfrom openpyxl.writer.excel import save_virtual_workbookPORT = 8000class Handler(http.server.SimpleHTTPRequestHandler): def do_GET(self): # openpyxl-&gt; wb = Workbook() ws = wb.active ws.cell(1,1,\"openpyxl test 1\") output = io.BytesIO(save_virtual_workbook(wb)) # 파일 포인터는 항상 글의 끝에 위치하고 있다. # save할 때는 상관이 없으나, read할 때는 파일 포인터를 글의 처음으로 옮겨서 읽어야 한다. self.send_response(200) self.send_header('Content-Disposition','attachment; filename=test.xlsx') self.send_header('Content-type','application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') self.end_headers() self.wfile.write(output.read()) returnprint(\"serving at port\",PORT)httpd = socketserver.TCPServer(('',PORT),Handler)httpd.serve_forever() CGI Common Gateway Interface CGI 장점 : 특별한 추가 프로그램 없이도 여러 언어의 스크립트 실행 가능 CGI 단점 : 요청이 있을 때마다 프로세스(응용프로그램)를 새로 실행(time overhead) CGI Test 127.0.0.1/cgi/test.py를 통해 실행 결과를 확인한다. 127.0.0.1/cgi/lotto.py를 통해 실행 결과를 확인한다.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# 테스트 파일 - test.py# 프로젝트 내에서 CGI 폴더를 생성# CGI 폴더 안에 test.py 생성# which python을 통해 경로 지정#!/home/jinwook/server_basic/venv/bin/pythonprint(\"COntent-type: text/html\\n\")print(\"&lt;html&gt;&lt;head&gt;&lt;title&gt;CGI테스트&lt;/title&gt;&lt;/head&gt;&lt;body&gt;CGI Server Testing&lt;/body&gt;&lt;/html&gt;\")# 윈도우와는 달리 리눅스는 실행 권한을 주어야 한다.# 스크립트에 실행권한 주기 : chmod ugo+x cgi/test.py# 테스트파일 - lotto.py#!/home/jinwook/server_basic/venv/bin/pythonimport random# 로또 예상번호 5게임 출력하기# 로또는 1게임당 1~45 사이의 정수 중 6개를 중복없이 뽑아야 한다.# 1. 랜덤하게 숫자 뽑아서 채우기# 1-1. list 방식# random.randint(1,45) &lt;- 끝에 숫자를 포함한다.numbers = []while len(numbers) &lt; 6: number = random.randint(1,45) if number not in numbers: numbers.append(number)# 1-1. set 방식numbers = set()while len(numbers) &lt; 6: number = random.randint(1,45) numbers.add(number)# 2. 원본을 만들어 두고 랜덤하게 몇 개 뽑는 방법# 2-1. 원본은 순서대로, 뽑는 것은 랜덤으로original_numbers = [x for x in range(1,46)]random.sample(original_numbers, 6)# 2-2. 원본을 랜덤으로 만들고, 뽑은 것은 순서대로random.shuffle(original_numbers)numbers = original_numbers[:6]numbers = original_numbers[-6:]print(\"COntent-type: text/html\\n\")print(\"&lt;html&gt;&lt;head&gt;&lt;title&gt;CGI테스트&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\"+str(numbers)+\"&lt;/body&gt;&lt;/html&gt;\")# cgi.py# HTTP Server 관련 소스import http.serverPORT = 8000class Handler(http.server.CGIHTTPRequestHandler): # 특정 폴더에 있는 파일들만 엑세스하도록 지정, # 지정하지 않으면 모든 파일을 엑세스하게 됨 cgi_directories = ['/cgi']with http.server.HTTPServer((\"\",PORT), Handler) as httpd: print(\"serving at port\", PORT) httpd.serve_forever()","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"Python에서 Save File을 만드는 3가지 방법","slug":"190426-Python-how-to-save","date":"2019-04-26T05:52:14.000Z","updated":"2019-06-16T06:12:16.445Z","comments":true,"path":"2019/04/26/190426-Python-how-to-save/","link":"","permalink":"http://JINUKK.github.io/2019/04/26/190426-Python-how-to-save/","excerpt":"","text":"excel file로 저장하기 12345678910111213141516171819# openpyxl module 등록from openpyxl import Workbook# 내용을 저장하기 위해 메모리 상에 파일 만들기wb = Workbook()# wb.activate를 사용하면 엑셀 처음 시트를 가져온다.# wb.create_sheet()를 통해 시트를 추가할 수 있다.ws1 = wb.activatews2 = wb.create_sheet(title='sheet2')ws1.title = 'sheet1' # 엑셀 처음 시트의 이름 지정# ws1[A1]처럼 셀 번호를 직접 지정하여 값을 넣는다.# ws2.cell()처럼 행과 열을 지정하여 값을 넣는 방법도 있다.ws1[A1] = 27ws2.cell(row=1, column=1, value=27)# 엑셀 파일로 저장한다.wb.save('test.xlsx') text file로 저장하기 1234567891011121314151617181920212223242526272829303132333435363738# 파일 경로를 지정하여 원하는 위치에 저장할 수 있다.# 파일 열기 모드에는 읽기 모드('r'), 쓰기 모드('w'), 추가 모드('a')가 있다.# 읽기 모드('r') : 파일을 읽기만 할 때 사용f = open('/home/test.txt', 'r')while True: # 한 줄씩 읽기 line = f.readline() # readline()은 더 이상 읽을 라인이 없으면 None을 출력 if not line: break print(line)# readlines()는 모든 라인을 읽어서 리스트로 반환lines = f.readlines()for line in lines: print(line)# read()는 파일 전체 내용을 문자열로 반환data = f.read()print(data)f.close()# 쓰기 모드('w') : 파일에 내용을 쓸 때 사용f = open('/home/test.txt', 'w')# 1부터 10까지 파일에 쓰기for i in range(1, 10+1): f.write(i+\"/n\")# 파일 객체 닫기f = close()# 추가 모드('a') : 파일의 마지막에 새로운 내용을 추가할 때 사용f = open('/home/test.txt', 'a')for i in range(11, 20+1): f.write(i)f.close() csv file로 저장하기 1234567891011121314151617181920csv module 등록import csv# csv 파일 쓰기 모드# writerow() 안에는 리스트 형태로 데이터를 넣는다.# newline 인자를 사용하여 각 라인의 빈 라인을 없애줌f = open('/home/test.csv', 'w', encoding='utf-8', newline=\"\")wr = csv.write(f)wr.writerow([1, \"a\"])wr.writerow([2, \"b\"])f.close()# csv 파일 읽기 모드# readlines()와 닮음# for문을 이용하여 각 라인 출력f = open('/home/test.csv', 'r', encoding='utf-8')rdr = csv.reader(f)for line in rdr: print(line)f.close()","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"excel","slug":"excel","permalink":"http://JINUKK.github.io/tags/excel/"},{"name":"text","slug":"text","permalink":"http://JINUKK.github.io/tags/text/"},{"name":"csv","slug":"csv","permalink":"http://JINUKK.github.io/tags/csv/"}]},{"title":"2019.04.25 Django Study","slug":"190425-Django-Study","date":"2019-04-25T08:49:18.000Z","updated":"2019-04-26T08:52:14.768Z","comments":true,"path":"2019/04/25/190425-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/25/190425-Django-Study/","excerpt":"","text":"Crawler(크롤러) : 인터넷에 있는 데이터를 자동으로 수집하는 프로그램-&gt; 웹 브라우저를 흉내내는 프로그램 1) requests : 웹 사이트에 접속, 데이터를 받아오는 역할2) BeautifulSoup : 데이터를 HTML로 해석하는 역할-&gt; 선행지식 : HTML에 대한 이해, CSS Selector를 만드는 방법 요소 검사를 통해 확인할 수 있는 소스 코드 or 업데이트되는 환경일 때-&gt; request는 정적 페이지만 가져오기 때문1) selenium : 웹 브라우저 자체를 컨트롤해서 크롤링1-1) 요소를 선택해서 사용자의 동작을 흉내냄 ex) 클릭, 키보드 입력선택자) xpath, css2) BeautifulSoup : 얻은 데이터를 HTML로 해석 daum 페이지의 증권 탭에서 국내 조회 급등 순위 및 현재가 가져오기 12345678910111213141516171819202122232425262728# 조회 급등 항목 10개 찾기# 항목에 1개에 대한 1페이지 주가 데이터를 찾아 출력# 총 10개 항목에 대한 데이터를 찾아 출력import requestsimport json # html, xml, json처럼 포맷 방식from bs4 import BeautifulSoupurl = \"http://finance.daum.net/api/quote/A048410/days?symbolCode=A048410&amp;page=1&amp;perPage=10&amp;\"custom_headers = &#123; 'referer':'http://finance.daum.net/quotes/A048410', 'user-agent':'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:66.0) Gecko/20100101 Firefox/66.0'&#125;req = requests.get(url, headers=custom_headers)if req.status_code == requests.codes.ok: print(\"접속 성공\") # print(req.text) stock_data = json.loads(req.text) # print(stock_data['data'][0]) for daily_data in stock_data['data'][:5]: print(daily_data['date'], daily_data['tradePrice'])else: print(\"접속 실패\") 조회 급등 항목 10개의 이름과 현재가 출력하기 123456789101112131415161718192021222324252627282930313233343536import requestsimport jsondef get_stock_price(stock_code): url = \"http://finance.daum.net/api/quote/\"+stock_code+\"/days?symbolCode=\"+stock_code+\"&amp;page=1&amp;perPage=10&amp;pagination=true\" custom_headers = &#123; 'referer': 'ttp://finance.daum.net/domestic', 'user-agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:66.0) Gecko/20100101 Firefox/66.0' &#125; req = requests.get(url, headers=custom_headers) data = json.loads(req.text) current_data = data['data'][0]['tradePrice'] return current_dataurl = \"http://finance.daum.net/api/search/ranks?limit=10\"custom_headers = &#123; 'referer':'http://finance.daum.net/domestic', 'user-agent':'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:66.0) Gecko/20100101 Firefox/66.0'&#125;req = requests.get(url, headers=custom_headers)if req.status_code == requests.codes.ok: print(\"접속 성공\") # print(req.text) rank_data = json.loads(req.text) # print(rank_data) for rank in rank_data['data']: current_price = get_stock_price(rank['symbolCode']) print(rank['rank'], rank['name'], rank['symbolCode'], current_price)else: print(\"접속 실패\") 원하는 종목 코드를 입력받아 해당 종목의 1페이지 주가 출력하기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 아무 항목이나 1페이지 주가 출력# 사용자에게 종목 코드를 받아서 출력import requestsimport jsonfrom openpyxl import Workbookwb = Workbook()ws = wb.activedef get_stock_data(stock_code): url = \"http://finance.daum.net/api/quote/A\"+stock_code+\"/days?symbolCode=A\"+stock_code+\"&amp;page=1&amp;perPage=10&amp;pagination=true\" custom_headers = &#123; 'referer':'http://finance.daum.net/domestic', 'user-agent':'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:66.0) Gecko/20100101 Firefox/66.0' &#125; req = requests.get(url, headers=custom_headers) if req.status_code == requests.codes.ok: print(\"접속 성공\") total_date_data = json.loads(req.text) print(total_date_data) ws.cell(row=1, column=1, value='날짜') ws.cell(row=1, column=2, value='시가') ws.cell(row=1, column=3, value='고가') ws.cell(row=1, column=4, value='저가') ws.cell(row=1, column=5, value='종가') for idx,date_data in enumerate(total_date_data['data']): ws.cell(row=idx+2, column=1, value=date_data['date']) ws.cell(row=idx+2, column=2, value=date_data['openingPrice']) ws.cell(row=idx+2, column=3, value=date_data['highPrice']) ws.cell(row=idx+2, column=4, value=date_data['lowPrice']) ws.cell(row=idx+2, column=5, value=date_data['prevClosingPrice']) print(date_data['date'], date_data['openingPrice'], date_data['highPrice'], date_data['lowPrice'], date_data['prevClosingPrice']) wb.save('stock_list.xlsx') else: print(\"접속 실패\")if __name__ == \"__main__\": sb_code = input(\"코드 입력: \") get_stock_data(sb_code) NAVER 개발자센터 API 사용 - papago 개발자센터 사이트에서 Application 탭으로 간다. 로그인 후, 애플리케이션 등록에서 이름과 papago API를 선택한다.(papago NMT 번역) 환경은 WEB 설정으로 한다. URL은 “http://127.0.0.1&quot; 로 한다. 등록을 마친 후, Clinet ID와 Client Secret를 확인한다. Documents - 파파고 탭에서 구현 예제를 사용한다.1234567891011121314151617181920212223242526import requestsimport jsonclient_id = \"xxxxxx\" # 개발자센터에서 발급받은 Client IDclient_secret = \"xxxxx\" # 개발자센터에서 발급받은 Client Secretcustom_header = &#123; \"X-Naver-Client-Id\":client_id, \"X-Naver-Client-Secret\":client_secret&#125;encText = \"안녕하세요.\" # input(\"번역할 문장을 입력하세요.\")# data = \"source=ko&amp;target=en&amp;text=\" + encTextdata = &#123; \"source\":\"ko\", \"target\":\"en\", \"text\":encText&#125; # dictionary 형태url = \"https://openapi.naver.com/v1/papago/n2mt\"req = requests.post(url, headers=custom_header, data=data)if req.status_code == requests.codes.ok: print(\"접속 성공\") trans_data = json.loads(req.text) print(trans_data) # 데이터 형태 파악 print(trans_data['message']['result']['translatedText']) # 원하는 데이터 출력 NAVER 개발자센터 API 사용 - 단축 URL12345678910111213141516171819202122import requestsimport jsonclient_id = \"xxxxx\" # 개발자센터에서 발급받은 Client IDclient_secret = \"xxxxx\" # 개발자센터에서 발급받은 Client Secretcustom_header = &#123; \"X-Naver-Client-Id\":client_id, \"X-Naver-Client-Secret\":client_secret&#125;encText = \"https://developers.naver.com/docs/utils/shortenurl\"data = &#123; \"url\":encText&#125;url = \"https://openapi.naver.com/v1/util/shorturl\"req = requests.post(url, headers=custom_header, data=data)if req.status_code == requests.codes.ok: print(\"접속 성공\") trans_data = json.loads(req.text) print(trans_data) # 데이터 형태 파악 print(trans_data['result']['url']) # 원하는 데이터 출력","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.24 Django Study","slug":"190424-Django-Study","date":"2019-04-24T08:49:05.000Z","updated":"2019-04-29T07:34:10.623Z","comments":true,"path":"2019/04/24/190424-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/24/190424-Django-Study/","excerpt":"","text":"Crawler(크롤러) : 웹 페이지에 있는 자료를 자동으로 수집하는 프로그램 주소를 입력하면 해당 서버로 접근한다. 웹 서버 프로그램이 해당 주소에 맞는 내용을 전달한다.-&gt; requests(urllib의 wrapper 클래스) 받은 내용을 해석해서 화면을 보여준다.3-1. 받은 내용을 해석해서 내가 원하는 데이터를 찾는다.-&gt; BeautifulSoup + HTML 코드의 해석 + CSS Selector 모듈 설치 12$ pip install requests$ pip install BeautifulSoup4 # pip install bs4도 가능 셀렉터 HTML Tag1) Container Tag : 맨 앞이 태그 이름 12# ex)&lt;div td=\"adf\"&gt;내용&lt;/div&gt; 2) Empty Tag : 이미지 태그 12# ex)&lt;img src=\"이미지 주소\"&gt; 태그는 속성을 갖는다. 원하는 텍스트를 얻고 싶다면 태크를 찾아야 한다. 단일 셀렉터 1&lt;div id=\"super\" class=\"test\" data-rel=\"\" data-num=\"\"&gt;cont&lt;/div&gt; tag 이름 : ex) div id : 앞에 ‘#’을 붙인다. id는 한 페이지 내에서 중복될 수 없다. ex) #super class : 앞에 ‘.’을 붙인다.(별명이나 그룹이름이라고 생각하면 된다.) ex) .test 다중 셀렉터 ~안에 있는 무엇ex) div li.ah_k : 중간 경로 생략 가능ex) div &gt; ul &gt; li.ah_k : 중간 경로 생략 불가능 = 더 빠름 띄워쓰기가 되어있는 것은 여러 별명으로 되어있는 것으로 그 중에 하나만 선택해서 사용하면 된다. ~이고 ~인 것ex) span.ah_k.ah_some : span이고 ah_k이고 ah_some인 것 naver를 이용하여 실시간 검색어 순위 및 최근 회차 로또 당첨번호 가져오기 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# 웹 페이지에 접근해서 데이터를 가져온다.# requests는 ajax로 받아온 데이터를 실시간으로 반영할 수 없다.# requests로 받아온 데이터는 소스 보기에서 보는 소스까지만 있다.(정적 페이지)# selenium : 웹 브라우저를 원격 조작하는 방식의 크롤러# selenium, scrapyimport requests# 가져온 데이터를 HTML로 해석한다.from bs4 import BeautifulSoupurl = \"https://www.naver.com/\"# URL Encoding# url : 영문# 영문이 아닌 한글은 인코딩된다.# 내용을 알고싶으면 URL Decoding을 해야 한다.url2 = \"https://search.naver.com/search.naver?sm=top_hty&amp;fbm=1&amp;ie=utf8&amp;query=%EB%A1%9C%EB%98%90+%EB%8B%B9%EC%B2%A8%EB%B2%88%ED%98%B8\"# HTTP Method : Get, Post, Put, Head, Delete# Get : 리소스 얻기# Post : 데이터 전달 - 로그인, 회원가입, 글쓰기 ------------ 수정# Put : 리소스 전달 - 사진 올리기 ------------- 최조 업로드# Delete : 리소스 삭제# Head : Method 확인# Postman 이라는 익스텐션치 or 애플리케이션 설치custom_headers = &#123; 'referer':'https://www.naver.com', 'user-agent':'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:66.0) Gecko/20100101 Firefox/66.0' # user-agent는 사용자마다 다르므로 확인하자.&#125;req = requests.get(url, headers=custom_headers)print(req.status_code)print(type(req.status_code))# 200이라고 쓰는 것은 명확한 코드가 아니므로 codes의 ok를 사용if req.status_code == requests.codes.ok: print(\"접속 성공\") # 데이터 해석 req.text print(req.text) # html parser를 이용해서 해석하라는 의미 html = BeautifulSoup(req.text, \"html.parser\") keywords = html.select('.ah_list .ah_k') items = html.select('.ah_list .ah_item') for keyword in keywords: print(keyword.text) print(keywords) # 실시간 검색어 순위 가져오기 for item in items: keyword = item.select_one('.ah_k') rank = item.select_one('.ah_r') link = item.select_one('.ah_a') # print(rank.attrs['class']) # print(rank['class']) print(rank.text, keyword.text, link['href']) # ~ 어떤 요소를 찾고 # 그 요소 안에 각각의 요소를 다시 찾을 수 있다.else: print(\"접속 실패\")# 최근 회차 로또 당첨번호 가져오기req2 = requests.get(url2)if req2.status_code == requests.codes.ok: print(\"접속 성공\") html = BeautifulSoup(req2.text, \"html.parser\") numbers = html.select('.ds div.num_box .num') for number in numbers[:6]: print(number.text, end = \", \") print(\"보너스 번호: \", numbers[-1].text)else: print(\"접속 실패\") daum을 이용하여 모든 회차 로또 당첨번호를 가져오기 모든 회차 당첨번호 카운트 세기 엑셀 파일로 저장하기123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import requestsfrom bs4 import BeautifulSoup# file - setting - projectname - interpreter에서 현재 설치된 모듈을 확인할 수 있다.from openpyxl import Workbook# Workbook : 파일# Worksheet : 탭# 내용을 저장하기 위해 파일 만들기(메모리 상에)wb = Workbook()ws1 = wb.active # 엑셀 처음 시트 가져오기ws2 = wb.create_sheet(title='lotto_list')ws1.title = 'lotto_Count'#dictionary comprehensionnumbers_count = &#123;x:0 for x in range(1, 46)&#125;for num in range(1,856): url = \"https://search.daum.net/search?w=tot&amp;rtmaxcoll=LOT&amp;DA=LOT&amp;q=\"+str(num)+\"회차 로또\" req = requests.get(url) if req.status_code == requests.codes.ok: print(\"접속 성공\") print(num,'회차') html = BeautifulSoup(req.text, \"html.parser\") numbers = html.select('span.img_lotto') ws2.cell(row=num, column=1, value=str(num)+'회차') for index, number in enumerate(numbers): # print(number.text, end=', ') ws2.cell(row=num, column=index+2, value=int(number.text)) numbers_count[int(number.text)] += 1 # print('보너스 번호: ', numbers[-1].text) else: print(\"접속 실패\")print(numbers_count)# for row in range(1, 46):# ws1.cell(row=row, column=1, value=row)# ws1.cell(row=row, column=2, value=numbers_count[row])for k, v in numbers_count.items(): ws1.cell(row=k, column=1, value=k) ws1.cell(row=k, column=2, value=v)wb.save('./lotto_list_text.xlsx')","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.23 Django Study","slug":"190423-Django-Study","date":"2019-04-23T08:36:09.000Z","updated":"2019-04-29T07:11:51.862Z","comments":true,"path":"2019/04/23/190423-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/23/190423-Django-Study/","excerpt":"","text":"웹페이지의 기본형식 = CRUD + List C(CREATE) R(READ) U(UPDATE) D(DELETE) 데이터를 얻을 때…단일 객체 = object. -&gt; R,U,D복수 객체 = object_list. -&gt; List단일 객체로 받을지 복수 객체로 받을지 생각해야 한다. 앱 생성 시 목록 admin.py : 모델을 관리하기 위해 등록, 관리자 페이지 커스터마이징 apps.py : 앱 정보 관리, 앱 진입 시 로드할 기능 관리 models.py : 모델을 만들고 관리하는 부분. (모델은 데이터베이스에 어떤 자료를 어떤 형식으로 저장할 것인지) tests.py : 테스트 셋을 지정하는 파일 - TDD views.py : 페이지나 기능을 코딩하는 파일(대부분 여기서 작업) 뷰 작성하기 12345from django.http import HttpResponsedef index(request): return HttpResponse(\"Hello, world. You're at the polls index.\") 뷰를 호출하기 위해 앱 디렉토리 안에 urls.py를 생성하고 다음과 같은 코드 작성 12345678from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'),]# path('url pattern', view, name = 'url pattern name') 필요한 값이 들어갈 수 있게 url을 설계한다. config 디렉토리 안에 있는 urls.py에서 앱 디렉토리 안 urls를 바라보도록 설정1234567from django.contrib import adminfrom django.urls import include, pathurlpatterns = [ path('polls/', include('polls.urls')), path('admin/', admin.site.urls),] include()로 인해 다른 root와 연결하더라도 정상 동작 가능 데이터베이스 생성models.py에서 작업한다. 모델 만들기 : 필드의 종류와 제약조건 설정 변경 사항 추적하기 : 모델을 읽어서 DB에 반영할 사항을 파일로 작성 1$ python manage.py makemigrations [앱이름] 변경 사항 적용하기 : 변경 사항 파일을 읽어서 쿼리 실행 12345678910111213141516$ python manage.py migrate [앱이름] [마이그레이션 번호]# 앱이름을 쓰지 않을 경우 적용은 가능하지만, 지금 변경된 모든 부분이 바뀌게 된다.# 변경사항이 만들어진 파일은 migrations 폴더 안에 쌓이게 된다.# 장고는 DB 의존성이 낮다. # ~에 대한 의존성이 높다. = ~ 가 아니면 정상 동작하지 않는다. # ~에 대한 의존성이 낮다. = 그게 아니어도 상관이 없다. # 어떤 쿼리가 실행될지 알고 싶다면 $ python manage.py sqlmigrate polls 0001# 어떤 쿼리가 실행될지 확인 # slow 쿼리인지 여부 확인 # 튜닝이 필요한 쿼리인지 여부 확인 config 디렉토리 안 setting.py에 현재 사용할 앱 추가 1234567891011INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'polls',]# 장고 프로젝트에서 동작할 기능. 사용자들이 사용할 기능.# 습관처럼 앱을 추가하면 콤마를 찍자. models.py 변경 후, 변경 사항 적용 12345678910111213141516from django.db import modelsclass Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published')class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0)# 데이터베이스 적용# $ python manage.py makemigrations polls# $ python manage.py migrate polls 쉘 진입으로 데이터베이스 테스트 가능 1$ python manage.py shell 관리자 생성 및 관리자 서버 접속하기 1234567891011121314$ python manage.py createsuperuser# Username: 원하는 아이디 입력# Email address: 이메일 주소 입력# Password: 비밀번호 입력# Password (again): 다시 비밀번호 입력Superuser created successfully.# 접속을 통해 확인# $ python manage.py runserver 관리자 페이지에서 사용 중인 앱 변경 가능하도록 만들기 12345from django.contrib import adminfrom .models import Questionadmin.site.register(Question) 뷰 추가 작성하기 12345678910111213141516171819202122232425from django.shortcuts import render, get_object_or_404from .models import Question,BMIdef index(request): # 모델.objects : 디폴트 매니저 latest_question_list = Question.objects.order_by('-pub_date')[:5] # pub_date를 내림차순으로 5개 받음 context = &#123;'latest_question_list': latest_question_list&#125; # 템플릿 시스템 # render(request, 템플릿, 템플릿 변수) return render(request, 'polls/index.html', context)# 뷰 : 클래스 형 뷰, 함수형 뷰# detail 뷰 : 매개변수가 question_id를 받는다.# 함수형 뷰는 기본적으로 request라는 매개변수를 받는다.def detail(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, 'polls/detail.html', &#123;'question': question&#125;)def results(request, question_id): response = \"You're looking at the results of question %s.\" return HttpResponse(response % question_id)def vote(request, question_id): return HttpResponse(\"You're voting on question %s.\" % question_id) 템플릿 파일 생성 앱 디렉토리 안에 templates 폴더를 생성한다. templates 폴더 안에 사용하고 있는 앱과 같은 이름을 가진 폴더를 생성한다. 같은 이름을 가진 폴더를 한번 더 생성하는 이유는 배포 과정에서 정확한 영역을 나눠주기 위함이다.(같은 이름을 가진 html 파일이 덮어씌워질 수도 있기 때문이다.1234567891011121314151617181920212223242526272829303132333435363738# index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#123;% if latest_question_list %&#125; &lt;ul&gt; &#123;% for question in latest_question_list %&#125; &lt;li&gt;&lt;a href=\"&#123;% url 'detail' question.id %&#125;\"&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&#123;% else %&#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123;% endif %&#125;&lt;/body&gt;&lt;/html&gt;# detail.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;ul&gt;&#123;% for choice in question.choice_set.all %&#125; &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.22 Django Study","slug":"190422-Django-Study","date":"2019-04-22T08:33:40.000Z","updated":"2019-04-26T08:35:19.837Z","comments":true,"path":"2019/04/22/190422-Django-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/22/190422-Django-Study/","excerpt":"","text":"다음과 같은 순서로 장고 프로젝트를 시작하자. 파이썬 프로젝트 생성 가상환경 생성 장고 설치 장고 프로젝트 생성 프로젝트 내부 처리 virtualenv 설치 1$ pip3 install virtualenv python 3.7로 가상환경 사용 1$ virtualenv --python=python3.7 venv 가상환경 activate 실행 1234$ source venv/bin/activate# 가상환경 종료 시$ deactivate 장고 설치 123456789$ pip install [모듈명]$ pip install [모듈명]==[버전]$ pip uninstall [모듈명]$ pip install django$ pip install django==2.1 # 2.1버전 설치 시# 버전 확인$ python -m django --version 의존성 리스트 생성 1234$ pip freeze &gt; requirements.txt# 리스트 설치 시$ pip install -r requirements.txt 장고 프로젝트 생성 123456$ django-admin startproject [프로젝트명]$ django-admin startproject mysite$ django-admin startproject config . # 현재 폴더에 설정 파일만 만들겠다는 의미# django-admin : 장고 매니저# startproject : 프로젝트를 만들겠다라는 옵션 프로젝트를 만들 때에는 django-admin을 사용하고, manage.py를 이용해서 장고 관련 명령어를 사용한다. 127.0.0.1을 이용하여 장고 프로젝트 서버 동작 확인하기 1$ python manage.py runserver 앱 생성 12345678$ python manage.py startapp [앱이름]$ python manage.py startapp polls# admin.py : 모델을 관리하기 위해 등록, 관리자 페이지 커스터마이징# apps.py : 앱 정보 관리, 앱 진입 시 로드할 기능 관리# models.py : 모델을 만들고 관리하는 부분(데이터베이스에 어떤 자료를 어떤 형식으로 저장할 것인지)# tests.py : 테스트 셋을 지정하는 파일 - TDD# views.py : 페이지나 기능을 코딩하는 파일(대부분 여기서 작업)","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.12 Python and CE Study","slug":"190412-PCE-Study","date":"2019-04-12T12:44:32.000Z","updated":"2019-07-04T06:50:04.202Z","comments":true,"path":"2019/04/12/190412-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/12/190412-PCE-Study/","excerpt":"","text":"트리(Tree) 트리의 정의 트리는 connected(연결된) acyclic(순환되지 않는) gragh 루트(root) 노드를 반드시 가진다.(부모가 없는 노드) 트리는 하나의 루트 노드만을 가진다. 트리를 구성하는 노드 간에 단순 경로가 존재 단순 경로(Simple Path) : 왔던 곳을 다시 거치지 않고 가는 것 1개 이상의 노드로 이루어진 유한 집합 나머지 노드들은 서브 트리로 분할 가능 관련 용어 차수(degree) 해당 노드의 자식 노드 개수 트리의 차수(degree of a tree) 트리에 있는 노드의 최대 차수 차수 중에 최대 차수 리프 노드(leaf node) 차수가 0인 노드, 즉 자식이 없는 노드 단말 노드(terminal node)라고도 부름 레벨(level) 루트의 레벨을 1로 하고 자식으로 내려가면서 하나씩 더함 루트 레벨의 시작을 0으로 하기도 함 트리의 높이(height) or 깊이(depth) 트리가 가지는 최대 레벨 포레스트(forest) 루트 노드를 없앤 서브 트리들의 집합 에지(edge) 노드와 노드를 잇는 간선 인터널 노드(internal node) 리프 노드가 아닌 노드 노드와 에지의 관계 1234노드의 개수 = n에지의 개수 = e&gt;&gt; e = n - 1 이진 트리(binary tree) 어떤 노드의 자식 노드의 수가 최대 2개인 트리 루트와 왼쪽 서브 트리, 오른쪽 서브 트리로 이루어진 유한 집합 서브 트리도 모두 이진 트리 특징 레벨 a에서 최대 노드 수: 2^(a-1) 1ex) Level 3에서의 최대 노드 수 : 2^(3-1) = 4 높이가 h인 이진 트리의 최대 노드 수 : 2^h - 1 1ex) 트리의 높이가 3이면 2^3 - 1 = 7 높이가 h인 이진 트리의 최소 노드 수 : h개 1ex) 트리의 높이가 3이면 최소 노드 수도 3 이진 트리의 종류 포화 이진 트리(full binary tree) 모든 레벨이 꽉 차 있는 트리 완전 이진 트리(complete binary tree) 위에서 아래로, 왼쪽에서 오른쪽으로 채워져있는 트리 편향 이진 트리(skewed binary tree) 왼쪽이나 오른쪽 서브 트리만 가지는 트리 순회(traversal) 재방문을 허용하지 않고 트리를 구성하는 모든 노드에 다해서 반드시 한번씩 방문하는 것 Stack 계열의 알고리즘 DFS(Depth First Search) : 깊이 우선 탐색 재귀(recursion)와 반복문, stack 자료구조를 통한 구현 - stack frame 전위 순회(preorder traversal) root -&gt; 왼쪽 서브 트리 -&gt; 오른쪽 서브 트리 중위 순회(inorder traversal) 왼쪽 서브 트리 -&gt; root -&gt; 오른쪽 서브 트리 후위 순회(postorder traversal) 왼쪽 서브 트리 -&gt; 오른쪽 서브 트리 -&gt; root Queue 계열의 알고리즘 BFS(Breadth First Search) : 너비 우선 탐색 레벨 순서 순회(levelorder traversal) root를 시작으로 다음 레벨 왼쪽부터 방문 Coding Practice Linked List를 이용한 Stack과 Queue를 적용하여 이진 트리 및 BST 구현 Linked List를 이용한 Stack과 Queue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class Node: def __init__(self, data=None): self.__data = data self.__next = None @property def data(self): return self.__data @data.setter def data(self, data): self__data = data @property def next(self): return self.__next @next.setter def next(self, n): self.__next = n# Linked List를 통한 Stack 구현class LStack: def __init__(self): self.top = None def empty(self): if self.top is None: return True else: return False def push(self, data): new_node = Node(data) new_node.next = self.top self.top = new_node def pop(self): if self.empty(): return cur = self.top self.top = self.top.next return cur.data def peek(self): if self.empty(): return return self.top.data# Linked List를 통한 Queue 구현class LQueue: def __init__(self): self.front = None self.rear = None def empty(self): if self.front is None: return True else: return False def enqueue(self, data): new_node = Node(data) if self.empty(): self.front = new_node self.rear = new_node return self.rear.next = new_node self.rear = new_node def dequeue(self): if self.empty(): return if self.front is self.rear: self.rear = self.rear.next cur = self.front self.front = self.front.next return cur.data def peek(self): if self.empty(): return return self.front.data Binary Tree 구현 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195class TreeNode: def __init__(self, data): self.__data = data self.__left = None # 노드의 왼쪽 self.__right = None # 노드의 오른쪽 @property def data(self): return self.__data @data.setter def data(self, data): self.__data = data @property def left(self): return self.__left @left.setter def left(self, left): self.__left = left @property def right(self): return self.__right @right.setter def right(self, right): self.__right = right # DFS# recursion을 통한 구현# 전위 순회def preorder(cur): # base case if not cur: return # 방문했다는 것을 데이터로 출력하여 표현 # root node부터 cur 방문 print(cur.data, end = ' ') preorder(cur.left) preorder(cur.right) # 중위 순회def inorder(cur): # base case if not cur: return # root node를 중간에 방문 inorder(cur.left) print(cur.data, end = ' ') inorder(cur.right) # 후위 방문def postorder(cur): # base case if not cur: return # root node를 끝에 방문 postorder(cur.left) postorder(cur.right) print(cur.data, end = ' ') # 반복문 + stack을 통한 구현# 전위 순회def iter_preorder(cur): stack = LStack() while True: while cur: print(cur.data, end = ' ') stack.push(cur) cur = cur.left cur = stack.pop() if not cur: break cur = cur.right # 중위 순회def iter_inorder(cur): stack = LStack() while True: while cur: stack.push(cur) cur = cur.left cur = stack.pop() if not cur: break print(cur.data, end = ' ') cur = cur.right # 후위 순회def iter_postorder(cur): s1 = LStack() s2 = LStack() s1.push(cur) while not s1.empty(): cur = s1.pop() s2.push(cur) if cur.left: s1.push(cur.left) if cur.right: s1.push(cur.right) while not s2.empty(): cur = s2.pop() print(cur.data, end = ' ') # BFS# Queue를 이용한 구현def levelorder(cur): queue = LQueue() queue.enqueue(cur) while not queue.empty(): cur = queue.dequeue() print(cur.data, end = ' ') if cur.left: queue.enqueue(cur.left) if cur.right: queue.enqueue(cur.right)if __name__ == '__main__': n1 = TreeNode(1) n2 = TreeNode(2) n3 = TreeNode(3) n4 = TreeNode(4) n5 = TreeNode(5) n6 = TreeNode(6) n7 = TreeNode(7) n1.left = n2; n1.right = n3 n2.left = n4; n2.right = n5 n3.left = n6; n3.right = n7 print('preorder :') preorder(n1) print(\"\\n\") print('inorder :') inorder(n1) print(\"\\n\") print('postorder :') postorder(n1) print(\"\\n\") print('iter_preorder :') iter_preorder(n1) print(\"\\n\") print('iter_inorder :') iter_inorder(n1) print(\"\\n\") print('iter_postorder :') iter_postorder(n1) print(\"\\n\") print('levelorder :') levelorder(n1)&gt;&gt; preorder : 1 2 4 5 3 6 7 inorder : 4 2 5 1 6 3 7 postorder : 4 5 2 6 7 3 1 iter_preorder : 1 2 4 5 3 6 7 iter_inorder : 4 2 5 1 6 3 7 iter_postorder : 4 5 2 6 7 3 1 levelorder : 1 2 3 4 5 6 7 BST 구현 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172class TreeNode: def __init__(self, key): self.__key = key # data가 아닌 key 값을 기준으로 함 self.__left = None self.__right = None def __del__(self): print(f'deleted data : &#123;self.__key&#125;') @property def key(self): return self.__key @key.setter def key(self, key): self.__key = key @property def left(self): return self.__left @left.setter def left(self, left): self.__left = left @property def right(self): return self.__right @right.setter def right(self, right): self.__right = right class BST: def __init__(self): self.root = None def get_root(self): return self.root def preorder(self, cur, func): # 전위 순회를 사용 if not cur: return func(cur) self.preorder(cur.left, func) self.preorder(cur.right, func) def insert(self, key): new_node = TreeNode(key) cur = self.root if not cur: self.root = new_node return while True: par = cur if key &lt; cur.key: cur = cur.left if not cur: par.left = new_node return else: cur = cur.right if not cur: par.right = new_node return def search(self, target): cur = self.root while cur: if target == cur.key: return cur elif target &lt; cur.key: cur = cur.left else: cur = cur.right return cur def __remove_recursion(self, cur, target): # base case 1 if not cur: return None, None elif target &lt; cur.key: cur.left, rem = self.__remove_recursion(cur.left, target) elif target &gt; cur.key: cur.right, rem = self.__remove_recursion(cur.right, target) # 지우려는 노드를 찾음 else: # 삭제 노드가 리프 노드일 때 if not cur.left and not cur.right: rem = cur cur = None # 삭제 노드가 자식이 하나일 때 : 왼쪽 자식이 있을 때 elif not cur.right: rem = cur cur = cur.left # 삭제 노드가 자식이 하나일 때 : 오른쪽 자식이 있을 때 elif not cur.left: rem = cur cur = cur.right # 삭제 노드가 자식이 둘일 때: else: replace = cur.left while replace.right: replace = replace.right # 삭제 노드의 키와 대체 노드의 키를 교환 cur.key, repplace.key = replace.key, cur.key cur.left, rem = self.__remove_recursion(cur.left, replace.key) return cur, rem def remove(self, target): self.root, removed = self.__remove_recursion(self.root, target) if removed: removed.left = removed.right = None return removedif __name__ == '__main__': print('*'*100) bst = BST() bst.insert(6) bst.insert(3) bst.insert(2) bst.insert(4) bst.insert(5) bst.insert(8) bst.insert(10) bst.insert(9) bst.insert(11) f=lambda x: print(x.key, end=' ') bst.preorder(bst.get_root(), f) print() print('searched key : &#123;&#125;'.format(bst.search(8).key)) bst.remove(9) #bst.remove(8) #bst.remove(6) bst.preorder(bst.get_root(), f) print() print('*'*20)&gt;&gt; ****************************** 6 3 2 4 5 8 10 9 11 searched key : 8 deleted data : 6 5 3 2 4 8 10 9 11 ****************************** deleted data : 5 deleted data : 3 deleted data : 2 deleted data : 4 deleted data : 8 deleted data : 10 deleted data : 9 deleted data : 11","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.11 Python and CE Study","slug":"190411-PCE-Study","date":"2019-04-11T12:44:16.000Z","updated":"2019-05-07T12:45:26.968Z","comments":true,"path":"2019/04/11/190411-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/11/190411-PCE-Study/","excerpt":"","text":"Linked List Linked List를 이용한 Stack 구현 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Node: def __init__(self, data=None): self.__data = data self.__next = None @property def data(self): return self.__data @data.setter def data(self, data): self.__data = data @property def next(self): return self.__next @next.setter def next(self, n): self.__next = nclass LStack: def __init__(self): self.top = None def empty(self): if self.top is None: return True else: return False def push(self, data): new_node = Node(data) new_node.next = self.top self.top = new_node def pop(self): if self.empty(): return cur = self.top self.top = self.top.next return cur.data def peek(self): if self.empty(): return return self.top.dataif __name__ == '__main__': s = LStack() s.push(1) s.push(2) s.push(3) s.push(4) s.push(5) while not s.empty(): print(s.pop(), end = \" \")&gt;&gt; 5 4 3 2 1 Linked List를 이용한 Queue 구현 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Node: def __init__(self, data=None): self.__data = data self.__next = None @property def data(self): return self.__data @data.setter def data(self, data): self.__data = data @property def next(self): return self.__next @next.setter def next(self, n): self.__next = nclass LQueue: def __init__(self): self.front = None self.rear = None def empty(self): if self.front is None: return True else: return False def enqueue(self, data): new_node = Node(data) # 데이터가 하나도 없는 경우, front와 rear은 모두 None을 가리키게 된다. # 이 상태에서는 front와 rear에 데이터가 없기 때문에 다음 데이터를 # 가리킬 수 없다. # 따라서 front와 rear가 처음 데이터가 들어왔을 때, 그 데이터를 가리키게 # 조건을 추가해야 한다. if self.front is None and self.rear is None: self.front = new_node self.rear = new_node return self.rear.next = new_node self.rear = new_node def dequeue(self): if self.empty(): return # 만약 데이터가 한 개 남았을 경우, front와 rear가 같은 데이터를 가리킴 # front에 있는 데이터를 지역변수로 가리키게 하고 front를 front 다음 데이터로 # 옮겨도 rear이 계속 지역변수가 가리키고 있는 데이터를 같이 가리키게 된다. # 이렇게 된다면 레퍼런스 카운트가 0이 되지 않아 데이터가 지워지지 않는다. # 따라서 데이터가 하나 남은 상황이라면 즉, front와 rear이 같은 데이터를 # 가리키고 있다면 rear도 rear의 다음 데이터를 가리키게 조건을 추가해야 한다. if self.front is self.rear: self.rear = self.rear.next cur = self.front self.front = self.front.next return cur.data def peek(self): if self.empty(): return return self.front.data if __name__ == '__main__': q = LQueue() q.enqueue(1) q.enqueue(2) q.enqueue(3) q.enqueue(4) q.enqueue(5) while not q.empty(): print(q.dequeue(), end = \" \")&gt;&gt; 1 2 3 4 5 배열(array) vs 연결 리스트(Linked List) 배열(array) 같은 자료형의 변수를 모아 놓은 것 indexing(search) 데이터가 한군데 모여있다.(군집화) locality로 인해 cache hit가 많음 기본적으로 stack에 할당 검색속도가 빠름(O(1) - 빅오의 1순위) 데이터의 삽입과 삭제가 느림(O(n) - 빅오의 3순위) 데이터의 삽입과 삭제의 양이 많을 경우, 복사가 많이 일어나게 된다. 연결 리스트(Linked List) 데이터가 흩어져 있다. cache miss가 높다. heap에 할당 검색이 느림(O(n) - 빅오의 3순위) 데이터의 삽입과 삭제가 빠름(O(1) - 빅오의 1순위) dynamic heap을 통해 Linked List의 단점을 막을 수 있다. 두 가지 다 적용이 가능하다면 배열을 사용하는 것이 좋다. python의 리스트는 배열이 아니다. 리스트는 포인터 배열 서로 다른 자료형이 들어갈 수 있음 상수가 리스트 안에 있을 때, 그 상수가 정수형이어도 4bytes가 아니다. 상수 객체이기 때문에 int() 클래스 안의 내장함수를 모두 포함하고 있어서용량이 크다. Algorithm - Maze 미로찾기 stack 사용 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def empty(self): if not self.head: return True return False def add(self, data): new_node = Node(data) if not self.head: self.head = new_node return new_node.next = self.head self.head = new_node def traverse(self): cur = self.head while cur: yield cur cur = cur.next class Position: def __init__(self, row, col, dir): self.row = row self.col = col self.dir = dir class MazeSolver: direction = ((-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)) def __init__(self, maze): self.maze = maze # 출구 행, 열을 나타냄 self.EXIT_ROW = len(maze) self.EXIT_COL = len(maze[0]) # 맨 위 아래 옆에 1로된 벽 넣기 # 1. maze의 row열 양 옆에 1 넣기 for row in maze: row.insert(0, 1) row.append(1) # 2. maze의 위 아래로 1로 된 row 열 넣기 added_row = [1 for _ in range(self.EXIT_COL+2)] maze.insert(0, added_row) maze.append(added_row) self.path = LinkedList() def get_path(self): stack = LStack() mark = [] # mark를 0으로 가득 찬 실제 미로 크기의 리스트 for _ in range(self.EXIT_ROW+2): mark.append([0 for _ in range(self.EXIT_COL+2)]) row = None col = None dir = None next_row = None next_col = None found = None # 미로의 시작점(1, 1) mark[1][1] = 1 # 첫 시작의 위치를 stack에 push stack.push(Position(1, 1, 2)) # stack이 비었다면 목적지로 가는 길이 없다는 뜻이다. # 목적지에 도달했다면 while 문에서 빠져나와야 한다. while not stack.empty() and not found: # stack에서 pop을 한다. # 현재의 위치를 업데이트한다. pos = stack.pop() row = pos.row col = pos.col dir = pos.dir # dir을 조사한다. # 모든 방향을 조사했거나 목적지에 도착했다면 while 문에서 빠져나온다. while dir &lt; 8 and not found: next_row = row + self.direction[dir][0] next_col = col + self.direction[dir][1] if next_row == self.EXIT_ROW and next_col == self.EXIT_COL: found = True stack.push(Position(row, col, dir)) stack.push(Position(next_row, next_col, 0)) elif mark[next_row][next_col] == 0 and maze[next_row][next_col] == 0: mark[next_row][next_col] = 1 stack.push(Position(row, col, dir)) row = next_row col = next_col dir = 0 else: dir += 1 if found: while not stack.empty(): self.path.add(stack.pop()) else: print('There is no path in this maze!') def print_path(self): g = self.path.traverse() for node in g: print(\"(&#123;&#125;, &#123;&#125;)\".format(node.data.row, node.data.col)) def show_maze(self): print(' ', end='') for i in range(self.EXIT_ROW+2): print(' ' + str(i) + ' ', end='') print() for i in range(self.EXIT_ROW+2): print(' ' + str(i) + ' ', end='') for j in range(self.EXIT_COL+2): if self.maze[i][j] == 0: print(' O ', end='') else: print(' # ', end='') print() print() def show_path(self): path_set = set() g=self.path.traverse() for node in g: path_set.add((node.data.row, node.data.col)) print(' ', end='') for i in range(self.EXIT_ROW+2): print(' ' + str(i) + ' ', end='') print() for i in range(self.EXIT_ROW+2): print(' ' + str(i) + ' ', end='') for j in range(self.EXIT_COL+2): if (i, j) in path_set: print(' P ', end='') elif self.maze[i][j] == 0: print(' O ', end='') else: print(' # ', end='') print() print()if __name__ == \"__main__\": maze = [ [0, 1, 1, 0, 0], [1, 0, 0, 1, 1], [0, 1, 1, 0, 1], [0, 1, 0, 1, 1], [1, 1, 0, 0, 0], ] maze_solver = MazeSolver(maze) maze_solver.show_maze() maze_solver.get_path() maze_solver.print_path() maze_solver.show_path()&gt;&gt; 0 1 2 3 4 5 6 0 # # # # # # # 1 # O # # O O # 2 # # O O # # # 3 # O # # O # # 4 # O # O # # # 5 # # # O O O # 6 # # # # # # # (1, 1) (2, 2) (2, 3) (3, 4) (4, 3) (5, 4) (5, 5) 0 1 2 3 4 5 6 0 # # # # # # # 1 # P # # O O # 2 # # P P # # # 3 # O # # P # # 4 # O # P # # # 5 # # # O P P # 6 # # # # # # #","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"linked list를 이용한 queue 구현","slug":"190411-Algorithm-queue-linked-list","date":"2019-04-10T15:32:08.000Z","updated":"2019-06-16T15:38:15.883Z","comments":true,"path":"2019/04/11/190411-Algorithm-queue-linked-list/","link":"","permalink":"http://JINUKK.github.io/2019/04/11/190411-Algorithm-queue-linked-list/","excerpt":"","text":"FIFO(First In First Out) 구조를 생각하며 구현해본다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Node: def __init__(self, data=None): self.__data = data self.__next = None @property def data(self): return self.__data @data.setter def data(self, data): self.__data = data @property def next(self): return self.__next @next.setter def next(self, n): self.__next = nclass LQueue: def __init__(self): self.front = None self.rear = None def empty(self): if self.front is None: return True else: return False def enqueue(self, data): new_node = Node(data) # 데이터가 하나도 없는 경우, front와 rear은 모두 None을 가리키게 된다. # 이 상태에서는 front와 rear에 데이터가 없기 때문에 다음 데이터를 # 가리킬 수 없다. # 따라서 front와 rear가 처음 데이터가 들어왔을 때, 그 데이터를 가리키게 # 조건을 추가해야 한다. if self.front is None and self.rear is None: self.front = new_node self.rear = new_node return self.rear.next = new_node self.rear = new_node def dequeue(self): if self.empty(): return # 만약 데이터가 한 개 남았을 경우, front와 rear가 같은 데이터를 가리킴 # front에 있는 데이터를 지역변수로 가리키게 하고 front를 front 다음 데이터로 # 옮겨도 rear이 계속 지역변수가 가리키고 있는 데이터를 같이 가리키게 된다. # 이렇게 된다면 레퍼런스 카운트가 0이 되지 않아 데이터가 지워지지 않는다. # 따라서 데이터가 하나 남은 상황이라면 즉, front와 rear이 같은 데이터를 # 가리키고 있다면 rear도 rear의 다음 데이터를 가리키게 조건을 추가해야 한다. if self.front is self.rear: self.rear = self.rear.next cur = self.front self.front = self.front.next return cur.data def peek(self): if self.empty(): return return self.front.data if __name__ == '__main__': q = LQueue() q.enqueue(1) q.enqueue(2) q.enqueue(3) q.enqueue(4) q.enqueue(5) while not q.empty(): print(q.dequeue(), end = \" \")&gt;&gt; 1 2 3 4 5","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://JINUKK.github.io/categories/Algorithm/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://JINUKK.github.io/tags/algorithm/"},{"name":"queue","slug":"queue","permalink":"http://JINUKK.github.io/tags/queue/"},{"name":"linked list","slug":"linked-list","permalink":"http://JINUKK.github.io/tags/linked-list/"}]},{"title":"linked list를 이용한 stack 구현","slug":"190411-Algorithm-stack-linked-list","date":"2019-04-10T15:31:47.000Z","updated":"2019-06-16T15:36:39.110Z","comments":true,"path":"2019/04/11/190411-Algorithm-stack-linked-list/","link":"","permalink":"http://JINUKK.github.io/2019/04/11/190411-Algorithm-stack-linked-list/","excerpt":"","text":"LIFO(Last In First Out) 구조를 생각하면서 구현하도록 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Node: def __init__(self, data=None): self.__data = data self.__next = None @property def data(self): return self.__data @data.setter def data(self, data): self.__data = data @property def next(self): return self.__next @next.setter def next(self, n): self.__next = nclass LStack: def __init__(self): self.top = None def empty(self): if self.top is None: return True else: return False def push(self, data): new_node = Node(data) new_node.next = self.top self.top = new_node def pop(self): if self.empty(): return cur = self.top self.top = self.top.next return cur.data def peek(self): if self.empty(): return return self.top.dataif __name__ == '__main__': s = LStack() s.push(1) s.push(2) s.push(3) s.push(4) s.push(5) while not s.empty(): print(s.pop(), end = \" \")&gt;&gt; 5 4 3 2 1","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://JINUKK.github.io/categories/Algorithm/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://JINUKK.github.io/tags/algorithm/"},{"name":"linked list","slug":"linked-list","permalink":"http://JINUKK.github.io/tags/linked-list/"},{"name":"stack","slug":"stack","permalink":"http://JINUKK.github.io/tags/stack/"}]},{"title":"2019.04.10 Python and CE Study","slug":"190410-PCE-Study","date":"2019-04-09T16:40:09.000Z","updated":"2019-05-06T17:07:43.449Z","comments":true,"path":"2019/04/10/190410-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/10/190410-PCE-Study/","excerpt":"","text":"git 특강 clone으로 생성한 project는 -u 옵션을 사용할 필요가 없다. branch 분기점을 생성하고 독립적으로 코드를 변경할 수 있도록 도와주는 모델 가로는 시간, 세로는 공간을 의미 github에서 Insights/Network를 통해 현황 보기 가능 origin의 master는 하나 현재 위치 확인 1$ git branch 모든 branch 보기 1$ git branch -a 공간 추가 1$ git branch [공간 이름] 다른 공간 이동 이동한 공간에서 push를 한다면 당연히 remote는 현재 공간을 모름 처음에는 -u 명령어를 사용해야 한다. 1$ git checkout [공간 이름] 다른 공간에서 수정한 파일은 master에서는 아직 수정되어 있지 않은 상태 master로 가져오기(업데이트) 1$ git merge [공간 이름] merge를 한 경우, push를 통해 remote에 올려줘야 함 기존에 있던 복제한 공간은 제거해줘야 한다.(master만 남겨둠) 공간 제거 1$ git branch -D [공간 이름] 개발할 때에는 master와 develop 두 개를 두고 써야 한다. master는 프로그램을 사용하는 사용자에게 배포하는 최신 업로드 프로그램 공간으로 관리 develop는 프로그램을 개발하는 공간으로 관리 git flow git flow를 설치한 후, 사용 내가 사용하고자 하는 프로젝트에서 flow 사용을 알림 1$ git flow init git flow는 자동적으로 master와 develop의 공간을 나눠줌 branch 생성 후, 그 공간으로 자동 이동 1$ git flow feature start [생성 파일 이름] develop에 자동 merge 1$ git flow feature finish [생성 파일 이름] release 생성 1$ git flow release start [파일 이름] release 종료 1$ git flow release finish [파일 이름] python에서 mariaDB Database 활용하기 mysql 관련 모듈 설치 1$ pip install mysql-connector python 소스 작성 12345678910111213141516171819202122232425262728293031from mysql.connector import MySQLConnection# mariaDB의 user 계정 사용하여 연결conn = MySQLConnection(host='localhost', database='mydb', user='jinwook', password='0000')# Cursor 생성cursor = conn.cursor()# mariaDB에서 사용한 SQL문 실행# 가독성을 위해 \"\"\" \"\"\"의 멀티 라인문 사용 cursor.execute(\"\"\"SELECT * FROM students\"\"\")# 한번 호출에 하나의 Row data만 가져옴cursor.fetchone()# fetchmany(n)는 n개 만큼의 Row data를 한꺼번에 가져올 때 사용cursor.fetchmany(4)# 모든 data를 한꺼번에 가져올 때 사용cursor.fetchall()# 연결 종료cursor.close()conn.close() 사용자 정보를 저장한 파일 사용 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# 원하는 경로에 파일을 만든 뒤, conf.ini 파일을 만들어 사용자 정보 저장해둔 후 사용# mkdir today# cd today# touch conf.ini# vi conf.ini# conf.ini 내용\"\"\"[mysql]host = localhostdatabase = mydbuser = jinwookpassword = 0000\"\"\"# 같은 경로에서 다음과 같은 소스 파일 생성# ConfigParser module을 사용하여 외부의 설정 정보를 가져오기from mysql.connector import MySQLConnectionfrom configparser import ConfigParserparser = ConfigParser()# 설정 파일 읽기# 읽었다면 출력에 ['conf.ini']로 출력parser.read('conf.ini')# 섹션 존재 확인 - 'mysql'이라는 문자열이 설정 파일 안에 존재하는지# boolean으로 반환parser.has_section('mysql')# 외부 설정 정보를 딕셔너리에 담기 위해 빈 딕셔너리 선언conf = &#123;&#125;# 섹션이 존재한다면 items(key, value)을 가져옴if parser.has_section('mysql'): items = parser.items('mysql') for key, value in items: conf[key] = value # conf = &#123;'host': 'localhost', 'database': 'mydb', 'user': 'jinwook', 'password': '0000'&#125;# unpacking하여 넣어줌으로써 value 값들이 들어감# *를 쓰면 key 값이, **를 쓰면 value 값이 들어감conn = MySQLConnection(**conf) # UNPACKING 사용# cursor 생성cursor = conn.cursor()# MariaDB 접속 후 TRANSACTION 상태 보기# SHOW CREATE TABLE 및 SHOW TABLE로 상태 확인# ct라는 테이블 생성# column은 id, name, score, birthday로 구성# CREATE 명령어는 DDL이기 때문에 사용하면 자동 commit으로 외부 세션에서 변경 확인 가능cursor.execute(\"\"\"CREATE TABLE ct (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,name VARCHAR(20) DEFAULT 'john doe',score SMALLINT NULL,birthday DATE NOT NULL);\"\"\")# INSERT 명령어는 DML이기 때문에 commit을 하지 않으면# 외부 세션에서는 변경한 데이터 확인 불가능cursor.execute(\"\"\"INSERT INTO ct(name, score, birthday)VALUES('Greg', 99, '2002-2-2');\"\"\")cursor.execute(\"\"\"SELECT * FROM ct;\"\"\")cursor.fetchone()conn.commit() # DML 명령어에 대한 TRANSACTION 상태 종료(변경한 데이터 저장)# UDDATE는 DML 명령어cursor.execute(\"\"\"UPDATE ctSET Score = 120WHERE name LIKE 'Greg';\"\"\")cursor.execute(\"\"\"SELECT * FROM ct;\"\"\")cursor.fetchall()conn.rollback() # DML 명령어에 대한 TRANSACTION 상태 종료(변경 취소)cursor.execute(\"SELECT * FROM ct;\")cursor.fetchone()# IF EXISTS 문을 사용하여 해당 데이터베이스에 테이블이 존재하지 않을 경우# 발생하는 에러 방지cursor.execute(\"\"\"DROP TABLE IF EXISTS ct;\"\"\")# 연결 종료cursor.close()conn.close() 정규식(Regular Expression) 정규 표현식 복잡한 문자열을 처리할 때 사용하는 기법 1234# 일반 문자열 메서드 사용 예시str = \"I am your father!\"str.startswith('I') # 특정 문자열로 시작하는지 확인하는 메서드&gt;&gt; True 문자열 안에 a,b,c 중 한개의 문자와 매치되는지 확인 match 문은 문자열의 처음부터 매치되는지 확인 매치가 된다면 match 객체를 반환 1234import re # 정규식 모듈re.match(r'[abc]', 'abcde')&gt;&gt; &lt;re.Match object; span=(0, 1), match='a'&gt; match 문은 문자열의 처음부터 매치되는지 확인하기 때문에 ‘345ab’는 매치되지 않음 매치되지 않을 경우, None 반환 12print(re.match(r'[abc]', '345ab'))&gt;&gt; None [a-z] : a ~ z 까지 중에 하나 12re.match(r'[a-z]', 'opinion')&gt;&gt; &lt;re.Match object; span=(0, 1), match='o'&gt; [0-9] : 0 ~ 9 까지 중에 하나 12re.match(r'[0-9]', '345ab')&gt;&gt; &lt;re.Match object; span=(0, 1), match='3'&gt; search 문은 문자열 전체를 검색하여 매치되는지 확인 12re.search(r'[abc]', '345ab')&gt;&gt; &lt;re.Match object; span=(3, 4), match='a'&gt; ‘+’는 최소 한 번 이상 반복될 때 매치가 된다고 판단한다.(1 ~ 무한대) 0번 반복될 경우 매치되지 않는다고 판단한다. 12re.search(r'[abc]+', 'abc123')&gt;&gt; &lt;re.Match object; span=(0, 3), match='abc'&gt; 즉, 일치되는 결과가 하나도 없을 경우 매치되지 않는다고 판단 12print(re.search(r'[abc]+', '123'))&gt;&gt; None ‘*’는 최소 0번 이상 반복될 때 매치가 된다고 판단한다.(0 ~ 무한대) 즉, 일치되는 결과가 없더라도 매치된다고 판단 12re.search(r'[abc]*', '123')&gt;&gt; &lt;re.Match object; span=(0, 0), match=''&gt; ‘?’는 해당 문자가 있어도 되고 없어도 된다는 의미 12re.search(r'[abc]?', '123')&gt;&gt; &lt;re.Match object; span=(0, 0), match=''&gt; {n}은 반드시 n개의 개수를 가지고 있는지 판단 일치하지 않을 경우 매치되지 않는다고 판단 12print(re.search(r'a&#123;4&#125;', 'aabb'))&gt;&gt; None 매치된 경우 12re.search(r'a&#123;4&#125;', 'aaaaaaaab')&gt;&gt; &lt;re.Match object; span=(0, 4), match='aaaa'&gt; {m,n}은 m ~ n개 반복되는지 판단 선언할 때 {3, 10}처럼 ‘3,’ 다음에 공백을 두면 매치가 되지 않으므로 주의 공백을 두지 말자 12re.search(r'a&#123;3,10&#125;', 'aaaaaabbbbb')&gt;&gt; &lt;re.Match object; span=(0, 6), match='aaaaaa'&gt; abc가 있는지 전체 문자열에서 판단 12re.search(r'abc', 'defabcxyz')&gt;&gt; &lt;re.Match object; span=(3, 6), match='abc'&gt; ‘^’는 문자열의 처음이 abc인지 판단 처음이 항상 abc라면 매치되고 그렇지 않으면 매치되지 않음 12print(re.search(r'^abc', 'defabcxyz'))&gt;&gt; None ‘^’가 만약 문자 클래스인 [] 안에 들어간다면 처음을 의미하는 것이 아님 반대(not)의 의미를 가짐 [^abc]인 경우, a, b, c가 아닌 문자만 매치 12re.search(r'[^abc]', 'abbbababacczabbaba')&gt;&gt; &lt;re.Match object; span=(11, 12), match='z'&gt; ‘$’는 문자열의 마지막이 xyz인지 판단 마지막이 항상 xyz라면 매치되고 그렇지 않으면 매치되지 않음 12print(re.search(r'xyz$', 'xyzabc'))&gt;&gt; None 매치된 경우 12re.search(r'xyz$', 'abcxyz')&gt;&gt; &lt;re.Match object; span=(3, 6), match='xyz'&gt; 자주 사용하는 정규 표현식은 별도의 표현법으로 표현 가능 대문자는 소문자의 반대인 경우를 의미 \\d = [0-9] \\D = [^0-9] \\s = whitespace 문자 = [ \\t\\n\\r\\f\\v](맨 앞 공백도 의미) \\S = whitespace가 아닌 문자 = [^ \\t\\n\\r\\f\\v] \\w = [a-zA-Z0-9_] \\W = [^a-zA-Z0-9_] 0부터 9까지 하나라도 반복될 경우 매치 12re.search(r'\\d+', 'abc 123 bbb')&gt;&gt; &lt;re.Match object; span=(4, 7), match='123'&gt; match 객체의 메서드를 이용 123m = re.search(r'\\d+', 'abc 123 bbb')m&gt;&gt; &lt;re.Match object; span=(4, 7), match='123'&gt; group() : 매치된 문자열 리턴 12m.group()&gt;&gt; '123' start() : 매치된 문자열의 시작 위치 리턴 12m.start()&gt;&gt; 4 end() : 매치된 문자열의 끝 위치 리턴 12m.end()&gt;&gt; 7 span() : 매치된 문자열의 (시작, 끝)에 해당되는 튜플 리턴 12m.span()&gt;&gt; (4, 7) 전화번호 매치 다양하게 표현된 문자열의 전화번호를 매치 첫번째 번호 자리를 매치시킬 수 있는 \\d{3} = [0-9]{3} = 0 ~ 9 중에 반드시 3자리 매치 번호 사이에 올 수 있는 문자들의 반복(*)까지 추가 = [-./ ]* 가운데 번호 자리는 3 ~ 4자리이므로 \\d{3,4} 마지막 번호 자리를 매치시킬 수 있는 \\d{4} 123456789101112cell_li = ['010-1111-2222', '01022223333', '010.333.4444', '010 4444 5555']pattern = r'\\d&#123;3&#125;[-./ ]*\\d&#123;3,4&#125;[-./ ]*\\d&#123;4&#125;'for cell in cell_li: m = re.search(pattern, cell) if m: print(m.group())&gt;&gt; 010-1111-2222 01022223333 010.333.4444 010 4444 5555 Dot(.)는 모든 문자를 표현할 수 있기 때문에 모든 문자와 매칭됨 12re.search(r'a.z', 'abz')&gt;&gt; &lt;re.Match object; span=(0, 3), match='abz'&gt; Dot 두개는 문자 두개를 의미 12re.search(r'a..z', 'ahyz')&gt;&gt; &lt;re.Match object; span=(0, 4), match='ahyz'&gt; 백슬래시() 문자를 찾을 때… ‘\\‘ 문자가 문자열 그 자체임을 알려주기 위해 백슬래시 2개를 사용하여 처리해야 한다. 하지만 파이썬 문자열 리터럴 규칙에 의해 ‘\\\\‘로 명시하여도 다시 ‘\\‘로 변경하여 전달한다. 따라서 백슬래시 4개(‘\\\\\\\\‘)를 사용해야 한다. 파이썬에서 사용할 때만 적용되는 문제 12re.search('\\\\\\\\', 'dir1\\dir2')&gt;&gt; &lt;re.Match object; span=(4, 5), match='\\\\'&gt; 너무 복잡하기 때문에 파이썬 정규식에는 Raw string이라는 것이 존재 r을 붙여줌 12re.search(r'\\\\', 'dir1\\dir2')&gt;&gt; &lt;re.Match object; span=(4, 5), match='\\\\'&gt; 그룹핑(Grouping) 매치된 문자열 중에서 반복되는 문자열을 찾거나, 특정 부분의 문자열을 출력하기 위해 사용 해당 부분에 ‘()’로 묶어주면 된다. 12345pattern = r'(\\d&#123;3&#125;)[-./ ]*(\\d&#123;3,4&#125;)[-./ ]*(\\d&#123;4&#125;)'string = '010-1111-2222'm = re.search(pattern, string)m&gt;&gt; &lt;re.Match object; span=(0, 13), match='010-1111-2222'&gt; 매치된 전체 문자열 리턴 12m.group()&gt;&gt; '010-1111-2222' 첫번째 그룹에 해당되는 문자열 리턴 12m.group(1)&gt;&gt; '010' 두번째 그룹에 해당되는 문자열 리턴 12m.group(2)&gt;&gt; '1111' 세번째 그룹에 해당되는 문자열 리턴 12m.group(3)&gt;&gt; '2222' 그룹 범위가 벗어난 경우 에러 12m.group(4)&gt;&gt; IndexError: no such group 그룹핑의 범위는 문자열이 시작된 처음을 1번 그룹으로 한다. ‘(a(b)c)’인 경우, abc 앞에 있는 ‘()’가 처음이고 그 다음이 b에 있는 ‘()’가 된다. 12345678pattern = r'(a(b)c)'string = 'abcde'm = re.search(pattern, string)m&gt;&gt; &lt;re.Match object; span=(0, 3), match='abc'&gt;m.group()&gt;&gt; 'abc' 첫번째 그룹 문자열 리턴 12m.group(1)&gt;&gt; 'abc' 두번째 그룹 문자열 리턴 12m.group(2)&gt;&gt; 'b' 그룹 범위가 벗어난 경우 에러 12m.group(3)&gt;&gt; IndexError: no such group compile 옵션 compile 문을 활용하는 경우, 패턴 객체를 만들고 여러번 재사용이 가능 반복적인 매칭 작업이 필요한 경우에는 패던을 미리 컴파일해서 시간 단축 123p = re.compile(pattern)p.match(string)&gt;&gt; &lt;re.Match object; span=(0, 3), match='abc'&gt; ‘a = 100’이라는 문자열을 group으로 나눴을 때 각각 a, =, 100 출력하기 변수 처음은 문자가 올 수 있지만, 숫자는 올 수 없다.(ex) 1a는 안됨) [a-zA-Z_]로 처음 오는 문자가 숫자가 될 수 없도록 함 \\w*으로 다음 오는 문자가 무엇이든 반복이 얼마가 되든 상관없게 선언 사이에 공백으로 인해 \\s* 할당하는 숫자는 반드시 하나는 와야 하므로 ‘+’를 사용하여 [0-9]+ 선언 1234567891011pattern = r'([a-zA-Z_]\\w*)\\s*=\\s*([0-9]+)'p = re.compile(pattern)m = p.search('a_1 = 100')m.group()&gt;&gt; 'a_1 = 100'm.group(1)&gt;&gt; 'a_1'm.group(2)&gt;&gt; '100'","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.09 Python and CE Study","slug":"190409-PCE-Study","date":"2019-04-08T16:40:02.000Z","updated":"2019-05-06T16:48:48.987Z","comments":true,"path":"2019/04/09/190409-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/09/190409-PCE-Study/","excerpt":"","text":"FOREIGN KEY 해제 테이블 보기 1SHOW TABLES; 테이블 생성 쿼리 보기 12SHOW CREATE TABLE &quot;table_name&quot;;SHOW CREATE TABLE students; FOREIGN KEY 확인 1CONSTRAINT students_ibfk_1 FOREIGN KEY (classID) REFERENCES classes (classID) FOREIGN KEY 해제 테이블 생성 쿼리에서 FOREIGN KEY 앞 값 확인하여 작성 1ALTER TABLE students -&gt; DROP FOREIGN KEY students_ibfk_1; FOREIGN KEY가 해제됐는지 확인 1SHOW CREATE TABLE students; 테이블 인덱스 보기 1SHOW INDEX FROM students; FOREIGN KEY였던 값(classID) 확인 인덱스 제거 1DROP INDEX [index_name]; DROP INDEX classID; 제거되었는지 확인 1SHOW INDEX FROM students; teachers table도 같은 방법으로 FOREIGN KEY 해제 및 INDEX 제거 테이블 제거 1DROP TABLE [table_name]; DROP TABLE classes; classes의 classID를 FOREIGN KEY로 참조하고 있었기 때문에 해제한 후 제거 JOIN 집합론 INNER JOIN과 OUTER JOIN으로 나뉨 OUTER JOIN은 LEFT JOIN, RIGHT JOIN, FULL JOIN으로 나뉨 FULL JOIN은 mySQL이나 MariaDB에서는 지원하지 않으므로, UNION을 통해 구현 TABLE 1과 TABLE 2가 있을 때, 두 TABLE을 가로로 연결하는 것 해당 TABLE의 모든 내용 가져오기 123SELECT * FROM &quot;table_name&quot;;SELECT * FROM students;SELECT * FROM teachers; INNER JOIN - 교집합 첫번째, 두번째 줄에서 COLUMN 앞에 붙은 것은 해당 TABLE의 별칭 INNER JOIN은 DEFAULT 명령어이기 때문에 JOIN만 명시해도 INNER JOIN으로 실행 ON은 JOIN할 조건 ORDER BY는 오름차순으로 정렬 12345SELECT S.studentName, S.score, S.classID,-&gt; T.teacherName, T.subject-&gt; FROM students S INNER JOIN teachers T-&gt; ON S.classID = T.classID-&gt; ORDER BY S.classID LEFT OUTER JOIN - 왼쪽 TABLE 기준 집합 세번째 줄에서 JOIN 명령어를 기준으로 왼쪽에 있는 TABLE 기준으로 JOIN 왼쪽 TABLE의 데이터가 모두 출력 오른쪽 TABLE은 보이지 않으므로 NULL로 표시됨 12345SELECT S.studentName, S.score, S.classID,-&gt; T.teacherName, T.subject-&gt; FROM students S LEFT OUTER JOIN teachers T-&gt; ON S.classID = T.classID-&gt; ORDER BY S.classID; RIGHT OUTER JOIN - 오른쪽 TABLE 기준 집합 세번째 줄에서 JOIN 명령어를 기준으로 오른쪽에 있는 TABLE 기준으로 JOIN 오른쪽 TABLE의 데이터가 모두 출력 왼쪽 TABLE은 보이지 않으므로 NULL로 표시됨 12345SELECT S.studentName, S.score, S.classID,-&gt; T.teacherName, T.subject-&gt; FROM students S RIGHT OUTER JOIN teachers T-&gt; ON S.classID = T.classID-&gt; ORDER BY S.classID; FULL JOIN - 전체 집합 mySQL, MariaDB에서는 지원하지 않으므로, UNION 명령어를 통해 구현 [LEFT OUTER JOIN] UNION [RIGHT OUTER JOIN] 123456789SELECT S.studentName, S.score, S.classID,-&gt; T.teacherName, T.subject-&gt; FROM students S LEFT OUTER JOIN teachers T-&gt; ON S.classID = T.classID-&gt; UNIONSELECT S.studentName, S.score, S.classID,-&gt; T.teacherName, T.subject-&gt; FROM students S RIGHT OUTER JOIN teachers T-&gt; ON S.classID = T.classID; GROUP BY 특정 COLUMN을 그룹화 그룹한 결과에 조건을 거는 HAVING = HAVING은 GROUP BY 명령어 다음으로 선언 평균값(AVG)로 그룹화 하기 이렇게 할 경우, TABLE 내부에 classID 값이 NULL인 결과도 출력됨 123SELECT classID, AVG(score)-&gt; FROM students-&gt; GROUP BY classID; WHERE 조건으로 classID가 NULL이 아닌 값만 출력하게 함 1234SELECT classID, AVG(score)-&gt; FROM students-&gt; WHERE classID IS NOT NULL-&gt; GROUP BY classID; 평균값이 65 초과만 출력하기 이렇게 할 경우, TABLE 내부에 classID 값이 NULL인 결과도 출력됨 1234SELECT classID, AVG(score) AS average-&gt; FROM students-&gt; GROUP BY classID-&gt; HAVING average &gt; 65; WHERE 조건으로 classID가 NULL이 아닌 값만 출력하게 함 12345SELECT classID, AVG(score) AS average-&gt; FROM students-&gt; WHERE classID IS NOT NULL-&gt; GROUP BY classID-&gt; HAVING average &gt; 65; CHAR vs VARCHAR CHAR는 고정 길이 문자열 정보 VARCHAR는 가변 길이 문자열 정보 저장 측면에서 보면 VARCHAR가 장점 문자열 비교 측면 CHAR가 고정 길이 문자열을 사용 주민등록번호와 같이 길이가 일정한 데이터는 CHAR를 사용하는 것이 좋음 이름, 주소 등의 길이가 변할 수 있는 값은 VARCHAR를 사용 INT TINYINT : 1byte SMALLINT : 2bytes INT : 4bytes BIGINT : 8bytes JOIN(M:N) TABLE 생성 - subjects, student_subject PRIMARY KEY를 선언하지 않음 UNIQUE와 NOT NULL이 선언될 경우, PROMARY KEY로 선언됨 12345678CREATE TABLE subjects(-&gt; subjectName CHAR(20) UNIQUE NOT NULL-&gt; roomNum TINYINT NOT NULL);CREATE TABLE student_subject (-&gt; regID SMALLINT AUTO_INCREMENT PRIMARY KEY,-&gt; studentName VARCHAR(20) NOT NULL,-&gt; subjectName VARCHAR(20) NOT NULL); 테이블 구조 보기 12DESC subjects;DESC student_subject; TABLE 데이터 추가 123456789101112131415161718192021INSERT INTO subjects-&gt; (subjectName, roomNum)-&gt; VALUES-&gt; (&apos;math&apos;, 101), (&apos;literature&apos;, 105),-&gt; (&apos;science&apos;, 107), (&apos;english&apos;, 110), (&apos;ethics&apos;, 111);INSERT INTO student_subject-&gt; (studentName, subjectName)-&gt; VALUES-&gt; (&apos;Greg&apos;, &apos;english&apos;),-&gt; ((&apos;Greg&apos;, &apos;ethics&apos;), (&apos;John&apos;, &apos;english&apos;),-&gt; ((&apos;John&apos;, &apos;literature&apos;), (&apos;Mark&apos;, &apos;english&apos;),-&gt; ((&apos;Mark&apos;, &apos;literature&apos;),(&apos;Mark&apos;, &apos;math&apos;),-&gt; ((&apos;James&apos;, &apos;science&apos;), (&apos;Johanna&apos;, &apos;english&apos;),-&gt; ((&apos;Johanna&apos;, &apos;math&apos;), (&apos;Kelly&apos;, &apos;ethics&apos;),-&gt; ((&apos;Sam&apos;, &apos;english&apos;), (&apos;Daniel&apos;, &apos;math&apos;),-&gt; ((&apos;Daniel&apos;, &apos;science&apos;),(&apos;Daniel&apos;, &apos;ethics&apos;),-&gt; ((&apos;Ann&apos;, &apos;math&apos;), (&apos;Kreizig&apos;, &apos;math&apos;),-&gt; ((&apos;Elizabeth&apos;, &apos;literature&apos;),(&apos;Elizabeth&apos;, &apos;ethics&apos;),-&gt; ((&apos;Emilly&apos;, &apos;science&apos;), (&apos;Emilly&apos;, &apos;english&apos;),-&gt; ((&apos;Lily&apos;, &apos;math&apos;); 해당 TABLE의 모든 내용 가져오기(확인) 12SELECT * FROM subjects;SELECT * FROM student_subject; students(TABLE 1), student_subject(TABLE 2), subjects(TABLE 3) - JOIN 123456789101112131415SELECT ST.studentName, ST.score,-&gt; SB.subjectName, SB.roomNum-&gt; FROM students ST INNER JOIN student_subject SS-&gt; ON ST.studentName = SS.studentName-&gt; INNER JOIN subject SB-&gt; ON SS.subjectName = SB.subjectName-&gt; ORDER BY ST.studentName;SELECT SB.subjectName, SB.roomNum,-&gt; ST.studentName, ST.score-&gt; FROM students ST INNER JOIN student_subject SS-&gt; ON ST.studentName = SS.studentName-&gt; INNER JOIN subjects SB-&gt; ON SS.subjectName = SB.subjectName-&gt; ORDER BY SB.subjectName; VIEW view는 select 문일 뿐이지, table이 새로 만들어지는 것은 아니다. 가독성 - 복잡한 쿼리를 단순화해서 사용 가능 보안 - 데이터 접근 제어 가능. 뷰를 통해 접근하기 때문에 뷰에 나타나지 않는 데이터를 보호 VIEW 생성 123456789CREATE VIEW view_st_sb_join-&gt; AS-&gt; SELECT ST.studentName, ST.score,-&gt; SB.subjectName, SB.roomNum-&gt; FROM students ST INNER JOIN student_subject SS-&gt; ON ST.studentName=SS.studentName-&gt; INNER JOIN subjects SB-&gt; ON SS.subjectName=SB.subjectName-&gt; ORDER BY ST.studentName; 생성된 VIEW TABLE 확인 1SHOW TABLES; 테이블 내용 확인 1SELECT * FROM view_st_sb_join; VIEW TABLE도 WHERE을 통해 조건에 맞는 데이터 표시 가능 12SELECT * FROM view_st_sb_join-&gt; WHERE score BETWEEN 50 AND 70; VIEW TABLE 제거 1DROP VIEW view_st_sb_join; 제거되었는지 확인 1SHOW TABLES; INDEX 빠른 데이터 검색을 위함(Search) 검색 속도가 빠르지만, 데이터의 수정 및 삽입이 많아지면 성능이 현저하게 떨어짐(page 분할) Clustered Index와 Secondary Index로 나뉨 Clustered Index 한 테이블에 하나씩만 가질 수 있음 데이터 자체를 clustered index에 맞춰서 정렬 PRIMARY KEY = clustered index PRIMARY KEY가 없는 경우, NOT NULL 옵션의 UNIQUE 인덱스가 PRIMARY KEY가 됨 Secondary Index 원하는 만큼 가질 수 있음 B-Tree라는 자료구조를 만들어 실제 데이터가 저장되어 있는 테이블에서 참조 Where을 자주 쓰는 상황일 때 CREATE INDEX 명령어는 Secondary Index만 만들 수 있다. Clustered Index의 수정은 ALTER TABLE 명령어를 사용해야 한다. “AUTO_INCREMENT”가 있는 PRIMARY KEY인 경우, DROP할 수 없다. MODIFY 명령어로 다시 Field 속성을 변경하여 DROP해야 한다. 인덱스 생성 1234567891011121314CREATE TABLE idx1 (-&gt; id INT PRIMARY KEY,-&gt; data1 INT,-&gt; data2 INT);CREATE TABLE idx2 (-&gt; id INT PRIMARY KEY,-&gt; data1 INT UNIQUE,-&gt; data2 INT);CREATE TABLE idx3 (-&gt; a INT UNIQUE NOT NULL,-&gt; b INT UNIQUE,-&gt; c INT); 인덱스 확인 123SHOW INDEX FROM idx1;SHOW INDEX FROM idx2;SHOW INDEX FROM idx3; 테이블 목록 확인 1SHOW TABLES; 인덱스 제거 1DROP TABLE idx1, idx2, idx3; PRIMARY KEY 해제 및 등록 12ALTER TABLE students-&gt; DROP PRIMARY KEY; 만약 PROMARY KEY가 등록된 COLUMN이 AUTO_INCREMENT 옵션을 가지고 있는 경우 MODIFY를 통해 Field 속성을 변경해주어야 한다. 12ALTER TABLE students-&gt; MODIFY COLUMN studentID INT NOT NULL; 변경된 field 속성 확인 1DESC students; 인덱스 확인 1SHOW INDEX FROM students; primary key 등록 123ALTER TABLE students-&gt; ADD CONSTRAINT-&gt; PRIMARY KEY(studentName); CONSTARAINT의 이름 지정도 가능 123ALTER TABLE students-&gt; ADD CONSTRAINT pk_st_studentName-&gt; PRIMARY KEY(studentName); 테이블 정보 확인 1SHOW CREATE TABLE students; 인덱스 정보 확인 1SHOW INDEX FROM students;","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.08 Python and CE Study","slug":"190408-PCE-Study","date":"2019-04-07T16:39:57.000Z","updated":"2019-05-06T16:44:11.610Z","comments":true,"path":"2019/04/08/190408-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/08/190408-PCE-Study/","excerpt":"","text":"Database 관계형 데이터 집합론 객체 - table, view, index table schema(외부, 내부, 물리) entity, relation 행 : column, field 열 : tuple, row, record 제약 조건(Constraint) 테이블에 부적절한 자료가 입력되는 것을 방지하기 위해 규칙을 적용하는 것 NOT NULL : 꼭 데이터를 입력해야 함 ex) 아이디, 이름, 생일 등등 UNIQUE : 데이터가 중복되는 것을 막음 ex) 아이디 PRIMARY KEY : 테이블에서 단 하나. 이 것을 기준으로 데이터 정렬 FOREIGN KEY : 테이블에서 다른 테이블의 칼럼을 참조할 때 사용(PRIMARY KEY 참조) utf8mb4 utf8의 경우 1글자당 3bytes를 사용 4bytes의 이모티콘을 표현할 수 없음 확장된 utf8mb4를 사용하게 됨 1글자 당 4bytes 사용 INT = 4bytes SMALLINT = 2bytes String = CHAR, VARCHAR, TEXT mysql의 경우, 대소문자를 구분하지 않지만 대문자를 쓰도록 한다. typing error가 났을 경우 \\c를 통해 빠져나온다. ‘로 시작했을 경우, ‘로 닫아주고 다시 \\c로 빠져나온다. mysql server와 연결 1$ sudo mysql -u root 유저 생성 123CREATE USER [username]@[IP] INDENTIFIED BY [password];# sudo mysql -u jinwook -p 및 password 입력 후 mysql server와 연결 유저에게 사용자의 권한 제어 및 모든 테이블에 모든 권한 부여 및 적용 1GRANT ALL PRIVILEGES ON *.* TO [username]@&apos;%&apos; WITH GRANT OPTION; FLUSH PRIVILEGES; 생성된 데이터베이스 목록을 보여줌 1SHOW DATABASES; 데이터베이스 생성 1CREATE DATABASE [database_name] DEFAULT CHARACTER SET utf8mb4; 데이터베이스 제거 1DROP DATABASE [database_name] “classes” 테이블 생성 AUTO_INCREMENT : record의 값이 중복되지 않고 1씩 자동 증가 123CREATE TABLE classes (-&gt; classID INT AUTO_INCREMENT NOT NULL PRIMARY KEY,-&gt; num_students INT NOT NULL); “students” 테이블 생성 FOREIGN KEY는 classes의 classID 참조 12345678CREATE TABLE students (-&gt; studentID INT AUTO_INCREMNT NOT NULL PRIMARY KEY,-&gt; studentName VARCHAR(20) NOT NULL,-&gt; height SMALLINT DEFAULT 200,-&gt; score SMALLINT NULL,-&gt; birthday DATE NOT NULL,-&gt; classID INT NULL,-&gt; FOREIGN KEY (classID) REFERENCES classes (classID)); “teachers” 테이블 생성 PRIMARY KEY를 뒤에서 지정 123456CREATE TABLE teachers (-&gt; teacherID INT AUTO_INCREMENT NOT NULL,-&gt; subject VARCHAR(30) UNIQUE,-&gt; classID INT NULL,-&gt; PRIMARY KEY(teacherID),-&gt; FOREIGN KEY (clastsID) REFERENCES classes (classID)); “classes” 테이블의 num_students에 데이터 추가 123456INSERT INTO classes-&gt; (num_students)-&gt; VALUES-&gt; (4),-&gt; (3),-&gt; (3); 같은 방법으로 “students” 테이블에 데이터 추가 12345678910111213INSERT INTO students-&gt; (studentName, height, score, birthday, classID)-&gt; VALUES-&gt; (&apos;Greg&apos;, 180, 87, &apos;2002-3-23&apos;, 1)-&gt; (&apos;John&apos;, 175, 95, &apos;2002-4-2&apos;, 2),-&gt; (&apos;Mark&apos;, 178, 50, &apos;2002-5-12&apos;, 1),-&gt; (&apos;James&apos;, 170, 56, &apos;2002-7-14&apos;, 3),-&gt; (&apos;Johanna&apos;, 165, 90, &apos;2001-9-23&apos;, 1),-&gt; (&apos;Mary&apos;, 160, 50, &apos;2002-1-5&apos;, 2),-&gt; (&apos;Kelly&apos;, 176, 80, &apos;2002-9-17&apos;, 3),-&gt; (&apos;Sam&apos;, 172, 78, &apos;2002-6-5&apos;, 1),-&gt; (&apos;Daniel&apos;, 187, 90, &apos;2002-12-1&apos;, 2),-&gt; (&apos;Ann&apos;, 165, 46, &apos;2002-9-18&apos;, 3); ALTER 명령어를 통해 “teachers” 테이블에 column 항목 추가 123ALTER TABLE teachers-&gt; ADD COLUMN-&gt; teacherName VARCHAR(20) NOT NULL AFTER teacherID; 같은 방법으로 “teachers” 테이블에 데이터 추가 123456INSERT INTO teachers-&gt; (teacherName, subject, classID)-&gt; VALUES-&gt; (&apos;yang&apos;, &apos;math&apos;, 1),-&gt; (&apos;park&apos;, &apos;literature&apos;, 2),-&gt; (&apos;lee&apos;, &apos;science&apos;, 3); 데이터베이스 백업 1mysqldump -u [username] -p --databases [database_name] &gt; [save_filename.sql] 데이터베이스 복원 mysql -u [username]] -p로 연결 mariaDB [(none)]&gt; source [save_filename.sql] 실행 테이블 구조 확인 1DESC [table_name] 테이블 컬럼 속성 변경 12ALTER TABLE students-&gt; MODIFY COLUMN height SMALLINT NULL; 데이터 추가 테이블 컬럼 값을 모두 추가하지 않아도 기본값으로 NULL 값 추가 1234INSERT INTO students-&gt; (studentName, height, score, birthday)-&gt; VALUES (&apos;Kreizig&apos;, 175, 75, &apos;2002-9-19&apos;),-&gt; (&apos;Elizabeth&apos;, 165, 80, &apos;2003-1-17&apos;); 데이터베이스 복사 괄호로 묶은 문법이 바로 subquery 12CREATE TABLE student_cp-&gt; (SELECT * FROM students); 테이블 데이터 제거 %eiz%는 eiz가 포함되어있는 데이터를 지움 123456DELETE FROM student_cp-&gt; WHERE studentName like &apos;%eiz%&apos;;또는TRUNCATE TABLE student_cp; 데이터의 이름이 정확하게 기억나지 않는 경우, %나 , _를 통해 검색 가능 1SELECT [column_name] FROM [table\\_name] WHERE [column\\_name] LIKE [특정문자열%] AND도 사용 가능 123INSERT INTO student_cp-&gt; (SELECT * FROM students WHERE birthday-&gt; BETWEEN &apos;2002-5-1&apos; AND &apos;2002-9-10&apos;); 테이블 제거 1DROP TABLE student_cp; DDL and DML and DCL DDL(Data Definition Language) 데이터 정의어 데이터 구조를 정의하는데 사용되는 명령어 CREATE, ALTER, DROP, RENAME, TRUNCATE DML(Data Manipulation Language) 데이터 조작어 데이터베이스에 들어있는 데이터를 조회하거나 변형을 가하는 명령어 SELECT, INSERT, UPDATE, DELETE DCL(Data Control Language) 데이터 제어어 데이터베이스에 접근하고 객체들을 사용하도록 권한을 주고 회수하는 명령어 GRANT, REVOKE session and transactionsession sudo mysql -u root 실행 = mysql server로 연결 = TCP connection = session transaction mysql server로 연결되는 client가 여러 군데인 상황이라면… 하나의 table에 여러 client가 접근하게 됨 table은 공유 자원(shard resource)가 됨 은행 계좌 시스템(예시) client 1 계좌에서 client 2 계좌로 10000원을 송금한다고 하자. client 1 계좌에서 10000원을 감산하는 처리 client 2 계좌에서는 10000원을 가산하는 처리 그런데 client 2의 계좌에서 10000원을 가산하는 과정에서 오류가 발생한다면? 가산 처리 과정은 이루어지지 않은 채, 감산 처리 과정만 일어나게 됨 이러한 상황 때문에 감산과 가산의 과정을 하나의 처리로 취급한다면? 가산이 실패하면 감산도 취소하도록 함 이렇게 여러 단계의 처리를 하나의 처리처럼 다루는 기능을 Transaction이라 한다. Transaction이 서버에서 진행 중인 경우, 외부 세션에서는 아직 변경한 데이터가 보이지 않는다. Transaction 상태에서는 작업 중인 영역이 LOCK 상태가 된다. commit을 진행할 때에는 반드시 다른 개발자들에게 알려야 한다. DML은 자동으로 commit이 되지 않고, DDL은 자동으로 commit이 된다. DML 명령어는 사용 후… commit이라는 명령어를 통해 Transaction을 끝내면 데이터 상태를 최종 변경 commit을 하기 전에 rollback 명령어를 통해 변경 전의 데이터 상태로 돌아가고 Transaction을 종료 가능 DDL은 Transaction의 개념이 없기 때문에 명령어를 사용하는 데 있어서 주의해야 한다. AUTOCOMMIT 여부를 확인 1SELECT @@AUTOCOMMIT; AUTOCOMMIT 해제 1SET AUTOCOMMIT = FALSE","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.05 Python and CE Study","slug":"190405-PCE-Study","date":"2019-04-04T16:15:37.000Z","updated":"2019-05-06T16:38:29.027Z","comments":true,"path":"2019/04/05/190405-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/05/190405-PCE-Study/","excerpt":"","text":"TCP Socket Coding TCP socket - server 12345678import socketserv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)serv.bind(('localhost', 3030))serv.listen()data_sock, clnt_addr = serv.accept()data = data_sock.recv(1024)data socket 클래스를 생성한다. AF_INET는 IPv4를, SOCK_STREAM은 TCP 방식을 의미한다. bind() 메소드를 통해 IP와 port를 지정해준다. 이 때 localhost는 127.0.0.1을 의미한다. listen() 메소드를 통해 client가 접속하는 것을 기다린다. 연결이 되면 accept() 메소드를 통해 데이터 통신용 소켓인 data_sock와 client의 주소 clnt_addr로 받는다. data_sock.recv()를 통해 데이터를 받을 수 있다. TCP socket - client 12345import socketclnt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)clnt.connect(('localhost', 3030))clnt.send('I am your father'.encode()) server socket과 마찬가지로 같은 방식으로 socket 클래스를 생성한다. connect() 메소드를 이용하여 server와 같은 IP와 port를 지정한다. send() 메소드를 이용하여 데이터를 송신한다. server 쪽에서 데이터 통신용 소켓인 data_sock를 통해 send(), recv() 모두 가능하다. client 쪽에서도 send(), recv() 모두 가능하다. close()를 통해 연결을 종료힌다. server는 serv와 data_sock 둘다 close 해야 한다. client에서 connect만 하여도 되는 이유 OS가 자동적으로 IP(client의 host)와 port(ramdom)를 할당 connect() 메소드의 반환시점은 sever의 request Queue에 등록이 될 때 enqueue를 할 때 server와 다수의 client인 경우 server 쪽에서는 data_sock을 request Queue를 만들어 저장 이 때, accept() 메소드에서 blocking이 걸림 다른 데이터 소켓들은 데이터를 주고 받아야 하기 때문에 concurrency programming을 해야 함 concurrency programming Multithreading, Multiprocessing 사용 - database는 아직도 multithreading 사용중 I/O Multiplexing - select, event-driven linux에서의 epoll, window에서의 IOCP TCP 헤더 Source Port(송신) : 2bytes Destination Port(수신) : 2bytes Sequence Number : 4bytes 이번에 보내는 데이터의 첫번째 바이트 순서 번호 Acknowledgement Number : 4bytes 수신하기를 기대하는 다음 바이트 번호 마지막 수신 성공 순서번호 + 1 Window : 2bytes 상대편에게 자신의 버퍼 여유용량 크기를 지속적으로 통보하여 주는 기능 데이터의 흐름을 컨트롤(flow control) Sliding Window TCP connection이 되면 server와 client의 TCB에 TCP 연결 처리에 필요한 정보가 들어있다. TCB(Transmission Control Block) server TCB 예시 server의 IP와 port send buffer pointer UNA 송신했지만, 아직 승인되지 않은 첫 번째 데이터의 순서번호 Send Unacknowledged NXT 다음 차례의 sequence number WND 송신 윈도우 크기 receive buffer pointer NXT 다음 차례에 받을 client(상대 host) sequence number WND 수신 윈도우 크기 client TCB 예시 client의 IP와 port send buffer pointer - UNA, NXT, WND receive buffer pointer - NXT, WND 여기서 수신 WND와 송신 WND의 크기는 같아야 한다. 그리고 송신 WND의 크기가 주체가 된다. 여기서 윈도우 크기는 수신 window 크기가 주체가 된다. 받는 쪽이 먼저 크기를 알려줘야 송신이 그 크기로 보내기 때문이다. 윈도우 크기로 데이터의 흐름을 컨트롤한다.(flow control) send window TCP 특성 상 데이터를 보내고 응답을 기다릴때까지 다음 데이터를 못보낸다. 데이터를 주고 받는데 있어서 느릴 수 있다. 그래서 send window 안에 usable window 개념이 있다. send window 안에 다음과 같은 데이터 존재 송신했으나 응답을 받지 못한 데이터(SENT + NOT ACK) 아직 송신하지 않고 대기 중인 데이터(NOT SENT + READY) 응답 받지 못한 데이터가 있더라도 보낼 수 있다. SND.NXT와 RCV.NXT는 데이터를 주고 받을 때 값이 업데이트된다. SND.UNA 경우, 수신 측에서 응답(ACK)을 받기 전까지는 절대 값이 업데이트되지 않는다. 응답을 받으면 그 때 SND.UNA 값이 업데이트되면서 정해진 윈도우 크기가 옆으로 이동하게 된다. 이렇게 윈도우 크기가 옆으로 이동하는 것을 슬라이딩 윈도우라고 한다. TCP 약점(예시) send window 안에 데이터가 9byte가 있음 4byte를 먼저 보내고 5byte를 나중에 보냄 Routing table이 변하여 처음 4byte를 보냈을 때보다 나중에 보낸 5byte가 먼저 도착 이 때 4byte가 도착하지 못하고 유실된 경우 5byte가 도착했다하더라도 다시 4byte의 데이터부터 다시 보내게 된다. UDP(User Datagram Protocol) 비 연결 지향형 프로토콜 신뢰할 수 없다. 데이터를 재전송하지 않는다. 전송된 데이터 일부가 손실될 수 있다. 동영상 및 게임 쪽에 사용 UDP Socket Coding UDP socket - server 12345import socketserv = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)serv = bind(('localhost', 3030))data_sock, clnt_addr = serv.recvfrom(1024) SOCK_DGRAM은 UDP 방식을 의미한다. bind() 메소드를 통해 IP와 port를 지정해준다. serv.recvfrom()를 통해 데이터를 받을 수 있다. UDP socket - client 12345import socketclnt = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)serv_addr = ('localhost', 3030)clnt.sendto('I am your father!'.encode(), serv_addr) 마찬가지로 같은 SOCK_DGRAM으로 생성한다. sendto() 메소드를 이용하여 데이터를 송신한다. server와 client 둘 다 sendto(), recvfrom() 메소드를 통해 데이터를 주고 받을 수 있다. 신뢰성을 보장하지 않는다. UDP 헤더 Source Port(송신) : 2bytes Destination Port(수신) : 2bytes length : 2bytes. UDP 헤더와 데이터 필드를 모두 포함한 전체 패킷의 길이 응용 계층 FTP 파일 전송을 위한 프로토콜로 보안이 취약 DNS(Domain Name System) 도메인 이름을 IP 주소로 변환하는 프로토콜 1$ nslookup [도메인 이름] # 명령어를 통해 IP를 알 수 있음 ex) www.google.com DNS server가 뒤에서부터 com, google, www server를 통해 주소를 찾아낸다. 한번 연결된 주소는 DNS 캐시에 남긴다. 12345ex) https://www.naver.com&gt;&gt; https : schema&gt;&gt; www : host&gt;&gt; naver.com : Domain Name HTTP(HyperText Transfer Protocol) 웹에서 데이터를 주고 받을 수 있는 프로토콜 HTTP/1.0 - 일시적 연결 0.9 ~ 1.0까지 client와 server 간에 하나하나 데이터를 주고 받을 때마다 TCP를 연결하고 종료한다. HTTP/1.1 - 지속적 연결(Keep Alive Connection[persistent connection]) 1.1부터는 TCP 연결을 닫지 않지 않고 그대로 유지 한다. Connection: Close 헤더를 포함해 일시적 연결을 할 수 있다. 캐싱 clientr가 첫 요청한 데이터를 저장 재 요청시 내부에 저장해둔 파일을 사용하여 더 빠르게 서비스하기 위함 프록싱 client와 server 사이에 위치 사용자가 데이터를 요청했을 때, 프록시 서버로 요청 프록시 서버는 해당 웹 서버로 가서 데이터를 주고 받음 다시 프록시 서버를 통해 사용자에게 데이터를 가져오게 됨 프록시 서버는 요청된 내용들을 캐시를 이용하여 저장 캐시 안에 저장된 정보를 요구하는 요청에 대해 해당 서버에 접속하여 가져올 필요가 없음 전송 시간을 절약할 수 있음(네트워크 병목 현상을 줄임) 모든 데이터가 프록시 서버를 거치게 되므로 방화벽 역할 HTTP request header 구조 컨텐트 협상 Accept로 시작하는 헤더는 컨텐츠 협상에 해당 서버 주도 협상 항상 원하는 형식의 데이터를 받을 수 없음 에이전트 주도 협상 원하는 데이터를 받을 수 있음 자료 접근으로 두번의 요청과 응답이 필요함 123ex) Accept-Language : kr;q=0.7, fr;q=0, en;q=0.4&gt;&gt; q 값을 다르게 줌으로써 가져오는 사이트의 언어를 결정한다.(0.7 = 70%) Method GET 요청받은 URL의 정보를 검색하기 위해 서버 측에 요청 SELECT의 성격 POST 요청한 URL에 폼(form) 입력을 처리하기 위함 폼(form)과 함께 전송 헤더 정보에 포함되지 않고 데이터 부분에 요청 정보가 들어감 INSERT의 성격 HEAD GET 방식과 동일하나, 헤더 정보 이외에는 어떤 데이터도 보내지 않음 웹서버 정보확인, 버젼확인, 최종 수정일자 확인 등의 용도로 사용 PUT POST와 유사한 전송 구조를 가짐 헤더 이외에 메시지(데이터)가 함께 전송 UPDATE의 성격 PUT vs PATCH PUT은 항상 모든 필드 값을 바꾸지만, PATCH는 해당하는 필드 부분만 바꿈 DELETE 요청된 소스를 삭제할 것은 요청 TRACE 서버에 루프백 메세지를 호출하기 위해 사용 HTTP response header 구조 상태 코드 1xx : 정보 2xx : 성공 3xx : 리다이렉션 4xx : 클라이언트 오류 5xx : 서버 오류 청킹(chunking) Content-Length response header에 정의 요청한 내용에 대한 실제적인 결과인 body의 길이가 몇 bytes인가를 의미 즉, 읽어야 할 body의 크기를 알려줄 때 사용 Transfer-Encoding: chunked 덩어리(Chunk)의 나열로 데이터를 전송하는 HTTP 1.1 데이터 전송 방법 중 하나 동적으로 생성한 콘텐츠인 경우, 전체보다 덩어리 단위로 쪼개서 보냄 따라서 전체 콘텐츠의 크기를 알려주지 않아도 됨","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.04 Python and CE Study","slug":"190404-PCE-Study","date":"2019-04-03T16:15:33.000Z","updated":"2019-05-06T16:39:05.651Z","comments":true,"path":"2019/04/04/190404-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/04/190404-PCE-Study/","excerpt":"","text":"IP Routing 출발지(Host)에서 목적지(원하는 사이트의 ip)까지 어떤 홉(hop)들을 거쳐갈 것인지를 선택하는 것 홉(hop) 데이터 통신망에서 각 패킷이 라우터를 건너가는 모습 가능성 있는 모든 경로들에 대한 정보 수집 후, 라우팅 테이블(Routing Table)에 기록함 최적 경로, 시간, 거리, 비용 등 다양한 조건에 의한 최적 경로 라우팅 테이블(Routing Table) 최적의 경로를 저장해놓은 테이블 라우팅 테이블이 없으면 데이터를 전송할 수 없다. 인터넷이 안된다면… Router(ex iptime)가 안될 경우 NIC 즉, 랜카드가 안될 경우 OS 자체 내에서 TCP/IP 4계층 동작이 안될 경우 localhost(127.0.0.1)를 통해 loopback하여 OS 자체 내 문제 확인 packet을 날려서 잘돌아오는지 확인 NIC 하고는 상관없는 동작 전송 계층(Transport Layer)TCP vs UDP TCP(Transmission Control Protocol) 연결 지향형 프로토콜 높은 신뢰성 수신 호스트를 체크 수신 호스트가 응답하지 않을 경우, 일정 시간 후 데이터를 재전송 소켓쌍(ex (source IP, source port), (dst IP, dst port))으로 연결 식별 커널 영역에 send buffer와 receive buffer로 동작 수행 TCB(Transmission Control Block) TCP 연결 처리에 필요한 정보가 있다. connection state(LISTEN, ESTABLISHED, TIME_WAIT 등) receive window congestion window sequence 번호 재전송 타이머 등 3-Way Handshaking 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장한다. 1client &lt;------------&gt; server client가 처음으로 SYN(Synchronize)를 보낸다. sequence number는 ISN(Initial Sequence Number) 보낸 후, 응답을 기다리는 SYN_SENT 상태가 된다. server는 client에게 요청을 수락한다는 ACK(Acknowledgment)와 SYN를 발송한다. ACK는 SYN에 +1을 한 것 client가 다시 응답하기는 기다리는 SYN_RECEIVED 상태가 된다. client는 다시 server에게 ACK를 보내고 이후부터는 연결이 이루어진다. client와 server 모두 ESTABLISHED 상태가 된다. 4-Way Handshaking 연결을 종료하기 위해 수행되는 절차 1client &lt;------------&gt; server client가 연결을 종료하겠다는 FIN(Finish)을 보낸다. 이 때 client는 더 이상 send를 할 수 없고, received만 하는 상태가 된다. client는 FIN-WAIT1 상태가 된다. server는 ACK를 보내고 application이 끝날 때까지 기다린다. server는 CLOSE_WAIT 상태가 된다.(TIME_WAIT) client는 server의 FIN을 기다리는 FIN-WAIT2 상태가 된다. application이 끝나면 server는 FIN을 client로 보낸다. server는 client의 ACK를 기다리며 LAST_ACK 상태가 된다. client는 ACK를 보낸 뒤에 TIME_WAIT 상태가 된다. 이 때 보낸 client는 server로부터 받지 못한 데이터가 있을 수 있다. 그럴 경우를 대비해 MSL(Maximum Segment Lifetime)의 두 배의 시간을 기다린다.(defalut : 240s) 그리고 CLOSE 1234567- SYN(Synchronization) : 동기화. 연결 요청 플래그- ACK(Acknowledgement) : 응답- FIN(Finish) : 연결 종료 요청- MSL(Maximum Segment Lifetime) : 최대 세그먼트 수명, 주로 2분. UDP(User Datagram Protocol) 낮은 신뢰성 packet을 보내고 받았는지 체크를 하지 않음 스트리밍 서비스에 이용","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.03 Python and CE Study","slug":"190403-PCE-Study","date":"2019-04-02T16:15:29.000Z","updated":"2019-05-06T16:28:37.406Z","comments":true,"path":"2019/04/03/190403-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/03/190403-PCE-Study/","excerpt":"","text":"git 특강 git란? VCS(Version Control System) == SCM(Source Code Management: 형상관리) 빠른 속도, 단순한 구조 수정내용은 commit 단위로 관리 모든 파일이 Blob이라는 단위로 구성 파일에 대한 정보들을 모은 것이 commit source + history = commit =&gt; blob + label = commit commit들을 나열하는게 Tree 인터넷이 연결되지 않아도 개발 가능 내 정보 작성(git config list) git 관리를 위한 디렉토리를 만든 후, global config list 작성 유저 작성 1$ git config --global user.name [유저 이름] 유저 이메일 작성 1$ git config --global user.email [유저 이메일] 작성된 리스트 보기 1$ git config --list git 명령어 해당 디렉토리에서 git 저장소를 만듦 github 사이트에서도 해당 디렉토리와 이름이 같은 프로젝트 생성 해당 디렉토리와 이름을 같게 하는 이유는 헷갈리지 않기 위함 123$ git init# 반드시 관리하기 위해 만들어두었던 디렉토리에서 명령어 실행# 그렇지 않고 다른 디렉토리에 했다면 ls -al 통해 확인 후, rm -rf .git로 지우기 가능 주소 별명 지정 1$ git remote add [주소 별명] [내 github 디렉토리 주소] 주소 별명의 url 확인 1$ git remote get-url [주소 별명] 주소 별명 제거 1$ git remote remove [주소 별명] 현재 파일의 commit 진행 상황 확인 1$ git status git init를 진행한 디렉토리 안에서 원하는 소스 파일 생성 vim으로 작업한 후, 저장 소스 파일이 잘 실행되는지 확인 git status를 통해 파일의 현재 커밋 상황 확인 add 명령어를 통해 workspace에 저장해둔 소스 파일을 stage 위로 올림 1$ git add [소스 파일] commit 작성 1234567891011$ git commit# vim 진입# 첫 줄은 해당 소스 파일 작업에 대해 요약 ex) feat: add hello.py# 요약할 때에는 첫 줄만 봐도 파악될 수 있게 정리# 밑에 줄 부터는 무엇을 수정했는지 서술# 영어로 서술하도록 한다. 끝나면 저장하고 나온 후, git status를 통해 진행 상황 확인 이 지점에서 다시 수정해서 local repository에 계속 축적 대기시킬 수 있음 git remote repositorry에 추가 12345$ git push -u [주소 별명] master# 처음만 -u를 통해 명령어 입력# -u를 입력하여 master 브랜치를 맞춰줌 리스트나 딕셔너리의 컬렉션 자료형을 쓸 때에는 인덱스를 세로로 명시하는 것이 좋다. 또한 마지막 인덱스에는 콤마를 붙여서 끝내는 것이 좋다.(아무 문제 없다.) 그래야 commit을 했을 때 수정한 부분이 명확하게 보인다. Computer EngineeringNetwork OSI 7계층 응용 계층(Application Layer) - FTP, HTTP, SSH 표현 계층(Presentation Layer) 세션 계층(Session Layer) 전송 계층(Transport Layer) - TCP, UDP 네트워크 계층(Network Layer) - IP 데이터 링크 계층(Data Link Layer) - Ethernet 물리 계층(Physical Layer) TCP/IP 4계층 Application - 응용 계층, 표현 계층, 세션 계층 Transport - 전송 계층 Internet - 네트워크 계층 Network Interface - 데이터 링크 계층, 물리 계층 물리 계층 Lan cable(CAT5, UTP(Unshielded Twisted Pair), RJ-45(커넥터)) Repeater : 거리가 멀어지면 노이즈가 생겨 약해진 신호를 증폭 데이터 링크 계층 NIC(Network Interface Card) : 랜 카드. 네티워크 어댑터 MAC(Media Access Control) : NIC의 하드웨어 주소 1234ex) 40 - 49 - 0F - 80 - C3 - 2F&gt;&gt; 40 - 49 - 0F = 제조사&gt;&gt; 80 - C3 - 2F = NIC 번호 라우터를 기준으로 같은 공간에 있다면 LAN(Local Area Network) MAC Address는 LAN에서 컴퓨터 주소를 찾을 때만 사용 Destination MAC Address : 6 bytes, 패킷 수신 NIC Source Mac Address : 6 bytes, 패킷 송신 NIC MTU(Maximum Transmission unit) [최대 전송 단위] : 1500 bytes 실제적으로는 조금 더 작음 네트워크 계층 ARP(Address Resolution Protocol) 브로드캐스트로 어떤 IP를 사용하는 호스트의 MAC 주소를 알아냄 123456789101112131415161718host1 : 192.168.100.18host2 : 192.168.100.63host1에서 host2로 정보를 보내고 싶을 때...1. 브로드캐스트를 해서 내가 보내고자 하는 IP 주소 즉, host2의 IP 주소를 알아낸다.2. host2가 request로 본인의 IP 주소와 MAC 주소를 보낸다.3. 그 때 host2로 원하는 정보를 전송 가능하다.- ARP Cache를 통해 MAC 주소를 저장해둠(ARP Table)- ARP Request : 192.168.100.63은 누구인가?- ARP Reply : 내가 192.168.100.63이고 MAC 주소는 이거다.이러한 과정을 ARP라고 한다. RARP(Reverse Address Resolution Protocol) 역순 주소 결정 프로토콜 ARP와는 반대로 MAC 주소를 가지고 IP 주소를 알아냄 지금은 거의 사라진 개념 DHCP(Dynamic Host Configuration Protocol) 동적 호스트 구성 프로토콜 IP 주소들을 동적으로 할당할 수 있으며 더이상 사용되지 않는 경우 회수함 IP TTL(Time To Live) 데이터의 유효 기간을 나타내기 위한 방법 몇 개의 라우터를 지나면 패킷을 버릴 것인지를 나타냄 ex) ttl = 55 &lt;- 55번 지나면 사라짐 Source Address : 4bytes, 송신 IP Destination Address : 4bytes, 수신 IP 1[1byte] [1byte] [1byte] [1byte] = 4bytes 1byte에 0 ~ 255 Network 주소 = 라우터를 찾는 주소 Host 주소 = LAN에 소속되있는 특정 Host(컴퓨터) IPv4, IPv6 클래스 단위 주소 지정 1class A = [Network ID] [Host ID] [Host ID] [Host ID] Network ID =&gt; 0000 0000 ~ 0111 1111(0 ~ 127) 네트워크 주소는 0과 127을 제외한 126개 사용 호스트 주소는 네트워크 주소 당 “0”과 “1”을 제외한 2^24 - 2 = 16,777,214개 사용 1class B = [Network ID] [Network ID] [Host ID] [Host ID] Network ID =&gt; 1000 0000 ~ 1011 1111(128 ~ 191) 네트워크 주소는 2^14 - 2 = 16,282개 사용 호스트 주소는 네트워크 주소 당 2^16 - 2 = 65534개 사용 1class C = [Network ID] [Network ID] [Network ID] [Host ID] Network ID =&gt; 1100 0000 ~ 1101 1111(192 ~ 223) 네트워크 주소는 2^21 - 2 = 2,097,150개 사용 호스트 주소는 네트워크 주소 당 2^8 - 2 = 254개 사용 0은 네트워크 주소 자기자신이고, 255는 브로드캐스트용 주소 IP 서브넷 주소 지정 12345678910111213ex) IP address : 201.175.122.74 =&gt; class CSubnet mask : 255.255.255.192&gt;&gt; (11111111 . 11111111 . 11111111) . (11)(000000)&gt;&gt; (Network ID) (Subnet ID) (Host ID)IP Address &amp; Subnet mask(AND 연산 수행)11001001.10101111.01111010.01001010 -&gt; IP 주소11111111.11111111.11111111.11000000 -&gt; Subnet 주소-------------------------------------11001001.10101111.01111010.01000000 -&gt; 결과 1byte = 255에서는 AND 연산을 수행했을 때 모두 그대로 나오게 된다. 서브넷 마스크 주소가 255.255.255.0이라면… 앞 3bytes는 그대로 주소가 나옴 네트워크 주소는 24개 호스트 주소로 253개 사용 가능 서브넷 마스크 주소가 255.255.255.192라면… 앞 3bytes는 그대로 주소가 나옴 추가로 마지막 byte 자리에서 첫번째와 두번째 자리까지 연산을 수행 네트워크 주소는 26개 호스트 주소로 나머지 자리의 2^6 -2 = 62개 사용 가능 표현 방식 = 201.175.122.74/26 Public IP(공인 IP 주소) vs Private IP(사설 IP 주소) 공인 IP 주소는 유일하기 때문에 주소로 바로 접근이 가능하다. 사설 IP 주소는 반드시 NAT를 통해 접근해야 한다. 하나의 공인 IP 주소를 라우터에 할당하고 사설 IP Network를 구성하여 공인 IP 주소를 공유 1234567ex) 211.57.44.2(Public) =&gt; 192.168.0.1(Private) =&gt; 192.168.0.2(Host1) 192.168.0.4(Host2) 192.168.0.11(Host3) 192.168.0.16(Host4) NAT(Network Address Translation) 사설 IP 네트워크에서 192.168.0.2의 Host가 Router 바깥에 있는 서버에 접근할 때… 라우터가 이 Host에게 123.108.157.1(공인 IP 주소의 예)를 만들어줌 바깥 서버와 정보를 주고 받을 수 있게 해줌 바깥 서버는 라우터 안에 있는 Host와 정보를 주고 받을 때… 라우터가 이 Host에게 부여해준 123.108.157.1의 주소로 정보를 주고 받을 수 있다. NAPT(Network Address Port Translation) NAT에 포트 개념이 추가됨 사설 IP와 라우터가 부여하는 공인 IP 뒤에 포트를 추가하여 정보를 주고 받음 ex) 192.168.0.2:6000 &lt;- 6000이 포트 port란? socket에 할당된 주소 2bytes로 이루어져있으며, 0 ~ 1023은 특정 서비스 포트 의미 포트 포워딩(port forwarding) 하나의 IP 주소와 포트 번호 결합의 통신 요청을 다른 곳으로 넘겨주는 네트워크 주소 변환(NAT)의 응용 전송 계층 Port : 소켓에 할당된 주소로, 특정 프로세스로 데이터를 전달할 수 있다. well-known port 0 ~ 1023 (server) FTP(20), SSH(22), HTTP(80), HTTPS(443)… dynamic port 49152 ~ 65535 (client)","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.02 Python and CE Study","slug":"190402-PCE-Study","date":"2019-04-01T16:15:25.000Z","updated":"2019-05-06T16:24:47.109Z","comments":true,"path":"2019/04/02/190402-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/02/190402-PCE-Study/","excerpt":"","text":"linux에 대해 Basic “-“가 붙으면 옵션 ex) -l, -r, -m, -s, -i… “..”은 상위 폴더 ex) cd .. “~”는 user의 최상단 폴더로 진입. user 폴더의 절대 경로 “.”은 현재 폴더, “..”은 상위 폴더 최상단 폴더로 진입 가능한 명령어 : cd, cd ~, cd ../.. 폴더 만들기 1$ mkdir [폴더 이름] 파일 만들기 12$ touch [파일 이름.확장자]# touch 명령어를 통해 같은 파일을 만들면 최종 수정 날짜 변경 가능 대상 이동 123$ mv [이동할 대상] [이동할 폴더]# 이름을 바꿀 때도 mv 명령어를 쓴다. ex) mv [현재 폴더] [이름을 바꾼 현재 폴더]# 폴더를 이동할 때 \"폴더 이름*\"을 사용하면 한꺼번에 이동 가능 디렉토리 폴더를 지울 때 12345# 폴더 안에 저장되어 있는 것이 있다면$ rm -r [폴더 이름]# 저장된 것이 없이 빈 폴더라면rmdir [폴더 이름] 디렉토리 폴더 내 목록 보기 1234567$ ls# 자세히 보기$ ls -l# 숨겨진 파일 보기$ ls -a 자세히 보기 1ex) -rwxrwxrwx 1 user group 4096 4월 2 00:00 test.txt 맨 앞은 파일의 종류에 대한 속성을 나타낸다. ‘-‘이라면 파일, ‘d’라면 디렉토리 폴더이다. 그 다음으로 세자리씩 끊어서 읽는다. ex) rwx rwx rwx 첫번째 세자리는 파일의 User에 대한 권한이다. 두번째 세자리는 파일의 Group에 대한 권한이다. 세번째 세자리는 관련이 없는 자들(Other)에 대한 권한이다. r은 읽기(read), w는 쓰기(write), x는 실행(execute)이다. rwx는 세 개 모두 된다는 뜻이다. r-x는 읽고 실행은 가능하지만 수정은 불가능하다는 뜻이다. rwx = 7 즉, 8진수로 나타낼 수 있다. r = 4, w = 2, x = 1로 계산하면 된다. 777이면 rwxrwxrwx라는 뜻이다.(퍼미션) chmod 명령어를 통해 권한을 줄 수 있다. 12345$ chmod 755 [파일 이름]$ chmod u+r [파일 이름] # u+r =&gt; user에게 r 권한을 줄 수 있음$ chmod g+x [파일 이름] # g+x =&gt; group에게 x 권한을 줄 수 있음$ chmod o=rwx [파일 이름] # o=rwx =&gt; other에게 rwx 권한을 줄 수 있음 rwxrwxrwx 다음으로 1은 해당 파일에 link되어 있는 파일의 개수 다음은 user은 해당 파일의 사용자(User) 다음은 group은 해당 파일의 그룹(Group) 4096은 파일의 크기(byte) 날짜는 해당 파일이 최종 수정된 날짜 및 시간 다음 의미를 알아보자. SetUID, SetGID, sticky bit 하드 링크(hard link)와 심볼릭 링크(symbolic link) 하드 링크(hard link) 원본 파일과 동일한 inode를 가진다. 원본 파일이 삭제되더라도 원본 파일의 inode를 갖고 있는 링크 파일은 여전히 사용 가능 같은 inode를 가리키는 서로 다른 이름이라고 생각하면 된다. file system이 같을 때만 만들 수 있다.(같은 디스크 내) inode의 값은 ls -i를 사용하면 된다. 심볼릭 링크(symbolic link) 원본 파일의 이름을 가리키는 링크 원본 파일이 사라지게 되면 역할 수행 불가능 file system이 달라도 만들 수 있다. 원본 파일이 삭제되더라도 원본 파일과 같은 이름으로 다시 생성하면 다시 사용 가능 ls -F로 링크 파일 파악가능 ‘@’가 붙어있으면 심볼릭 링크, ‘/‘가 붙어있으면 폴더, ‘*’가 붙어있으면 실행파일 tar : Tape ARchiver의 앞 글자를 조합 여러 개의 파일을 하나의 파일로 묶거나 풀 때 사용하는 명령어 Archiver는 통상적으로 여러 개의 파일을 하나의 파일로 합치는 프로그램을 의미 저장 장치에 파일을 저장하거나 네트워크를 통해 파일을 전송할 때 파일이 여러 개 있으면 관리가 복잡 여러 파일을 하나로 합쳐서 처리하기 위한 목적으로 만들어짐 c : 아카이브 생성(파일을 묶을 때 사용) v : 처리되는 과정(파일 정보)을 자세하게 나열 f : 대상 아카이브 지정 1$ tar cvf test.tar test.txt test2.txt test3.txt t : 아카이브에 포함된 내용 확인 1$ tar tvf test.tar x : 아카이브에서 파일 추출(파일을 풀 때 사용) 1$ tar xvf test.tar u : 아카이브의 마지막에 파일들 추가(update) 1$ tar uvf test.tar test4.txt z : gzip 압축 적용 옵션 1234567$ tar cvzf test.tar test.txt test2.txt test3.txt$ gzip test.tar # test.tar 압축 = test.tar.gz$ zcat test.tar.gz # 압축된 파일을 binary code로 풀어서 모두 보여줌$ gunzip test.tar.gz # test.tar.gz를 압축 해제 = test.tar BIOS(Basic Input/Output System) 운영 체제 중 가장 기본적인 컴퓨터의 입출력을 처리하는 소프트웨어 사용자가 컴퓨터를 켜면 시작되는 프로그램 주변 장치와 컴퓨터 운영 체제 사이의 데이터의 흐름을 관리 Check hardwares MBR(Master Boot Record)이 부트로더를 알고 있음 User user 1$ cat /etc/passwd user 생성 1$ sudo useradd -s /bin/bash -m -d /home/username username user passward 생성 1$ sudo passwd username user 삭제 1$ sudo userdel -r username group 생성 1$ sudo groupadd groupname group passward 생성 1$ sudo gpasswd groupname group 삭제 1$ sudo groupdel groupname chown 명령어 파일 및 디렉토리의 소유권을 바꾸는 명령어 1234567# root 계정으로 만든 파일을 user1이라는 계정이 소유하게 변경# test.txt 파일이 root(user) root(group) 계정 권한이 있다면$ chown user1:user1 test.txt# user1(user) user1(group)으로 계정 권한이 변경된다. Vim 명령어 진입 1$ vim [파일 이름.확장자] vim은 시작하자마자 Normal 모드 insert를 시작할 때는 i a를 누르면 내가 원하는 자리에서 시작 가능 shift + a를 이용하여 커서의 처음자리에서 끝자리로도 이동가능 복사 : shift + y 붙여넣기 : p(한 단계 위에서 붙여진다.) esc를 통해 Normal 모드 Normal 모드에서 ‘shift + :’를 누르면 명령어 입력 가능 ‘shift + :’에서 w는 저장, q는 나가기, wq는 저장 후 나가기 ‘shift + :’에서 숫자를 입력하면 해당 숫자 라인으로 이동 H, J, K, L로 방향키 가능 v는 비주얼 모드 비정상적인 종료로 swp 파일이 생겼을 경우, 지우면 된다. 기타 명령어 시스템 레벨 확인 1$ run level 종료 1$ sudo shutdown -h now 리눅스 설치 비트 확인 1234567$ arch$ getconf LONG_BIT$ uname -m$ echo $HOSTTYPE python 실행 비트 확인 12345$ python&gt;&gt; import platform&gt;&gt; platform.architecture() 리눅스에서 hard disk, USB mount 하는법 찾아보기 fdisk, mke2fs","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.04.01 Python and CE Study","slug":"190401-PCE-Study","date":"2019-03-31T16:15:22.000Z","updated":"2019-05-06T16:21:41.810Z","comments":true,"path":"2019/04/01/190401-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/04/01/190401-PCE-Study/","excerpt":"","text":"Single Linked List Node = data + link head(list의 첫번째 노드를 가리킴) d_size(list의 요소 개수) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118class Node: def __init__(self, data = None): self.__data = data # 노드 안에 데이터 변수 self.__link = None # 노드를 가리키기 위한 변수 # 소멸자 # 객체가 사라지기 전에 반ㄷ시 한번 호출하는 것을 보장한다. # 객체가 언제 소멸하는지를 알아보기 위해 적용 def __del__(self): print(f\"node[&#123;self.__data&#125;] deleted!!\") @property def data(self): return self.__data # setter를 지정할 땐 getter와 함수 이름을 같게 한다. @data.setter def data(self, data): self.__data = data @property def link(self): return self.__link @link.setter def link(self, link): self.__link = linkclass SLinkedList: def __init__(self): self.head = None # 리스트의 첫번째 노드를 가리키는 변수 self.d_size = 0 # 리스트의 요소 개수 def empty(self): if self.d_size == 0: return True # 리스트의 요소 개수가 0이면 True else: return False # 0이 아니면 False def size(self): return self.d_size # 리스트의 요소 개수 반환 def add(self, data): new_node = Node(data) new_node.link = self.head # 새로운 노드가 head를 가리키게 함 self.head = new_node # head가 새로운 노드를 가리키게 함 self.d_size += 1 # 잊지 말고 1을 더해줘야 함 def search(self, target): cur = self.head while cur: if cur.data == target: return cur # target과 같다면 노드 객체 자체를 받음 else: cur = cur.link # 헷갈리면 link를 next로 보자. return cur def delete(self): if self.empty(): return # head를 head.next로 가리키게 하면 기존 head가 가리키고 있는 # 노드 객체는 reference count가 0이 되어 자동으로 사라진다. self.head = self.head.link self.d_size -= 1 # 잊지 말고 1을 빼준다. # 리스트 출력을 보기 위해 만든 함수 def show(self): cur = self.head for _ in range(self.size()): print(cur.data, end = \" \") cur = cur.link print(\"\")if __name__ == \"__main__\": sll = SLinkedList() sll.add(1) sll.add(3) sll.add(4) sll.add(6) sll.add(8) sll.add(11) sll.show() target = 7 result = sll.search(target) if result: print(f'searched data : &#123;result.data&#125;') else: print('there is no such data') sll.delete() print(\"*\"*20) # 객체 소멸 시기를 알기 위해 기준점 역할&gt;&gt; 11 8 6 4 3 1 there is no such data node[11] deleted!! ******************** node[1] deleted!! node[3] deleted!! node[4] deleted!! node[6] deleted!! node[8] deleted!! Dummy Double Linked List 구현 편의성을 위해서 Dummy(데이터를 가지지 않는 노드) 사용 즉, head와 Tail은 데이터를 가지지 않음 head : 리스트 맨 앞에 있는 더미를 가리킴 tail : 리스트 맨 뒤에 있는 더미를 가리킴 size : 리스트의 요소 개수 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274class Node: def __init__(self, data = None): self.__data = data # 노드가 가지는 데이터 변수 self.__prev = None # 이전 노드를 가리키는 변수 self.__next = None # 다음 노드를 가리키는 변수 def __del__(self): print(f\"deleted : [&#123;self.__data&#125;]\") @property def data(self): return self.__data @data.setter def data(self, data): self.__data = data @property def prev(self): return self.__prev @prev.setter def prev(self, prev): self.__prev = prev @property def next(self): return self.__next @next.setter def next(self, next): self.__next = next class DoubleLinkedList: def __init__(self): # dummy 생성 시점 # head, tail, d_size # head와 tail은 연결 # 노드 추가 전이기 때문에 생성된 dummy의 head와 tail이 연결 self.head = Node() # head Dummy 노드 생성 self.tail = Node() # tail Dummy 노드 생성 self.d_size = 0 # 리스트의 요소 개수 초기화 self.head.next = self.tail # head Dummy가 tail Dummy를 가리킴 self.tail.prev = self.head # tail Dummy가 head Dummy를 가리킴 def empty(self): if self.d_size == 0: return True else: return False def size(self): return self.d_size def add_first(self, data): new_node = Node(data) # new_node 관점에서 연결 # 그림 그려보기 new_node.next = self.head.next new_node.prev = self.head # head 관점에서 연결(리스트 관점) # add_first는 head에 의존한다. # tail 쪽의 데이터 개수에 따라서 prev를 할 수 있기 때문에 # head에서 접근해야 한다. self.head.next.prev = new_node self.head.next = new_node # 잊지 말고 사이즈 추가 self.d_size += 1 def add_last(self, data): new_node = Node(data) # new_node 관점에서 연결 # 그림 그려보기 new_node.prev = self.tail.prev new_node.next = self.tail # tail 관점에서 연결(리스트 관점) # add_last는 tail에 의존한다. self.tail.prev.next = new_node self.tail.prev = new_node # 잊지 말고 사이즈 추가 self.d_size += 1 def insert_after(self, data, node): new_node = Node(data) # new_node 관점에서 연결 # 그림 그려보기 new_node.next = node.next new_node.prev = node # node 관점에서 연결(리스트 관점) node.next.prev = new_node node.next = new_node # 잊지 말고 사이즈 추가 self.d_size += 1 def insert_before(self, data, node): new_node = Node(data) # new_node 관점에서 연결 # 그림 그려보기 new_node.prev = node.prev new_node.next = node # node 관점에서 연결(리스트 관점) node.prev.next = new_node node.prev = new_node # 잊지 말고 사이즈 추가 self.d_size += 1 def search_forward(self, target): cur = self.head.next # self.head로 시작하면 Dummy 노드이기 때문에 None이 나오게 된다. # 따라서 self.head의 다음 노드부터 시작해야 한다. # self.tail까지 순회해야 Dummy 노드를 포함하지 않는 범위까지 값을 읽는다. # 객체를 비교하기 때문에 \"is\" 비교를 사용 while cur is not self.tail: if cur.data == target: return cur cur = cur.next return None # while문에 포함되지 않을 경우, None을 반환해야 한다. def search_backward(self, target): cur = self.tail.prev while cur is not self.head: if cur.data == target: return cur cur = cur.prev return None def delete_first(self): if self.empty(): return # self.head.next가 self.head.next.next가 되었기 때문에 # self.head.next의 prev가 self.head가 되면 된다. # 그림 그려보기 self.head.next = self.head.next.next self.head.next.prev = self.head # 잊지 말고 사이즈 감소 self.d_size -= 1 def delete_last(self): if self.empty(): return # 그림 그려보기 self.tail.prev = self.tail.prev.prev self.tail.prev.next = self.tail # 잊지 말고 사이즈 감소 self.d_size -= 1 def delete_node(self, node): # 그림 그려보기 node.prev.next = node.next node.next.prev = node.prev # 잊지 말고 사이즈 감소 self.d_size -= 1 # 편의 함수 - generator def traverse(self, start = True): if start: # 리스트의 첫 데이터부터 순회하기 위해 head가 아닌 head.next cur = self.head.next while cur is not self.tail: yield cur cur = cur.next else: # 리스트의 마지막 데이터부터 순회하기 위해 tail이 아닌 tail.prev cur = self.tail.prev while cur is not self.head: yield cur cur = cur.prev# \"==\"는 값을 비교하는 것이다.# \"is\"는 객체를 비교하는 것이다.# a = \"I am your father\"# b = \"I an your father\"# a == b --&gt; True# a is b --&gt; False# a와 b의 값은 똑같지만, 같은 객체는 아니다.def show_list(d_list): # generator g = d_list.traverse() for node in g: print(node.data, end = \" \") print()if __name__ == \"__main__\": dlist = DoubleLinkedList() dlist.delete_first() # delete_first에 empty 조건을 달아주지 않으면 에러 발생 # dlist.add_first(1)# dlist.add_first(2)# dlist.add_first(3)# dlist.add_first(4)# dlist.add_first(5) dlist.add_last(1) dlist.add_last(2) dlist.add_last(3) dlist.add_last(4) dlist.add_last(5) show_list(dlist) searched_data = dlist.search_backward(3) if searched_data: dlist.insert_before(15, searched_data)# print(f'searched_data : &#123;searched_data.data&#125;') else: print(\"there is no data\") show_list(dlist) dlist.delete_first() show_list(dlist) del_data = dlist.search_forward(15) if del_data: dlist.delete_node(del_data) del_data = None # del_data가 계속 찾은 노드를 가리키고 있기 때문에 # None 값을 넣어줘야 한다. else: print(\"기준 노드가 없습니다. 다시 확인하세요!\") show_list(dlist) print(\"*\"*20)&gt;&gt; 1 2 3 4 5 1 2 15 3 4 5 deleted : [1] 2 15 3 4 5 deleted : [15] 2 3 4 5 ******************** deleted : [None] deleted : [None] deleted : [2] deleted : [3] deleted : [4] deleted : [5]","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"dummy double linked list","slug":"190401-Algorithm-dummy-double-linked-list","date":"2019-03-31T15:21:20.000Z","updated":"2019-06-16T15:28:23.662Z","comments":true,"path":"2019/04/01/190401-Algorithm-dummy-double-linked-list/","link":"","permalink":"http://JINUKK.github.io/2019/04/01/190401-Algorithm-dummy-double-linked-list/","excerpt":"","text":"구현 편의성을 위해서 Dummy(데이터를 가지지 않는 노드) 사용 즉, head와 Tail은 데이터를 가지지 않음 head : 리스트 맨 앞에 있는 더미를 가리킴 tail : 리스트 맨 뒤에 있는 더미를 가리킴 size : 리스트의 요소 개수 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267class Node: def __init__(self, data = None): self.__data = data # 노드가 가지는 데이터 변수 self.__prev = None # 이전 노드를 가리키는 변수 self.__next = None # 다음 노드를 가리키는 변수 def __del__(self): print(f\"deleted : [&#123;self.__data&#125;]\") @property def data(self): return self.__data @data.setter def data(self, data): self.__data = data @property def prev(self): return self.__prev @prev.setter def prev(self, prev): self.__prev = prev @property def next(self): return self.__next @next.setter def next(self, next): self.__next = nextclass DoubleLinkedList: def __init__(self): # dummy 생성 시점 # head, tail, d_size # head와 tail은 연결 # 노드 추가 전이기 때문에 생성된 dummy의 head와 tail이 연결 self.head = Node() # head Dummy 노드 생성 self.tail = Node() # tail Dummy 노드 생성 self.d_size = 0 # 리스트의 요소 개수 초기화 self.head.next = self.tail # head Dummy가 tail Dummy를 가리킴 self.tail.prev = self.head # tail Dummy가 head Dummy를 가리킴 def empty(self): if self.d_size == 0: return True else: return False def size(self): return self.d_size def add_first(self, data): new_node = Node(data) # new_node 관점에서 연결 # 그림 그려보기 new_node.next = self.head.next new_node.prev = self.head # head 관점에서 연결(리스트 관점) # add_first는 head에 의존한다. # tail 쪽의 데이터 개수에 따라서 prev를 할 수 있기 때문에 # head에서 접근해야 한다. self.head.next.prev = new_node self.head.next = new_node # 잊지 말고 사이즈 추가 self.d_size += 1 def add_last(self, data): new_node = Node(data) # new_node 관점에서 연결 # 그림 그려보기 new_node.prev = self.tail.prev new_node.next = self.tail # tail 관점에서 연결(리스트 관점) # add_last는 tail에 의존한다. self.tail.prev.next = new_node self.tail.prev = new_node # 잊지 말고 사이즈 추가 self.d_size += 1 def insert_after(self, data, node): new_node = Node(data) # new_node 관점에서 연결 # 그림 그려보기 new_node.next = node.next new_node.prev = node # node 관점에서 연결(리스트 관점) node.next.prev = new_node node.next = new_node # 잊지 말고 사이즈 추가 self.d_size += 1 def insert_before(self, data, node): new_node = Node(data) # new_node 관점에서 연결 # 그림 그려보기 new_node.prev = node.prev new_node.next = node # node 관점에서 연결(리스트 관점) node.prev.next = new_node node.prev = new_node # 잊지 말고 사이즈 추가 self.d_size += 1 def search_forward(self, target): cur = self.head.next # self.head로 시작하면 Dummy 노드이기 때문에 None이 나오게 된다. # 따라서 self.head의 다음 노드부터 시작해야 한다. # self.tail까지 순회해야 Dummy 노드를 포함하지 않는 범위까지 값을 읽는다. # 객체를 비교하기 때문에 \"is\" 비교를 사용 while cur is not self.tail: if cur.data == target: return cur cur = cur.next return None # while문에 포함되지 않을 경우, None을 반환해야 한다. def search_backward(self, target): cur = self.tail.prev while cur is not self.head: if cur.data == target: return cur cur = cur.prev return None def delete_first(self): if self.empty(): return # self.head.next가 self.head.next.next가 되었기 때문에 # self.head.next의 prev가 self.head가 되면 된다. # 그림 그려보기 self.head.next = self.head.next.next self.head.next.prev = self.head # 잊지 말고 사이즈 감소 self.d_size -= 1 def delete_last(self): if self.empty(): return # 그림 그려보기 self.tail.prev = self.tail.prev.prev self.tail.prev.next = self.tail # 잊지 말고 사이즈 감소 self.d_size -= 1 def delete_node(self, node): # 그림 그려보기 node.prev.next = node.next node.next.prev = node.prev # 잊지 말고 사이즈 감소 self.d_size -= 1 # 편의 함수 - generator def traverse(self, start = True): if start: # 리스트의 첫 데이터부터 순회하기 위해 head가 아닌 head.next cur = self.head.next while cur is not self.tail: yield cur cur = cur.next else: # 리스트의 마지막 데이터부터 순회하기 위해 tail이 아닌 tail.prev cur = self.tail.prev while cur is not self.head: yield cur cur = cur.prev# \"==\"는 값을 비교하는 것이다.# \"is\"는 객체를 비교하는 것이다.# a = \"I am your father\"# b = \"I an your father\"# a == b --&gt; True# a is b --&gt; False# a와 b의 값은 똑같지만, 같은 객체는 아니다.def show_list(d_list): # generator g = d_list.traverse() for node in g: print(node.data, end = \" \") print()if __name__ == \"__main__\": dlist = DoubleLinkedList() dlist.delete_first() # delete_first에 empty 조건을 달아주지 않으면 에러 발생# dlist.add_first(1)# dlist.add_first(2)# dlist.add_first(3)# dlist.add_first(4)# dlist.add_first(5) dlist.add_last(1) dlist.add_last(2) dlist.add_last(3) dlist.add_last(4) dlist.add_last(5) show_list(dlist) searched_data = dlist.search_backward(3) if searched_data: dlist.insert_before(15, searched_data)# print(f'searched_data : &#123;searched_data.data&#125;') else: print(\"there is no data\") show_list(dlist) dlist.delete_first() show_list(dlist) del_data = dlist.search_forward(15) if del_data: dlist.delete_node(del_data) del_data = None # del_data가 계속 찾은 노드를 가리키고 있기 때문에 # None 값을 넣어줘야 한다. else: print(\"기준 노드가 없습니다. 다시 확인하세요!\") show_list(dlist) print(\"*\"*20)&gt;&gt; 1 2 3 4 5 1 2 15 3 4 5 deleted : [1] 2 15 3 4 5 deleted : [15] 2 3 4 5 ******************** deleted : [None] deleted : [None] deleted : [2] deleted : [3] deleted : [4] deleted : [5]","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://JINUKK.github.io/categories/Algorithm/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://JINUKK.github.io/tags/algorithm/"},{"name":"dummy double linked list","slug":"dummy-double-linked-list","permalink":"http://JINUKK.github.io/tags/dummy-double-linked-list/"}]},{"title":"single linked list","slug":"190401-Algorithm-single-linked-list","date":"2019-03-31T15:18:11.000Z","updated":"2019-06-16T15:28:38.866Z","comments":true,"path":"2019/04/01/190401-Algorithm-single-linked-list/","link":"","permalink":"http://JINUKK.github.io/2019/04/01/190401-Algorithm-single-linked-list/","excerpt":"","text":"Node = data + link head(list의 첫번째 노드를 가리킴) d_size(list의 요소 개수) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117class Node: def __init__(self, data = None): self.__data = data # 노드 안에 데이터 변수 self.__link = None # 노드를 가리키기 위한 변수 # 소멸자 # 객체가 사라지기 전에 반ㄷ시 한번 호출하는 것을 보장한다. # 객체가 언제 소멸하는지를 알아보기 위해 적용 def __del__(self): print(f\"node[&#123;self.__data&#125;] deleted!!\") @property def data(self): return self.__data # setter를 지정할 땐 getter와 함수 이름을 같게 한다. @data.setter def data(self, data): self.__data = data @property def link(self): return self.__link @link.setter def link(self, link): self.__link = linkclass SLinkedList: def __init__(self): self.head = None # 리스트의 첫번째 노드를 가리키는 변수 self.d_size = 0 # 리스트의 요소 개수 def empty(self): if self.d_size == 0: return True # 리스트의 요소 개수가 0이면 True else: return False # 0이 아니면 False def size(self): return self.d_size # 리스트의 요소 개수 반환 def add(self, data): new_node = Node(data) new_node.link = self.head # 새로운 노드가 head를 가리키게 함 self.head = new_node # head가 새로운 노드를 가리키게 함 self.d_size += 1 # 잊지 말고 1을 더해줘야 함 def search(self, target): cur = self.head while cur: if cur.data == target: return cur # target과 같다면 노드 객체 자체를 받음 else: cur = cur.link # 헷갈리면 link를 next로 보자. return cur def delete(self): if self.empty(): return # head를 head.next로 가리키게 하면 기존 head가 가리키고 있는 # 노드 객체는 reference count가 0이 되어 자동으로 사라진다. self.head = self.head.link self.d_size -= 1 # 잊지 말고 1을 빼준다. # 리스트 출력을 보기 위해 만든 함수 def show(self): cur = self.head for _ in range(self.size()): print(cur.data, end = \" \") cur = cur.link print(\"\")if __name__ == \"__main__\": sll = SLinkedList() sll.add(1) sll.add(3) sll.add(4) sll.add(6) sll.add(8) sll.add(11) sll.show() target = 7 result = sll.search(target) if result: print(f'searched data : &#123;result.data&#125;') else: print('there is no such data') sll.delete() print(\"*\"*20) # 객체 소멸 시기를 알기 위해 기준점 역할&gt;&gt; 11 8 6 4 3 1 there is no such data node[11] deleted!! ******************** node[1] deleted!! node[3] deleted!! node[4] deleted!! node[6] deleted!! node[8] deleted!!","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://JINUKK.github.io/categories/Algorithm/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://JINUKK.github.io/tags/algorithm/"},{"name":"single linked list","slug":"single-linked-list","permalink":"http://JINUKK.github.io/tags/single-linked-list/"}]},{"title":"generator","slug":"190328-Python-generator","date":"2019-03-28T14:57:59.000Z","updated":"2019-06-16T15:01:04.755Z","comments":true,"path":"2019/03/28/190328-Python-generator/","link":"","permalink":"http://JINUKK.github.io/2019/03/28/190328-Python-generator/","excerpt":"","text":"body 안에 yield 파이썬 코루틴의 구현은 generator를 기반으로 한다. 파이썬 stack frame이 heap에 저장되어 있기 때문에 가능하다. return 값은 StopIteration이 발생했을 때 반환된다. StopIteration도 객체이다. 1234567891011def gen(): print('gen start') yield 1 print('abcde') yield 2 print('fghjk') yield 3 print('asdfasdf') yield 4 print('123123123') return 'done' 모든 제네레이터는 이터레이터이다. 제네레이터는 게으른 팩토리이다.(값을 그 때 그 때 생성함) 제네레이터를 호출했을 때 제네레이터 객체가 생성 12345678910111213141516171819202122232425262728293031g = gen()g&gt;&gt; &lt;generator object gen at 0x001727F0&gt;# 첫 번째 next() 호출하면 yield를 만날 때까지 함수가 실행이 된다.next(g)&gt;&gt; gen start 1next(g)&gt;&gt; abcde 2a = next(g)&gt;&gt; fghjka&gt;&gt; 3next(g)&gt;&gt; asdfasdf 4# 함수가 리턴을 만나면 StopIteration 객체가 생성# value에 지정해놓은 리턴 값을 반환한다.try: next(g)except StopIteration as exc: print(exc.value) pass&gt;&gt; 123123123 done coroutine function 함수 실행 도중에 실행 주도권을 다른 함수에 넘길 수 있음 내가 원하는 시점(non - preemptive)에 다시 실행 주도권을 가져올 수 있는 함수 명시적(explicit) 123456789101112131415# 제네레이터로 피보나치 만들기def fibo_gen(n): a = 0 b = 1 for _ in range(n): yield a a,b = b, a+bfibo = fibo_gen(15)for _ in range(15): print(next(fibo), end = \" \")&gt;&gt; 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 yield from 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def gen(): print('gen start') data1 = yield 1 print(f'gen[1] : &#123;data1&#125;') data2 = yield 2 print(f'gen[2] : &#123;data2&#125;') return 'END'# yield가 들어가있으면 generator# yield from 다음에는 generator 객체가 들어와야 함# yield from은 중계 역할# yield from 다음으로 나오는 generator 객체가 끝날 때까지 중계 역할# g = gen() 부분은 generator 객체이기 때문에 함수가 실행되지 않는다.# 만약 generator 객체가 아니고 일반 함수였다면 실행이 되야 한다.# delegate - 위임def delegate(): g = gen() print('start') ret = yield from g print('end') print(f'return value : &#123;ret&#125;') return retg = delegate()g&gt;&gt; &lt;generator object delegate at 0x006C1430&gt;first = g.send(None)&gt;&gt; start gen startsecond = g.send('world')&gt;&gt; gen[1] : worldsecond&gt;&gt; 2# 'END'라는 generator g 객체의 리턴 값을 StopIteration 객체가 value에 넣음try: g.send('hello')except StopIteration as exc: print(exc.value)&gt;&gt; gen[2] : hello end return value : END END","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"generator","slug":"generator","permalink":"http://JINUKK.github.io/tags/generator/"},{"name":"yield","slug":"yield","permalink":"http://JINUKK.github.io/tags/yield/"},{"name":"yield from","slug":"yield-from","permalink":"http://JINUKK.github.io/tags/yield-from/"},{"name":"stopiteration","slug":"stopiteration","permalink":"http://JINUKK.github.io/tags/stopiteration/"}]},{"title":"iterator","slug":"190328-Python-iterator","date":"2019-03-28T14:54:52.000Z","updated":"2019-06-16T14:57:19.866Z","comments":true,"path":"2019/03/28/190328-Python-iterator/","link":"","permalink":"http://JINUKK.github.io/2019/03/28/190328-Python-iterator/","excerpt":"","text":"next() 함수에 의해서 값을 하나씩 반환(next 호출 시점) StopIteration custom iterator 정의한 클래스가 이터레이터를 지원하려면 iter 메서드를 정의해야함 iter 메서드에는 자신을 돌려주면 됨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# custom iteratorclass MyIter(): # iterator를 구성하려면 __iter__, __next__ 메소드가 필요하다. def __init__(self, li): self.container = li self.index = 0 def __iter__(self): # 이터레이터를 지원을 위한 __iter__ 메소드를 정의 # 자신을 돌려줌 return self def __next__(self): # 어느 시점에 StopIteration 에러만 넘겨줄 수 있으면 if self.index &gt;= len(self.container): raise StopIteration ret = self.container[self.index] self.index += 1 return retli = [1, 2, 3, 4, 5]it = iter(li)type(it)&gt;&gt; list_iteratornext(it)&gt;&gt; 1next(it)&gt;&gt; 2next(it)&gt;&gt; 3next(it)&gt;&gt; 4next(it)&gt;&gt; 5# StopIteration 에러 발생next(it)&gt;&gt; StopIteration# for문에서 li는 자동으로 iterator 객체가 된다.for e in li: print(e, end = ' ')&gt;&gt; 1 2 3 4 5it_obj = MyIter(li)it = iter(it_obj)type(it)&gt;&gt; __main__.MyIternext(it)&gt;&gt; 1next(it)&gt;&gt; 2next(it)&gt;&gt; 3next(it)&gt;&gt; 4next(it)&gt;&gt; 5# next() 호출 시점에서 지정한 예외가 발생할 수 있도록 조건 지정# StopIteration 에러 발생next(it)&gt;&gt; StopIteration","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"stopiteration","slug":"stopiteration","permalink":"http://JINUKK.github.io/tags/stopiteration/"},{"name":"iterator","slug":"iterator","permalink":"http://JINUKK.github.io/tags/iterator/"},{"name":"next","slug":"next","permalink":"http://JINUKK.github.io/tags/next/"}]},{"title":"2019.03.28 Python and CE Study","slug":"190328-PCE-Study","date":"2019-03-27T16:01:28.000Z","updated":"2019-05-06T16:13:33.885Z","comments":true,"path":"2019/03/28/190328-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/28/190328-PCE-Study/","excerpt":"","text":"iterator next() 함수에 의해서 값을 하나씩 반환(next 호출 시점) StopIteration custom iterator 정의한 클래스가 이터레이터를 지원하려면 iter 메서드를 정의해야함 iter 메서드에는 자신을 돌려주면 됨 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# custom iteratorclass MyIter(): # iterator를 구성하려면 __iter__, __next__ 메소드가 필요하다. def __init__(self, li): self.container = li self.index = 0 def __iter__(self): # 이터레이터를 지원을 위한 __iter__ 메소드를 정의 # 자신을 돌려줌 return self def __next__(self): # 어느 시점에 StopIteration 에러만 넘겨줄 수 있으면 if self.index &gt;= len(self.container): raise StopIteration ret = self.container[self.index] self.index += 1 return retli = [1, 2, 3, 4, 5]it = iter(li)type(it)&gt;&gt; list_iteratornext(it)&gt;&gt; 1next(it)&gt;&gt; 2next(it)&gt;&gt; 3next(it)&gt;&gt; 4next(it)&gt;&gt; 5# StopIteration 에러 발생next(it)&gt;&gt; StopIteration# for문에서 li는 자동으로 iterator 객체가 된다.for e in li: print(e, end = ' ')&gt;&gt; 1 2 3 4 5it_obj = MyIter(li)it = iter(it_obj)type(it)&gt;&gt; __main__.MyIternext(it)&gt;&gt; 1next(it)&gt;&gt; 2next(it)&gt;&gt; 3next(it)&gt;&gt; 4next(it)&gt;&gt; 5# next() 호출 시점에서 지정한 예외가 발생할 수 있도록 조건 지정# StopIteration 에러 발생next(it)&gt;&gt; StopIteration byte stream 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657f = open('iterator_test.txt', 'rt') # 텍스트 파일을 불러옴# 텍스트 파일 내용\"\"\"Single responsibility principleOpen-closed principleLiskov substitution principleInterface segregation princileDependency inversion principleEND\"\"\"f.readline() # 텍스트 파일 한줄을 읽어옴&gt;&gt; 'Single responsibility principle\\n'class Reader: def __init__(self, filename): # open()의 두 번째 인자는 mode # 'r' = 읽기 전용 # 't' = 텍스트 모드(기본값) self.f = open(filename, 'rt') def __iter__(self): return self def __next__(self): line = self.f.readline() # readline() - 한번에 한 줄씩 읽기 if line: return line[:-1] # 문자열 끝에 \\n를 빼고 반환 else: self.f.close() raise StopIterationreader = Reader('iterator_test.txt')it = iter(reader)for _ in range(15): print(next(it))# 총 텍스트의 줄 수를 벗어나 StopIteration 발생&gt;&gt; Single responsibility principle Open-closed principle Liskov substitution principle Interface segregation principle Dependency inversion principle EN --------------------------------- StopIteration generator 독특한(?) 함수 body 안에 yield 파이썬 코루틴의 구현은 generator를 기반으로 한다. 파이썬 stack frame이 heap에 저장되어 있기 때문에 가능하다. return 값은 StopIteration이 발생했을 때 반환된다. StopIteration도 객체이다. 1234567891011def gen(): print('gen start') yield 1 print('abcde') yield 2 print('fghjk') yield 3 print('asdfasdf') yield 4 print('123123123') return 'done' 모든 제네레이터는 이터레이터이다. 제네레이터는 게으른 팩토리이다.(값을 그 때 그 때 생성함) 제네레이터를 호출했을 때 제네레이터 객체가 생성 1234567891011121314151617181920212223242526272829303132g = gen()g&gt;&gt; &lt;generator object gen at 0x001727F0&gt;# 첫 번째 next() 호출하면 yield를 만날 때까지 함수가 실행이 된다.next(g)&gt;&gt; gen start 1next(g)&gt;&gt; abcde 2a = next(g)&gt;&gt; fghjka&gt;&gt; 3next(g)&gt;&gt; asdfasdf 4# 함수가 리턴을 만나면 StopIteration 객체가 생성# value에 지정해놓은 리턴 값을 반환한다.try: next(g)except StopIteration as exc: print(exc.value) pass&gt;&gt; 123123123 done coroutine function 함수 실행 도중에 실행 주도권을 다른 함수에 넘길 수 있음 내가 원하는 시점(non - preemptive)에 다시 실행 주도권을 가져올 수 있는 함수 명시적(explicit) 123456789101112131415# 제네레이터로 피보나치 만들기def fibo_gen(n): a = 0 b = 1 for _ in range(n): yield a a,b = b, a+bfibo = fibo_gen(15)for _ in range(15): print(next(fibo), end = \" \")&gt;&gt; 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 yield from 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def gen(): print('gen start') data1 = yield 1 print(f'gen[1] : &#123;data1&#125;') data2 = yield 2 print(f'gen[2] : &#123;data2&#125;') return 'END'# yield가 들어가있으면 generator# yield from 다음에는 generator 객체가 들어와야 함# yield from은 중계 역할# yield from 다음으로 나오는 generator 객체가 끝날 때까지 중계 역할# g = gen() 부분은 generator 객체이기 때문에 함수가 실행되지 않는다.# 만약 generator 객체가 아니고 일반 함수였다면 실행이 되야 한다.# delegate - 위임def delegate(): g = gen() print('start') ret = yield from g print('end') print(f'return value : &#123;ret&#125;') return retg = delegate()g&gt;&gt; &lt;generator object delegate at 0x006C1430&gt;first = g.send(None)&gt;&gt; start gen startsecond = g.send('world')&gt;&gt; gen[1] : worldsecond&gt;&gt; 2# 'END'라는 generator g 객체의 리턴 값을 StopIteration 객체가 value에 넣음try: g.send('hello')except StopIteration as exc: print(exc.value)&gt;&gt; gen[2] : hello end return value : END END","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"merge sort","slug":"190327-Algorithm-Sort-merge-sort","date":"2019-03-27T14:49:11.000Z","updated":"2019-07-21T07:29:34.956Z","comments":true,"path":"2019/03/27/190327-Algorithm-Sort-merge-sort/","link":"","permalink":"http://JINUKK.github.io/2019/03/27/190327-Algorithm-Sort-merge-sort/","excerpt":"","text":"Help Link! GeeksforGeeks Youtube(https://www.youtube.com/watch?v=JSceec-wEyw) merge sort(합병 정렬) Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 divide and conquer(분할 정복 알고리즘) O(nlogn) 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않을 경우에는 정렬되지 않는 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import randomdef merge(li, start, mid, end): \"\"\" 쪼개진 두 개 리스트 조각에서 left_idx, right_idx를 비교해서 작은 값을 올리고 다음 칸으로 이동 둘 중 하나가 범위를 벗어날 때 \"\"\" left_idx = start right_idx = mid + 1 temp = [] while left_idx &lt;= mid and right_idx &lt;= end: if li[left_idx] &lt; li[right_idx]: temp.append(li[left_idx]) left_idx += 1 else: temp.append(li[right_idx]) right_idx += 1 while left_idx &lt;= mid: temp.append(li[left_idx]) left_idx += 1 while right_idx &lt;= end: temp.append(li[right_idx]) right_idx += 1 li[start:end+1] = temp def merge_sort(li, start, end): # base case if start &gt;= end: return mid = (start + end) // 2 merge_sort(li, start, mid) merge_sort(li, mid + 1, end) merge(li, start, mid, end) if __name__ == \"__main__\": while True: num_data = int(input('데이터 개수(종료:0):')) if not num_data: break data = [random.randint(1, 100) for _ in range(num_data)] print(data) merge_sort(data, 0, len(data) - 1) print(data)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://JINUKK.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://JINUKK.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://JINUKK.github.io/tags/algorithm/"},{"name":"merge sort","slug":"merge-sort","permalink":"http://JINUKK.github.io/tags/merge-sort/"}]},{"title":"quick sort","slug":"190327-Algorithm-Sort-quick-sort","date":"2019-03-27T14:46:04.000Z","updated":"2019-07-21T07:29:05.677Z","comments":true,"path":"2019/03/27/190327-Algorithm-Sort-quick-sort/","link":"","permalink":"http://JINUKK.github.io/2019/03/27/190327-Algorithm-Sort-quick-sort/","excerpt":"","text":"Help Link! GeeksforGeeks Youtube(https://www.youtube.com/watch?v=PgBzjlCcFvc) quick sort(퀵 정렬) Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 divide and conquer(분할 정복 알고리즘) O(nlogn) 맨 앞의 데이터를 기준으로 선택했을 경우 모든 데이터가 정렬되었을 때, 오히려 많은 시간이 걸리게 된다.(O(n^2)) 따라서 이 문제를 해결하는 방법은 기준을 선택할 때 중간 값을 기준으로 선택한다. 리스트의 중간 원소 pivot을 기준으로 pivot보다 큰 원소는 오른쪽으로 옮긴다. 리스트의 중간 원소 pivot을 기준으로 pivot보다 작은 원소는 왼쪽으로 옮긴다. pivot의 오른쪽 리스트와 왼쪽 리스트를 분할하여 재귀를 통해 다시 정렬 반복한다. 리스트의 크기가 0이나 1이 될때까지 반복한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import random# 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.# 따라서 pivot을 선택할 때 더욱 리스트를 균등하게 분할할 수 있는# 데이터를 선택할 수 있도록 get_pivot_index 함수를 설계def get_pivot_index(li, start, mid, end): \"\"\" get_pivot_index(li, start, end) -&gt; index 리스트의 맨 처음 값, 가운데 값, 마지막 값 중에서 중간 값을 가진 인덱스를 반환한다. \"\"\" # 더 좋은 알고리즘이 있는지 다시 코딩해보기 idx_li = [start, mid, end] if li[idx_li[0]] &gt; li[idx_li[1]]: idx_li[0], idx_li[1] = idx_li[1], idx_li[0] if li[idx_li[1]] &gt; li[idx_li[2]]: idx_li[1], idx_li[2] = idx_li[2], idx_li[1] if li[idx_li[0]] &gt; li[idx_li[1]]: idx_li[0], idx_li[1] = idx_li[1], idx_li[0] return idx_li[1]def quick_sort(li, start, end): # base case if start &gt; end: return left = start right = end mid = (start + end) // 2 pivot_index = get_pivot_index(li, start, mid, end) li[pivot_index], li[mid] = li[mid], li[pivot_index] pivot = li[mid] while left &lt;= right: while li[left] &lt; pivot: left += 1 while li[right] &gt; pivot: right -= 1 if left &lt;= right: li[left], li[right] = li[right], li[left] left += 1 right -= 1 quick_sort(li, start, right) quick_sort(li, left, end) if __name__ == \"__main__\": while True: num_data = int(input(\"데이터 개수(종료: 0):\")) if not num_data: break data = [random.randint(1, 100) for _ in range(num_data)] print(data) quick_sort(data, 0, len(data) - 1) print(data)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://JINUKK.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://JINUKK.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://JINUKK.github.io/tags/algorithm/"},{"name":"quick sort","slug":"quick-sort","permalink":"http://JINUKK.github.io/tags/quick-sort/"}]},{"title":"selection sort","slug":"190327-Algorithm-Sort-selection-sort","date":"2019-03-27T14:44:15.000Z","updated":"2019-07-21T07:27:48.031Z","comments":true,"path":"2019/03/27/190327-Algorithm-Sort-selection-sort/","link":"","permalink":"http://JINUKK.github.io/2019/03/27/190327-Algorithm-Sort-selection-sort/","excerpt":"","text":"Help Link! GeeksforGeeks Youtube(https://www.youtube.com/watch?v=xWBP4lzkoyM) selection sort(선택 정렬) Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 O(n^2) simple sort 제자리 정렬 알고리즘의 하나 입력 리스트(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법 주어진 배열 중에서 최솟값을 찾는다. 그 값을 맨 앞에 위치한 값과 교체한다.(두 수를 비교하여 pass도 가능) 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다. 하나의 원소만 남을 때까지 위의 1~3 과정을 반복한다.1234567891011121314151617181920212223242526272829import randomdef selection_sort(li): n = len(li) for i in range(0, n-1): min_idx = i for j in range(i+1, n): if li[j] &lt; li[min_idx]: min_idx = j # min_idx --&gt; 맨 앞자리를 제외하고 최소값이 위치한 곳의 인덱스 li[i], li[min_idx] = li[min_idx], li[i] if __name__ == \"__main__\": while True: num_data = int(input('데이터 개수(종료:0):')) if not num_data: break data = [random.randint(1,100) for _ in range(num_data)] print(data) selection_sort(data) print(data)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://JINUKK.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://JINUKK.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://JINUKK.github.io/tags/algorithm/"},{"name":"selection sort","slug":"selection-sort","permalink":"http://JINUKK.github.io/tags/selection-sort/"}]},{"title":"insertion sort","slug":"190327-Algorithm-Sort-insertion-sort","date":"2019-03-27T14:41:44.000Z","updated":"2019-07-21T07:27:14.776Z","comments":true,"path":"2019/03/27/190327-Algorithm-Sort-insertion-sort/","link":"","permalink":"http://JINUKK.github.io/2019/03/27/190327-Algorithm-Sort-insertion-sort/","excerpt":"","text":"Help Link! GeeksforGeeks Youtube(https://www.youtube.com/watch?v=OGzPmgsI-pQ) insertion sort(삽입 정렬) Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 O(n^2) Comparison sort 중에 그나마 나음 simple sort 두 번째 자료부터 시작하여 그 앞 자료들과 비교하면서 삽입할 위치를 지정 지정한 후, 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 방식 처음 key 값은 두번째 자료부터 시작한다. 12345678910111213141516171819202122232425262728293031323334import randomdef insertion_sort(li): n = len(li) for i in range(1, n): ref_idx = li[i] for j in range(i-1, -2, -1): if j == -1: break elif li[j] &gt; li[j+1]: li[j], li[j+1] = li[j+1], li[j] else: break ref_idx = li[j+1] if __name__ == \"__main__\": while True: num_data = int(input('데이터 개수(종료:0):')) if not num_data: break data = [random.randint(1,100) for _ in range(num_data)] print(data) insertion_sort(data) print(data)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://JINUKK.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://JINUKK.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://JINUKK.github.io/tags/algorithm/"},{"name":"insertion sort","slug":"insertion-sort","permalink":"http://JINUKK.github.io/tags/insertion-sort/"}]},{"title":"2019.03.27 Python and CE Study","slug":"190327-PCE-Study","date":"2019-03-26T16:01:24.000Z","updated":"2019-05-06T16:09:12.717Z","comments":true,"path":"2019/03/27/190327-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/27/190327-PCE-Study/","excerpt":"","text":"Algorithm - Sort bubble sort(거품 정렬) Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 O(n^2) simple sort 마지막 전 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬 한번 순회가 끝나면 가장 큰 자료가 맨뒤로 이동 2번째 순회에서는 맨 끝에 있는 자료를 정렬에서 제외되는 방식 순회할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어남 123456789101112131415161718192021222324import randomdef bubble_sort(li): n = len(li) for i in range(n-1): for j in range(n-i-1): if li[j] &gt; li[j+1]: li[j], li[j+1] = li[j+1], li[j] if __name__ == '__main__': while True: num_data = int(input('데이터 개수(종료:0):')) if not num_data: break data = [random.randint(1,100) for _ in range(num_data)] print(data) bubble_sort(data) print(data) insertion sort(삽입 정렬) Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 O(n^2) Comparison sort 중에 그나마 나음 simple sort 두 번째 자료부터 시작하여 그 앞 자료들과 비교하면서 삽입할 위치를 지정 지정한 후, 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 방식 처음 key 값은 두번째 자료부터 시작한다. 123456789101112131415161718192021222324252627282930313233343536import randomdef insertion_sort(li): n = len(li) for i in range(1, n): ref_idx = li[i] for j in range(i-1, -2, -1): if j == -1: break elif li[j] &gt; li[j+1]: li[j], li[j+1] = li[j+1], li[j] else: break ref_idx = li[j+1] if __name__ == \"__main__\": while True: num_data = int(input('데이터 개수(종료:0):')) if not num_data: break data = [random.randint(1,100) for _ in range(num_data)] print(data) insertion_sort(data) print(data) selection sort(선택 정렬) Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 O(n^2) simple sort 제자리 정렬 알고리즘의 하나 입력 리스트(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법 주어진 배열 중에서 최솟값을 찾는다. 그 값을 맨 앞에 위치한 값과 교체한다.(두 수를 비교하여 pass도 가능) 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다. 하나의 원소만 남을 때까지 위의 1~3 과정을 반복한다. 123456789101112131415161718192021222324252627282930import randomdef selection_sort(li): n = len(li) for i in range(0, n-1): min_idx = i for j in range(i+1, n): if li[j] &lt; li[min_idx]: min_idx = j # min_idx --&gt; 맨 앞자리를 제외하고 최소값이 위치한 곳의 인덱스 li[i], li[min_idx] = li[min_idx], li[i] if __name__ == \"__main__\": while True: num_data = int(input('데이터 개수(종료:0):')) if not num_data: break data = [random.randint(1,100) for _ in range(num_data)] print(data) selection_sort(data) print(data) quick sort(퀵 정렬) Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 divide and conquer(분할 정복 알고리즘) O(nlogn) 맨 앞의 데이터를 기준으로 선택했을 경우 모든 데이터가 정렬되었을 때, 오히려 많은 시간이 걸리게 된다.(O(n^2)) 따라서 이 문제를 해결하는 방법은 기준을 선택할 때 중간 값을 기준으로 선택한다. 리스트의 중간 원소 pivot을 기준으로 pivot보다 큰 원소는 오른쪽으로 옮긴다. 리스트의 중간 원소 pivot을 기준으로 pivot보다 작은 원소는 왼쪽으로 옮긴다. pivot의 오른쪽 리스트와 왼쪽 리스트를 분할하여 재귀를 통해 다시 정렬 반복한다. 리스트의 크기가 0이나 1이 될때까지 반복한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import random# 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.# 따라서 pivot을 선택할 때 더욱 리스트를 균등하게 분할할 수 있는# 데이터를 선택할 수 있도록 get_pivot_index 함수를 설계def get_pivot_index(li, start, mid, end): \"\"\" get_pivot_index(li, start, end) -&gt; index 리스트의 맨 처음 값, 가운데 값, 마지막 값 중에서 중간 값을 가진 인덱스를 반환한다. \"\"\" # 더 좋은 알고리즘이 있는지 다시 코딩해보기 idx_li = [start, mid, end] if li[idx_li[0]] &gt; li[idx_li[1]]: idx_li[0], idx_li[1] = idx_li[1], idx_li[0] if li[idx_li[1]] &gt; li[idx_li[2]]: idx_li[1], idx_li[2] = idx_li[2], idx_li[1] if li[idx_li[0]] &gt; li[idx_li[1]]: idx_li[0], idx_li[1] = idx_li[1], idx_li[0] return idx_li[1]def quick_sort(li, start, end): # base case if start &gt; end: return left = start right = end mid = (start + end) // 2 pivot_index = get_pivot_index(li, start, mid, end) li[pivot_index], li[mid] = li[mid], li[pivot_index] pivot = li[mid] while left &lt;= right: while li[left] &lt; pivot: left += 1 while li[right] &gt; pivot: right -= 1 if left &lt;= right: li[left], li[right] = li[right], li[left] left += 1 right -= 1 quick_sort(li, start, right) quick_sort(li, left, end) if __name__ == \"__main__\": while True: num_data = int(input(\"데이터 개수(종료: 0):\")) if not num_data: break data = [random.randint(1, 100) for _ in range(num_data)] print(data) quick_sort(data, 0, len(data) - 1) print(data) merge sort(합병 정렬) Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 divide and conquer(분할 정복 알고리즘) O(nlogn) 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않을 경우에는 정렬되지 않는 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import randomdef merge(li, start, mid, end): \"\"\" 쪼개진 두 개 리스트 조각에서 left_idx, right_idx를 비교해서 작은 값을 올리고 다음 칸으로 이동 둘 중 하나가 범위를 벗어날 때 \"\"\" left_idx = start right_idx = mid + 1 temp = [] while left_idx &lt;= mid and right_idx &lt;= end: if li[left_idx] &lt; li[right_idx]: temp.append(li[left_idx]) left_idx += 1 else: temp.append(li[right_idx]) right_idx += 1 while left_idx &lt;= mid: temp.append(li[left_idx]) left_idx += 1 while right_idx &lt;= end: temp.append(li[right_idx]) right_idx += 1 li[start:end+1] = temp def merge_sort(li, start, end): # base case if start &gt;= end: return mid = (start + end) // 2 merge_sort(li, start, mid) merge_sort(li, mid + 1, end) merge(li, start, mid, end) if __name__ == \"__main__\": while True: num_data = int(input('데이터 개수(종료:0):')) if not num_data: break data = [random.randint(1, 100) for _ in range(num_data)] print(data) merge_sort(data, 0, len(data) - 1) print(data)","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"Queue","slug":"190326-Python-queue","date":"2019-03-26T14:33:46.000Z","updated":"2019-06-16T14:35:00.411Z","comments":true,"path":"2019/03/26/190326-Python-queue/","link":"","permalink":"http://JINUKK.github.io/2019/03/26/190326-Python-queue/","excerpt":"","text":"FIFO(First In, First Out) 선입선출 먼저 들어온 것이 먼저 나가는 방식 12345678910111213141516171819202122232425262728293031class Queue: def __init__(self): self.container = list() def empty(self): if self.container: return False else: return True def enqueue(self, data): return self.container.append(data) def dequeue(self): return self.container.pop(0) def peek(self): return self.container[0]if __name__ == '__main__': que = Queue() for i in range(1, 6): que.enqueue(i) while not que.empty(): print(que.dequeue(), end = \" \")&gt;&gt; 1 2 3 4 5","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"queue","slug":"queue","permalink":"http://JINUKK.github.io/tags/queue/"}]},{"title":"2019.03.26 Python and CE Study","slug":"190326-PCE-Study","date":"2019-03-25T16:01:14.000Z","updated":"2019-05-06T16:04:16.651Z","comments":true,"path":"2019/03/26/190326-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/26/190326-PCE-Study/","excerpt":"","text":"Queue FIFO(First In, First Out) 선입선출 먼저 들어온 것이 먼저 나가는 방식 12345678910111213141516171819202122232425262728293031class Queue: def __init__(self): self.container = list() def empty(self): if self.container: return False else: return True def enqueue(self, data): return self.container.append(data) def dequeue(self): return self.container.pop(0) def peek(self): return self.container[0]if __name__ == '__main__': que = Queue() for i in range(1, 6): que.enqueue(i) while not que.empty(): print(que.dequeue(), end = \" \")&gt;&gt; 1 2 3 4 5 Computer Engineering Process Program : HDD에 있는 Image Process : “실행중인” RAM에 메모리가 올라왔을 때 같은 프로세스를 켜도 PID(Process ID)가 다르다. 윈도우는 PID가 랜덤으로 생성 리눅스는 PID가 0번부터 순차적으로 생성 프로그램이 실행되면 바로 RAM에 메모리가 생기는 것이 아니라 Run queue로 들어감 Process Scheduling CPU에서 프로세스들이 동시에 실행할 수 있게 순위를 조정 Priority Algorithm 우선순위를 통해 프로세스 실행 리눅스에서는 nice 값이 높으면 우선순위가 낮아짐 Round-Robin Algorithm 모든 프로세스에게 공평하게 시간을 할당해줌 시간(Time Slice, Quantum) = 한 프로세스에 할당되는 시간 scheduler 동작시기 한 프로세스의 time slice가 끝나고 다음 차례일 때 Process created or ended Running process blocked I/O bound 또는 system call로 인해 blocking이 걸렸을 때 I/O bound ex) +, -, *, /, AND(CPU bound) System call ex) sleep() I/O 작업이 끝났다고 해서 바로 running으로 가는 것이 아니다. waiting으로 가서 scheduler를 기다린다.(time slice를 기다림) 리눅스에 top에서 R은 running + waiting = Context Switching 메모리 안에 Process Control Block(PCB)를 만든다. PCB 안에 CPU 레지스터에 있는 값을 모두 복사해둔다. CPU에 있는 레지스터 상태 정보를 Context라고 한다. Context Switching CPU에서 PCB의 정보를 내리고 올리는 작업 너무 자주 context switch를 하면 멀티해보일 수 있으나, 느려질 수 있음 메모리와 CPU가 최소 40 ~ 200 cycle 필요 Waiting vs Blocked waiting : scheduler가 부르면 바로 실행 가능 blocked : 바로 실행 불가 pre-emptive scheduling 선점형 스케줄링 모든 프로세스에게 CPU 사용 시간을 동일하게 부여 모든 OS에서 다 지원 Multitasking Job scheduling(Task scheduling) Thread process와 thread 모두 실행의 흐름일 뿐이다.(instruction의 나열) process는 무조건 하나 이상의 thread를 가진다. Single Thread 하나의 프로세스에서 하나의 스레드 실행 Concurrency Programming Multi - Processing Inter Process Communication(IPC)를 통해 통신해야 함 Multi - Thread 메모리를 물리적으로 공유 I/O bound한 작업을 할 때 Asynchonous(비동기) I/O Multi - Threading의 약점 GIL(Global Interpreter Lock) 코어가 많아도 하나의 스레드 밖에 쓰지 못함 Race Condition(경쟁 상태) 프로세스들이 하나의 데이터를 동시에 요청할 때 원치 않은 결과가 나올 수 있음 해결 방법 : Mutual Exclusion(상호 배제) 한 프로세스가 점유한 자원을 다른 프로세스들이 접근할 수 없도록 함 Thread Pool Thread를 여러개 만든 후에 Thread 작업이 끝나면 Thread가 사라지지 않고 작업하지 않을 때는 잠시 쉼 다음 키워드들을 찾아보자. Critical Condition Critical Section Mutex Semaphore OOP 정리 Encapsulation(캡슐화) 얼마만큼 관련이 있는가? “관련있는” = single responsibility = 변수(데이터) + 함수를 하나의 단위로 묶는 것 Information Hiding(정보은닉) 어떤 멤버와 메서드를 공개하고 비공개할 것인가? Polymorphism(다형성) 상속(Inheritance) Method overriding Relation of classes IS-A 상속으로 구현 HAS-A Composition = Same life cycle, Strongly couple Aggregation = Different life cycle, Weak couple Code reusability만을 위한 거라면 composition을 사용하는 것이 좋다. SOLID Single responsibility principle 클래스가 바뀌는 이유는 단 하나의 기능 때문이어야 한다. Open-Closed principle 확장에 대해서는 열려있지만, modification은 닫혀있어야 한다. Liskov substitution principle 인터페이스 명세 부모 클래스를 상속받는 자식클래스로 만든 객체에 부모 클래스 객체를 넣어도 잘 수행되어야 한다. Interface segregation principle 꼭 필요한 메서드들만 이용할 수 있게 함 Dependency inversion principle 변화하는 부분 -&gt; 추상화","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.03.22 Python and CE Study","slug":"190322-PCE-Study","date":"2019-03-21T15:43:55.000Z","updated":"2019-05-06T16:00:13.724Z","comments":true,"path":"2019/03/22/190322-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/22/190322-PCE-Study/","excerpt":"","text":"파이썬 테스트 Problem 1 n번째 피보나치 수를 반환하는 함수를 재귀 함수와 반복문을 활용한 함수로 만들기 사용자가 매개변수로 반드시 1 이상의 수를 넣음(에러 핸들링 X) 출력 결과 &gt;&gt; 0 1 1 2 3 5 8 13 21 34 만약 n이 4이면 반환 값은 2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 재귀 함수 사용def fibo_recursion(n): if n &lt;= 1: return 0 elif n == 2: return 1 return fibo_recursion(n - 2) + fibo_recursion(n - 1)#꼬리 재귀 --&gt; while 문으로 치환 가능# 반복문 사용 - whiledef fibo_iteration_while(n): a = 0 b = 1 count = 1 while not count == n: a, b = b, a + b count += 1 return a# 반복문 사용 - fordef fibo_iteration_for(n): a = 0 b = 1 for _ in range(n - 1): a, b = b, a + b return a# 출력 확인if __name__ == \"__main__\":for i in range(1, 11): # 결과 값은 # 0 1 1 2 3 5 8 13 21 34 print(fibo_recursion(i), end = \" \")print(\"\")for i in range(1, 11): print(fibo_iteration_while(i), end = \" \")print(\"\")for i in range(1, 11): print(fibo_iteration_for(i), end = \" \")&gt;&gt; 0 1 1 2 3 5 8 13 21 34 0 1 1 2 3 5 8 13 21 34 0 1 1 2 3 5 8 13 21 34 Problem 2 피보나치 함수를 재귀함수를 통해 구현하되 내부에 캐시로 사용할 자료구조를 둠 한번 호출되었던 값은 캐시에 저장 다음번에 다시 같은 매개변수가 전달되면 연산하지 않고 캐시에 저장된 값을 바로 반환하도록 구현 캐시로 사용할 자료구조는 리스트로 한정하며 리스트는 [0, 1]부터 시작 클로저를 이용해 구현 123456789101112131415161718def make_fibo(): fibo_list = [0, 1] def inner(n): if len(fibo_list) &lt; n: fibo_list.append(inner(n - 2) + inner(n - 1)) return fibo_list[n - 1] return inner# 위와 같이 코딩하는 것을 Memoiztion --&gt; dynamic programming이라 한다.if __name__ == \"__main__\": fibo = make_fibo()# print(fibo.__name__) for i in range(1, 11): print(fibo(i), end = \" \")&gt;&gt; 0 1 1 2 3 5 8 13 21 34 OOP 상속 parent child, super sub, base denied attribute = member, method OOP에서는 외부에서 member의 변수에 접근하는 것은 절대 하지 않아야 한다. 기능을 추가한 클래스 말고 다른 클래스들은 영향을 받지 않음(Open - Closed) 클래스들과의 관계가 OOP에서 제일 중요(relations between closes) interitance(상속) composition = composition(통합), aggregation(집합) Modeling 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# modeling : 내가 만들고 있는 프로그램에서 필요한 만큼의 속성만 구현class Person: def __init__(self, name, money): # 다른 메서드에서 인스턴스 멤버를 만들 수 있지만, # 되도록이면 생성자에 넣어주도록 한다.(그 값이 나중에 바뀔지라도) self.name = name self.money = money # getter @property def money(self): print(\"getter executed\") return self.__money @money.setter # money처럼 반드시 이름을 맞춰주어야 한다. def money(self, money): print(\"setter executed\") if money &lt; 0: try: self.__money = self.__money except AttributeError: self.__money = 0 finally: return self.__money = money # property는 반드시 메서드의 이름을 맞춰준다. # access function # getter# def get_money(self):# return self.money # access function # setter# def set_money(self, money):# self.money = moneyif __name__ == \"__main__\": #생성자에 음수가 기입됐을 때 john = Person('john', -5000) # 객체의 멤버에 접근(getter)이나 수정(setter)을 할 때는 # 반드시 메서드(access function)를 이용한다!! # print(john.get_money()) # john.set_money(4000) # 유저 프로그래머는 객체의 멤버처럼 취급하면 된다. # 하지만 내부적으로는 getter 혹시 setter를 호출한다. # 반드시 메서드를 통해 실제 멤버에 접근 # getter print(john.money) # setter # 양수가 기입됐을때 john.money = 6000 print(john.money) # 음수가 기입됐을 때 john.money = - 5000 print(john.money)&gt;&gt; setter executed getter executed 0 setter executed getter executed 6000 setter executed getter executed 6000 Method Overriding 12345678910111213141516171819202122232425262728293031323334353637383940414243# 다형성(Polymophism)은 상속을 했을 때만 사용 가능# Method Overriding의 예class CarOwner: def __init__(self, name): self.name = name def concentrate(self): print(f'&#123;self.name&#125; is concentrating!!') class Car: def __init__(self, owner_name): self.car_owner = CarOwner(owner_name) def drive(self): self.car_owner.concentrate() print(f'&#123;self.car_owner.name&#125; is driving!') class SelfDrivingCar(Car): # 비슷한 기능을 자식에 맞춰서 메서드를 재정의하는것 = method overriding def drive(self): print(\"driving by itself\") if __name__ == \"__main__\": car1 = Car('john') car2 = Car('james') car3 = SelfDrivingCar('yang') cars = [] cars.extend((car1, car2, car3)) # 다형성 코드 # 결과가 다양하게 바뀔 수 있다는 의미 for car in cars: car.drive() &gt;&gt; john is concentrating!! john is driving! james is concentrating!! james is driving! driving by itself Inheritance(상속) : IS-A 모든 멤버와 메서드가 중복이 되어야 한다. 하나라도 겹치지 않으면 상속할 수 없다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Computer: def __init__(self, cpu, ram): self.cpu = cpu self.ram = ram def web_surf(self): print('surfing') def work(self): print('surfing') # IS-A(~은 ~의 한 종류이다.)# 상속의 대전제 : 모든 멤버와 메서드가 중복이 되어야 한다. 하나라도 겹치지 않으면# : 상속할 수 없다.# 재사용성(Reusability)class Laptop(Computer): # 1. 모든 멤버와 메서드가 중복된 상태에서 멤버가 추가될 때 # 메서드 오버라이딩(다형성 구현) def __init__(self, cpu, ram, battery): super().__init__(cpu, ram) self.battery = battery # 2. 메서드가 추가될 때 def move(self, where_to): print('move to &#123;&#125;'.format(where_to)) if __name__ == '__main__': com = Computer('i5', 12) com.web_surf() print(com.cpu) notebook = Laptop('i7', 32, '19V_4.1am_80W') notebook.web_surf() notebook.move('office') print(notebook.ram)&gt;&gt; surfing i5 surfing move to office 32 Composition(통합) : HAS-A 객체의 생성 시점과 소멸 시점이 같다. 12345678910111213141516171819202122class CPU: def __init__(self, man): self.man = man class RAM: def __init__(self, gi): self.gi = gi # HAS-A(~이 ~을 가지고 있다. or 포함하고 있다.)# 객체의 멤버로서 다른 객체를 포함해서 사용한다. - composition, aggregation 둘 다# composition# 객체들의 생성 시점과 소멸 시점이 같다.(same life cycle)# 아래 예제에서 cpu, ram은 강하게 커플링되어있다.(strongly coupled)# 코드 재사용성을 위해서 관계를 구축하는 거라면# 상속보다는 컴포지션을 사용한다.class Computer: def __init__(self, man, gi): self.cpu = CPU(man) self.ram = RAM(gi) Aggregation(집합) 객체의 생성과 소멸 시점이 다르다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# aggregation 예class Gun: def __init__(self, kind): self.kind = kind def bangbang(self): print(f'&#123;self.kind&#125; bangbang!!!!!') class Police: def __init__(self, name): self.name = name self.gun = None def acquire_gun(self, gun): self.gun = gun def release_gun(self): gun = self.gun self.gun = None return gun def shoot(self): if not self.gun: print('You don\\'t have a gun') # \\를 이용하여 '을 문자 그대로 사용 else: self.gun.bangbang() if __name__ == '__main__': pol = Police('john') pol2 = Police('greg') gun = Gun('revolver') pol.shoot() # police 객체가 gun 객체를 얻은 시점 # 객체 생성 시점이 다르다. pol.acquire_gun(gun) gun = None # 객체의 소유권을 넘겼을 경우, None로 처리해줘야 한다. pol2.acquire_gun(gun) pol.shoot() pol2.shoot() gun = pol.release_gun() pol.shoot() del pol # police 객체가 사라져도 gun 객체는 사라지지 않는다. # 객체 소멸 시점이 다르다.&gt;&gt; You don't have a gun revolver bangbang!!!!! You don't have a gun You don't have a gun 추상 클래스 1234567891011121314151617181920212223242526272829303132333435363738394041424344from abc import ABCMeta, abstractmethod# 추상 클래스# 1. 인스턴스를 만들 수 없다.# 2. abstract method# pure virtual method : 몸체(body)가 없는 함수# 파생 클래스에서 반드시 overriding 해야 함!!(강제 조건)# 만약 파생 클래스에서도 overriding하지 않으면 그 파생 클래스도 추상 클래스가 된다.class Animal(metaclass = ABCMeta): @abstractmethod def say(self): print('nothing') pass class Lion(Animal): def say(self): print('어흥') class Duck(Animal): def say(self): print('꽥꽥') class Dog(Animal): def say(self): print('멍멍') class Deer(Animal): def say(self): print(\"사슴\") if __name__ == '__main__': animals = [] animals.extend((Lion(), Duck(), Deer(), Dog(), Duck())) for animal in animals: animal.say()&gt;&gt; 어흥 꽥꽥 사슴 멍멍 꽥꽥","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"class","slug":"190321-Python-class","date":"2019-03-21T14:26:00.000Z","updated":"2019-06-16T15:16:55.558Z","comments":true,"path":"2019/03/21/190321-Python-class/","link":"","permalink":"http://JINUKK.github.io/2019/03/21/190321-Python-class/","excerpt":"","text":"OOP 설계 계좌 만들기 예제를 통해 구현 class 모습을 살펴보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169 # 전역 함수 : 어느 클래스에도 속하지 않는다. # OOP 설계에서는 쓰지 않는 방법이기 때문에 staticmethod 개념 존재 def func(a, b): return a + b class Account: # 클래스 이름의 맨 앞은 대문자로 하도록 하자. # 클래스 멤버(class member) # 모든 객체가 공유한다. # 전역 변수(global variable)를 대체 # ex) 이자율 interest_rate = 0.08 num_of_account = 0 # 클래스 메소드(class method) # 객체가 하나도 없는 상태에서도 호출이 가능!! # 전역 함수(global variable)를 대체 # 전역 함수를 대체할 때는 static method를 쓸 수도 있다. # 대체 생성자(alternative constructor) # cls는 클래스 자체를 받는다. # staticmethod는 메소드처럼 보이지만 함수 : 전역 함수 @staticmethod def func(a, b): return a + b @classmethod #데코레이터 def get_num_of_account(cls): \"\"\" Account.get_num_of_account() -&gt; integer \"\"\" return cls.num_of_account # 대체 생성자 # 받을 데이터에 맞춰서 설계 @classmethod def string_constructor(cls, string): data = string.split('_') clnt_name = data[0] balance = int(data[1]) return cls(clnt_name, balance) # 생성자(constructor) : 파이썬에서는 오직 하나 # 객체(object)가 생성될 때 반드시!!! 한번 호출된다. def __init__(self, clnt_name, balance): # 인스턴스 멤버(instance member) --&gt; 상태 정보 = 데이터 # self라는 말은 자기 스스로의 메모리를 가리킨다는 의미 # self는 객체 메모리를 자체 참조 self.clnt_name = clnt_name # 변수 앞에 \"__\"를 붙이면 정보 은닉으로 접근하지 말라는 표시 # 변환 규칙 중에 \"_현재클래스이름__멤버변수\"를 하면 접근 가능 self.__balance = balance # 클래스 멤버에 접근하는 방법 Account.num_of_account += 1 # 인스턴스 메소드(instance method) def deposit(self, money): \"\"\" deposit(money) --&gt; boolean 만약에 money &gt; 0이면 입금 성공! 아니면 에러 메시지 출력 후 실패! \"\"\" if money &lt; 0: print(\"입금은 0원 초과부터 가능합니다.\") return False else: self.__balance += money print(f'&#123;money&#125;원을 입금하셨고, 현재 남아있는 금액은 &#123;self.__balance&#125;원입니다.') return True # 인스턴스 메소드 def withdraw(self, money): \"\"\" withdraw(money) --&gt; integer return : 인출된 돈 만약 잔고가 모자라면 None \"\"\" if self.__balance &lt; money: print(f'현재 금액은 &#123;self.__balance&#125;원으로, 출금하실 금액 &#123;money&#125;원보다 부족하여 출금하실 수 없습니다.') return None else: self.__balance -= money print(f'&#123;money&#125;원을 출금하였고, 현재 남아있는 금액은 &#123;self.__balance&#125;원입니다.') return money def transfer(self, other, money): # 내 객체가 가진돈 self.__balance -= money # message passing # 다른 객체의 상태 정보(인스턴스 멤버)를 변경할 대는 반드시 상대 객체가 # 가진 메소드를 이용 # 절대 상대의 객체에 직접 접근하면 안된다. other.deposit(money) def __str__(self): return f'&#123;self.clnt_name&#125; : &#123;self.__balance&#125;' if __name__ == '__main__': # 객체가 생성되지 않아도 호출이 가능 print(Account.interest_rate)&gt;&gt; 0.08 print(Account.get_num_of_account()) &gt;&gt; 0 # 객체를 생성 my_acnt = Account('greg', 5000) your_acnt = Account('john', 2000) print(my_acnt.interest_rate) &gt;&gt; 0.08 print(my_acnt.get_num_of_account())&gt;&gt; 2 print(Account.func(5, 4))&gt;&gt; 9 print(type(Account.func))&gt;&gt; &lt;class 'function'&gt; print(type(Account.get_num_of_account))&gt;&gt; &lt;class 'method'&gt; print(type(my_acnt.deposit))&gt;&gt; &lt;class 'method'&gt; # 대체 생성자를 이용한 객체의 생성 s = 'james_6000' his_acnt = Account.string_constructor(s) print(his_acnt)&gt;&gt; james : 6000 # instance method 호출하는 방법 # 외부에서는 self는 자동으로 들어가기 때문에 매개 변수에 쓸 필요가 없다. my_acnt.deposit(7000)&gt;&gt; 7000원을 입금하셨고, 현재 남아있는 금액은 12000원입니다. # 메소드 vs 함수(일반) # 메소드 = 입력 + 인스턴스 멤버(상태 정보, 데이터)에 의해 결과값이 결정! # = 인스턴스 멤버(상태 정보)를 바꾸는 역할! # 함수 = 입력에 의해서 출력이 결정 res1 = my_acnt.withdraw(3000)&gt;&gt; 3000원을 출금하였고, 현재 남아있는 금액은 9000원입니다. res2 = your_acnt.withdraw(3000)&gt;&gt; 현재 금액은 2000원으로, 출금하실 금액 3000원보다 부족하여 출금하실 수 없습니다. print(my_acnt)&gt;&gt; greg : 9000 print(your_acnt)&gt;&gt; john : 2000 # 객체 간에 상호 작용 --&gt; 객체가 가지고 있는 멤버 값(데이터, 상태정보) # INTERACTRION by 메소드에 의해!! # my_acnt.transfer(your_acnt, 1000) my_acnt.transfer(your_acnt, 1000)&gt;&gt; 1000원을 입금하셨고, 현재 남아있는 금액은 3000원입니다. # 절대 짜서는 안되는 코드 # 이렇게 멤버 변수에 직접 접근하는 방법은 좋지 않다. # my_acnt.balance -= 1000 # your_acnt.balance += 1000","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"class","slug":"class","permalink":"http://JINUKK.github.io/tags/class/"}]},{"title":"2019.03.21 Python and CE Study","slug":"190321-PCE-Study","date":"2019-03-20T15:43:48.000Z","updated":"2019-05-06T15:50:59.312Z","comments":true,"path":"2019/03/21/190321-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/21/190321-PCE-Study/","excerpt":"","text":"객체 지향 프로그래밍(OOP. Object Oriented Programming) Procedual와 Object-Oriented Procedual “함수”를 이용해 추상화 Object-Oriented “객체”를 통해 추상화 현실에 존재하는 것들을 어떻게 모델링할 것인가? 객체 “관련있는” 데이터(정보, 변수) “관련있는” 변수(상태 정보)와 함수를 한데 모아놓은 ‘곳’ the bunding of data with methods attribute = instance member, instance method 객체 == 인스턴스 메모리 상으로는 둘은 완벽히 같다. 다만 객체는 객체 자체에 집중하고, 인스턴스는 특정 해당 클래스에 집중한다. 1. 캡슐화(Encapsulation) “관련있는” 멤버(데이터)와 메소드(행동)를 하나의 단위로 묶는 것 2. 정보은닉(Information Hiding) 어떤 멤버를 공개 또는 비공개할 것인가? 어떤 메소드를 공개 또는 비공개할 것인가? python에서는 완벽한 정보은닉을 제공하지 않는다.(name-mangling, property) 3. 다형성(polymorphism) 부모 클래스에서 물려받은 가상 함수를 자식 클래스 내에서 오버라이딩되어 사용되는 것 SOLID 단일책임의 원칙(SRP. Single Responsibility Principle) 개방폐쇄의 원칙(OCP, Open Close Principle) 리스코브 치환의 원칙(LSP. The Liskov Substitution Principle) 인터페이스 분리의 원칙(ISP. Interface Segregation Principle) 의존성역전의 법칙(DIP. Dependency Inversion Principle) GOF(Gang of Four) Design Pattern Creational Pattern 객체를 생성하는데 관련된 패턴들 객체가 생성되는 과정의 유연성을 높이고 코드의 유지를 쉽게 함 Class - Factory Method Object - Abstract Factory, Builder, Prototype, Singleton Structural Pattern 프로그램 구조에 관련된 패턴들 프로그램 내에 자료구조나 인터페이스 구조 등 프로그램의 구조를 설계하는 데 활용할 수 있는 패턴들 Class - Adapter Object - Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy Behavioral Pattern 반복적으로 사용되는 객체들의 상호작용을 패턴화 해놓은 것들 Class - Interpreter, Template Method Object - Chain of Responsibility, Command, Iterator, Mediator, Memento, Observer, State, Strategy, Visitor 자주 쓰는 패턴 : Singleton, Observer, Abstruct closure and function and class closure를 사용한 계좌 만들기 예제 123456789101112131415161718192021222324252627282930313233def account(clnt_name, balance): def change_money(money): nonlocal balance balance += money return (clnt_name, balance) return change_money# 상태 정보 - free variable# gloval variable - 맨 바깥쪽# local variable - 함수 내my_acnt = account('greg', 5000)your_acnt = account('john', 3000)type(my_acnt)&gt;&gt; functionmy_acnt.__name__ == your_acnt.__name__&gt;&gt; Truemy_acnt.__name__&gt;&gt; 'change_money'my_acnt(1000) # 입력 + 상태 정보 = 출력이 나온다.&gt;&gt; ('greg', 6000)your_acnt(1000)&gt;&gt; ('john', 4000)cells = my_acnt.__closure__for cell in cells: print(cell.cell_contents, end = ' ')&gt;&gt; 6000 greg 함수와 딕셔너리를 통한 계좌 만들기 예제 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889def account_init(clnt_name, balance): \"\"\" account_init(clnt_name, balance) --&gt; dictionary return : dictionary : 이름과 잔고로 반환 \"\"\" account_data = &#123;'name' : clnt_name, 'balance' : balance&#125; return account_datadef account_deposit(clnt_data, money): \"\"\" account_deposit(clnt_data, money) --&gt; boolean 만약에 money &gt; 0이면 입금 성공! 아니면 에러 메시지 출력 후 실패! \"\"\" if money &lt; 0: print(\"입금은 0원 초과부터 가능합니다.\") return False else: clnt_data['balance'] += money a = clnt_data['balance'] print('이름 : &#123;&#125; 입금 : &#123;&#125; 총액 : &#123;&#125;'.format(clnt_data['name'], money, clnt_data['balance'])) return True def account_withdraw(clnt_data, money): \"\"\" account_withdraw(clnt_data, money) --&gt; integer return : 인출된 돈 만약 잔고가 모자라면 None \"\"\" if clnt_data['balance'] &lt; money: print(f'잔액이 부족합니다.') return None else: clnt_data['balance'] -= money print('이름 : &#123;&#125; 출금 : &#123;&#125; 총액 : &#123;&#125;'.format(clnt_data['name'], money, clnt_data['balance'])) return moneydef account_transfer(clnt_data, other_data, money): \"\"\" account_transfer(clnt_data, other_data, money) --&gt; None clnt_data에서 other_data로 금액 이동 \"\"\" clnt_data['balance'] -= money account_deposit(other_data, money)if __name__ == '__main__': my_acnt = account_init('greg', 5000) your_acnt = account_init('john', 2000) print(my_acnt) print(your_acnt) print('') account_deposit(my_acnt, 5000) account_deposit(your_acnt, 8000) print(my_acnt) print(your_acnt) print('') account_transfer(my_acnt, your_acnt, 5000) print(my_acnt) print(your_acnt) print('')&gt;&gt; &#123;'name': 'greg', 'balance': 5000&#125; &#123;'name': 'john', 'balance': 2000&#125; 이름 : greg 입금 : 5000 총액 : 10000 이름 : john 입금 : 8000 총액 : 10000 &#123;'name': 'greg', 'balance': 10000&#125; &#123;'name': 'john', 'balance': 10000&#125; 이름 : john 입금 : 5000 총액 : 15000 &#123;'name': 'greg', 'balance': 5000&#125; &#123;'name': 'john', 'balance': 15000&#125; OOP를 설계를 통한 계좌 만들기 예제 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185# 전역 함수 : 어느 클래스에도 속하지 않는다.# OOP 설계에서는 쓰지 않는 방법이기 때문에 staticmethod 개념 존재def func(a, b): return a + bclass Account: # 클래스 이름의 맨 앞은 대문자로 하도록 하자. # 클래스 멤버(class member) # 모든 객체가 공유한다. # 전역 변수(global variable)를 대체 # ex) 이자율 interest_rate = 0.08 num_of_account = 0 # 클래스 메소드(class method) # 객체가 하나도 없는 상태에서도 호출이 가능!! # 전역 함수(global variable)를 대체 # 전역 함수를 대체할 때는 static method를 쓸 수도 있다. # 대체 생성자(alternative constructor) # cls는 클래스 자체를 받는다. # staticmethod는 메소드처럼 보이지만 함수 : 전역 함수 @staticmethod def func(a, b): return a + b @classmethod #데코레이터 def get_num_of_account(cls): \"\"\" Account.get_num_of_account() -&gt; integer \"\"\" return cls.num_of_account # 대체 생성자 # 받을 데이터에 맞춰서 설계 @classmethod def string_constructor(cls, string): data = string.split('_') clnt_name = data[0] balance = int(data[1]) return cls(clnt_name, balance) # 생성자(constructor) : 파이썬에서는 오직 하나 # 객체(object)가 생성될 때 반드시!!! 한번 호출된다. def __init__(self, clnt_name, balance): # 인스턴스 멤버(instance member) --&gt; 상태 정보 = 데이터 # self라는 말은 자기 스스로의 메모리를 가리킨다는 의미 # self는 객체 메모리를 자체 참조 self.clnt_name = clnt_name # 변수 앞에 \"__\"를 붙이면 정보 은닉으로 접근하지 말라는 표시 # 변환 규칙 중에 \"_현재클래스이름__멤버변수\"를 하면 접근 가능 self.__balance = balance # 클래스 멤버에 접근하는 방법 Account.num_of_account += 1 # 인스턴스 메소드(instance method) def deposit(self, money): \"\"\" deposit(money) --&gt; boolean 만약에 money &gt; 0이면 입금 성공! 아니면 에러 메시지 출력 후 실패! \"\"\" if money &lt; 0: print(\"입금은 0원 초과부터 가능합니다.\") return False else: self.__balance += money print(f'&#123;money&#125;원을 입금하셨고, 현재 남아있는 금액은 &#123;self.__balance&#125;원입니다.') return True # 인스턴스 메소드 def withdraw(self, money): \"\"\" withdraw(money) --&gt; integer return : 인출된 돈 만약 잔고가 모자라면 None \"\"\" if self.__balance &lt; money: print(f'현재 금액은 &#123;self.__balance&#125;원으로, 출금하실 금액 &#123;money&#125;원보다 부족하여 출금하실 수 없습니다.') return None else: self.__balance -= money print(f'&#123;money&#125;원을 출금하였고, 현재 남아있는 금액은 &#123;self.__balance&#125;원입니다.') return money def transfer(self, other, money): # 내 객체가 가진돈 self.__balance -= money # message passing # 다른 객체의 상태 정보(인스턴스 멤버)를 변경할 대는 반드시 상대 객체가 # 가진 메소드를 이용 # 절대 상대의 객체에 직접 접근하면 안된다. other.deposit(money) def __str__(self): return f'&#123;self.clnt_name&#125; : &#123;self.__balance&#125;' if __name__ == '__main__': # 객체가 생성되지 않아도 호출이 가능 print(Account.interest_rate) print(Account.get_num_of_account()) # 객체를 생성 my_acnt = Account('greg', 5000) your_acnt = Account('john', 2000) print(my_acnt.interest_rate) print(my_acnt.get_num_of_account()) print(Account.func(5, 4)) print(type(Account.func)) print(type(Account.get_num_of_account)) print(type(my_acnt.deposit)) # 대체 생성자를 이용한 객체의 생성 s = 'james_6000' his_acnt = Account.string_constructor(s) print(his_acnt) # instance method 호출하는 방법 # 외부에서는 self는 자동으로 들어가기 때문에 매개 변수에 쓸 필요가 없다. my_acnt.deposit(7000) # 메소드 vs 함수(일반) # 메소드 = 입력 + 인스턴스 멤버(상태 정보, 데이터)에 의해 결과값이 결정! # = 인스턴스 멤버(상태 정보)를 바꾸는 역할! # 함수 = 입력에 의해서 출력이 결정 res1 = my_acnt.withdraw(3000) res2 = your_acnt.withdraw(3000) print(my_acnt) print(your_acnt) # 객체 간에 상호 작용 --&gt; 객체가 가지고 있는 멤버 값(데이터, 상태정보) # INTERACTRION by 메소드에 의해!! # my_acnt.transfer(your_acnt, 1000) my_acnt.transfer(your_acnt, 1000) # 절대 짜서는 안되는 코드 # 이렇게 멤버 변수에 직접 접근하는 방법은 좋지 않다. # my_acnt.balance -= 1000 # your_acnt.balance += 1000&gt;&gt; 0.08 0 0.08 2 9 &lt;class 'function'&gt; &lt;class 'method'&gt; &lt;class 'method'&gt; james : 6000 7000원을 입금하셨고, 현재 남아있는 금액은 12000원입니다. 3000원을 출금하였고, 현재 남아있는 금액은 9000원입니다. 현재 금액은 2000원으로, 출금하실 금액 3000원보다 부족하여 출금하실 수 없습니다. greg : 9000 john : 2000 1000원을 입금하셨고, 현재 남아있는 금액은 3000원입니다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.03.19 Python and CE Study","slug":"190319-PCE-Study","date":"2019-03-18T15:39:24.000Z","updated":"2019-05-06T15:43:09.417Z","comments":true,"path":"2019/03/19/190319-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/19/190319-PCE-Study/","excerpt":"","text":"통계 모 분산(population variance) 모집단의 분산 관측값에서 모 평균을 빼고 그것을 제곱한 값을 모두 더하여 전체 데이터 수 n으로 나눔 표본 분산(sample variance) 표본의 분산 관측값에서 표본 평균을 빼고 제곱한 값을 모두 더한 것을 n-1로 나눔 Excel File을 python으로 바꾸기 평균 구하기 분산 구하기(모 분산) 표준 편차 구하기 1234567891011121314151617from openpyxl import load_workbookfrom functools import reduceimport mathwb = load_workbook(\"class_1.xlsx\") # 엑셀 파일을 불러옴ws = wb.activeg = ws.rowsraw_data = &#123;&#125;for name_cell, score_cell in g: raw_data[name_cell.value] = score_cell.value print(raw_data)&gt;&gt; &#123;'greg': 95, 'john': 25, 'yang': 50, 'timothy': 15, 'melisa': 100, 'thor': 10, 'elen': 25, 'mark': 80, 'steve': 95, 'anna': 20&#125; average : 학생 평균 123456scores = tuple(raw_data.values())avg = reduce(lambda a, b : a + b, scores) / len(scores)print(avg)&gt;&gt; 51.5 variance : 학생 점수 분산 1234var = reduce(lambda res, x : (x - avg)**2 + res, scores) / len(scores)print(var)&gt;&gt; 1060.525 std_dev : 표준 편차 1234std_dev = math.sqrt(var)print(std_dev)&gt;&gt; 32.56570281753489 evaluation : 평가 12345678910111213141516print(\"평균:&#123;&#125;, 분산:&#123;&#125;, 표준편차:&#123;&#125;\".format(avg, var, std_dev))if avg &lt; 50 and std_dev &gt; 20: print('성적이 너무 저조하고 학생들의 실력 차이가 너무 크다.')elif avg &gt; 50 and std_dev &gt; 20: print('성적은 평균 이상이지만 학생들의 실력 차이가 크다. 주의 요망!')elif avg &lt; 50 and std_dev &lt; 20: print('학생들의 실력 차이는 크지 않지만 성적이 너무 저조하다. 주의 요망!')elif avg &gt; 50 and std_dev &lt; 20: print('성적도 평균 이상이고 학생들의 실력 차이도 크지 않다.') &gt;&gt; 평균:51.5, 분산:1060.525, 표준편차:32.56570281753489 성적은 평균 이상이지만 학생들의 실력 차이가 크다. 주의 요망! 절차 지향(procedural oriented) 프로그래밍 라이브러리 개발자가 하는일 123456789101112131415161718192021from openpyxl import load_workbookfrom functools import reduceimport mathdef get_raw_data(filename): \"\"\" get_raw_data(filename) -&gt; dict # dict = &#123;'name1' : score1, 'name2' : score2, 'name3' : score3 ...&#125; 결과값으로 딕셔너리를 반환 \"\"\" wb = load_workbook(filename) ws = wb.active raw_data = &#123;&#125; for name_cell, score_cell in ws.rows: raw_data[name_cell.value] = score_cell.value return raw_data 래핑 함수(wrapping function) 123456789101112# 기본 기능을 감싸는 새로운 기능을 만드는 방법def get_scores_tuple(dict_data): \"\"\" get_scores_tuple(dict) -&gt; tuple dict = &#123;'name1' : score1, 'name2' : score2, 'name3' : score3 ...&#125; ret : (score1, score2, score3) \"\"\" scores_data = tuple(dict_data.values()) return scores_data average : 학생 평균 123456789def get_average(scores_data): \"\"\" get_average(scores_data) -&gt; float&lt;2&gt; scores_data --&gt; tuple of scores ret : float : 소수점 이하 두 자리 반환 \"\"\" avg = reduce(lambda a, b: a + b, scores_data) / len(scores_data) return round(avg, 2) # round() : 소수점 제한 함수 variance : 학생 점수 분산 1234567891011def get_variance(scores_data, avg): \"\"\" get_variance(scores_data, avg) -&gt; float&lt;2&gt; scores_data --&gt; tuple of scores avg --&gt; 평균 ret : float : 분산 : 소수점 이하 두 자리 반환 \"\"\" var = reduce(lambda res, x : (x - avg)**2 + res, scores_data) / len(scores_data) return round(var, 2) std_dev : 표준 편차 1234567891011def get_std_dev(var): \"\"\" get_std_dev(var) -&gt; float&lt;2&gt; var --&gt; 분산 ret : float : 표준 편차 : 소수점 이하 두 자리 반환 결과값으로 표준 편차 반환(소숫점 두자리까지 표시) \"\"\" std_dev = math.sqrt(var) return round(std_dev, 2) evaluation : 평가 1234567891011121314151617181920def get_evaluation(avg, total_avg, std_dev, sd = 20): \"\"\" get_evaluation(avg, total_avg, var, std_dev, sd = 20) -&gt; None avg : your class avg total_avg : 학년 평균 std_dev : 우리 반 평균 sd : 원하는 표준 편차를 입력하세요. 20 정도면 무난합니다. \"\"\" if avg &lt; total_avg and std_dev &gt; sd: print('성적이 너무 저조하고 학생들의 실력 차이가 너무 크다.') elif avg &gt; total_avg and std_dev &gt; sd: print('성적은 평균 이상이지만 학생들의 실력 차이가 크다. 주의 요망!') elif avg &lt; total_avg and std_dev &lt; sd: print('학생들의 실력 차이는 크지 않지만 성적이 너무 저조하다. 주의 요망!') elif avg &gt; total_avg and std_dev &lt; sd: print('성적도 평균 이상이고 학생들의 실력 차이도 크지 않다.') if name ==”main”을 사용함으로서 테스트로 코드를 실행할 수 있다. name == “main” 조건이 없다면 위 함수를 실행할 때마다 테스트 코드도 매번 같이 실행하게 된다. name == “main”이 있음으로 해당 함수를 import로 쓰지 않고 직접 사용하게 되면 테스트 코드가 실행하게 된다. 123456789101112131415161718192021222324if __name__ == \"__main__\": raw_data = get_raw_data(\"class_1.xlsx\") print(raw_data) avg = get_average(get_scores_tuple(raw_data)) print(avg) var = get_variance(get_scores_tuple(raw_data), avg) print(var) std_dev = get_std_dev(var) print(std_dev) print(\"평균: &#123;&#125;, 분산:&#123;&#125;, 표준편차:&#123;&#125;\".format(avg, var, std_dev)) get_evaluation(avg, 50, std_dev)&gt;&gt; &#123;'greg': 95, 'john': 25, 'yang': 50, 'timothy': 15, 'melisa': 100, 'thor': 10, 'elen': 25, 'mark': 80, 'steve': 95, 'anna': 20&#125; 51.5 1060.53 32.57 평균: 51.5, 분산:1060.53, 표준편차:32.57 성적은 평균 이상이지만 학생들의 실력 차이가 크다. 주의 요망! USER PROGRAMMER 라이브러리를 사용하여 프로그램 설계 하드 코딩을 하지 않도록 설계 1234567891011121314151617181920212223242526272829303132333435363738394041424344import sysfrom functions import (get_raw_data, get_scores_tuple, get_average, get_variance, get_std_dev, get_evaluation)# from의 의미는 functions의 모든 코드를 다 가져다가 붙인다는 말# import 함수를 추가할 때 너무 길어진다면 tuple처럼 ()를 사용하여 다음 줄 이용# import 뒤에 *(별표)를 사용하면 해당 모듈이 모든 함수를 import한다는 뜻# 이렇게 되면 사용하지 않는 함수도 import하기 때문에 속도가 느려질 수 있음# 사용하는 함수들만 명시를 해주는 것이 좋다.if not len(sys.argv) == 3 and not len(sys.argv) == 4: print(\"usage : python main.py &lt;exel filename&gt; &lt;total_avg&gt; &lt;sd = 20&gt;\") exit(-1) # exit() : 프로그램을 종료하고 싶을 때 사용.# 내부 숫자는 프로그램이 정상 또는 비정상적으로 종료되었다는 것을 알림filename = sys.argv[1]total_avg = float(sys.argv[2])if len(sys.argv) == 4: sd = float(sys.argv[3]) raw_data = get_raw_data(filename)socres = get_scores_tuple(raw_data)avg = get_Average(scores)var = get_variance(socres, avg)std_dev = get_std_dev(var)print(f'평균 : &#123;avg&#125;, 분산 : &#123;var&#125;, 표준편차 : &#123;std_dev&#125;')if len(sys.argv) == 4: get_evaluation(avg, total_avg, std_dev, sd)elif len(sys.argv) == 3: get_evaluation(avg, total_avg, std_dev) ## visual studio code에서는 함수의 매개 변수 칸에 ctrl + shift + space를 누르면 함수 설명이 나온다. sys.argv를 사용하여 직접 프로그램을 실행할 때 원하는 값 입력 가능 sys.argv[0]은 실행하는 소스의 이름 sys.argv[1]부터 지정 가능 sys.argv의 반환값은 모두 string 형이기 때문에 만약 숫자를 사용하고 싶다면 int와 float처럼 형변환을 해야 한다. 내가 만든 라이브러리를 같은 폴더가 아니어도 불러오고 싶다면… Python / Python 37-32 / Lib / site-packages 안에 파일을 넣음 개인적으로 만든 라이브러리를 넣는 것을 비추천 라이브러리를 담아두는 폴더를 만든 후에 환경 변수 경로를 지정 visual studio code 터미널 창에 아래와 같이 치면 된다. “$env:PYTHONPATH = 경로” 해당 경로는 라이브러리가 있는 폴더를 가리키면 된다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.03.18 Python and CE Study","slug":"190318-PCE-Study","date":"2019-03-17T15:36:33.000Z","updated":"2019-05-06T15:37:47.472Z","comments":true,"path":"2019/03/18/190318-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/18/190318-PCE-Study/","excerpt":"","text":"Linux Terminal Basic top : cpu 프로세스 상황 보여주기 PID : Process ID 1%cpu(s), us(user), sy(system), id(idle), hi(hardware interrupt), si(software interrupt), st(steal time) F를 누르면 fields management로 진입 Q로 나갈 수 있음 VIRT : Virtual Image(KB) = Virtual Address Space RES = Resident Size = RAM에 있는 page의 총 합 F에서 D를 누르면 Field로 가져옴 man : manual executable code = code segment mkdir = make directory “=”을 누르면 top에서 모든 것을 다시 볼 수 있음 Demand paging 메모리 관리 메커니즘(MMU 메커니즘)을 사용해서 여러 프로세스가 시스템의 메모리를 효율적으로 공유할 수 있도록 하는 기술 페이지들이 실행 과정에서 실제로 필요해질 때 RAM에 올리는 것 Segmentation with paging 모든 메모리를 Segment로 쪼개고 각 Segment들을 Paging해서 메모리에 올리고 접근하는 방식 현재 모든 운영체제가 이런 방식 Shared memory(공유 메모리) 같은 메모리는 공유해서 씀(다른 프로세스 상에서) 여러 프로그램이 동시에 접근할 수 있는 메모리 Excel File을 python으로 바꾸기 사무 자동화 방법 1 123456789101112131415161718import openpyxl as opwb = op.load_workbook(\"exam.xlsx\") # 엑셀 파일을 불러옴ws = wb.activecell_count = list(ws.rows)cell_values = list(ws.values)li = []for i in range(1, len(cell_count)): dic = &#123;key : value for key, value in zip(cell_values[0], cell_values[i])&#125; li.append(dic)# zip는 동일한 갯수의 인덱스를 갖는 시퀀스 자료형을 묶어주는 함수# li를 출력해서 확인하자. 방법 2 12345678910111213141516g = ws.rowscells = next(g) # iterator 객체에서 내장 함수 next를 쓰면 다음 데이터를 불러옴keys = []for cell in cells: keys.append(cell.value) student_data = []for row in g: dic = &#123;k : c.value for k, c in zip(keys, row)&#125; student_data.append(dic)# student_data를 출력해서 확인하자.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"얕은 복사(shallow copy)와 깊은 복사(deep copy)","slug":"190315-Python-copy","date":"2019-03-15T14:19:31.000Z","updated":"2019-06-18T05:07:49.864Z","comments":true,"path":"2019/03/15/190315-Python-copy/","link":"","permalink":"http://JINUKK.github.io/2019/03/15/190315-Python-copy/","excerpt":"","text":"리스트 예시 12345678910li = [1, 2, 3]# 참조(reference). 둘은 완벽하게 같은 객체.li2 = lili2&gt;&gt; [1, 2, 3]li2.append(4)li&gt;&gt; [1, 2, 3, 4] 얕은 복사(shallow copy) 얕은 복사를 하면 공간을 복사해서 다른 공간이 생긴다. 하지만 바라보고 있는 대상이 리스트 안에 리스트일 경우는 다르다. 이름 객체가 같은 곳을 바라보고 있기 때문에 기존 대상과 같이 바뀌게 된다. pythontutor.com을 통해 이해하자. 12345678910111213141516171819202122232425262728293031li3 = li.copy() # 얕은 복사li3&gt;&gt; [1, 2, 3, 4]li3.append(5)li3&gt;&gt; [1, 2, 3, 4, 5]li&gt;&gt; [1, 2, 3, 4]# 리스트 안에 리스트를 넣을 경우li = [1, 2, 3, 4, [6, 7]]li3 = li.copy() # 얕은 복사li3&gt;&gt; [1, 2, 3, 4, [6, 7]]# 리스트 안에 리스트에 요소 값 추가li3[4].append(8)li3&gt;&gt; [1, 2, 3, 4, [6, 7, 8]]# 원래 있던 리스트 안 리스트도 바뀜li&gt;&gt; [1, 2, 3, 4, [6, 7, 8]] 깊은 복사(deep copy) 깊은 복사를 하면 완전히 다른 객체를 만들어버린다. 기존 대상이 복사한 대상과 같지 않다. pythontutor.com을 통해 이해하자.1234567891011121314import copyli4 = copy.deepcopy(li) # 깊은 복사li4&gt;&gt; [1, 2, 3, 4, [6, 7, 8]]li4[4][1] = 10li4&gt;&gt; [1, 2, 3, 4, [6, 10, 8]]li&gt;&gt; [1, 2, 3, 4, [6, 7, 8]]","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"copy","slug":"copy","permalink":"http://JINUKK.github.io/tags/copy/"}]},{"title":"2019.03.15 Python and CE Study","slug":"190315-PCE-Study","date":"2019-03-14T15:31:39.000Z","updated":"2019-05-06T15:34:01.880Z","comments":true,"path":"2019/03/15/190315-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/15/190315-PCE-Study/","excerpt":"","text":"얕은 복사(shallow copy) vs 깊은 복사(deep copy) 리스트 예시 12345678910li = [1, 2, 3]# 참조(reference). 둘은 완벽하게 같은 객체.li2 = lili2&gt;&gt; [1, 2, 3]li2.append(4)li&gt;&gt; [1, 2, 3, 4] 얕은 복사(shallow copy) 얕은 복사를 하면 공간을 복사해서 다른 공간이 생긴다. 하지만 바라보고 있는 대상이 리스트 안에 리스트일 경우는 다르다. 이름 객체가 같은 곳을 바라보고 있기 때문에 기존 대상과 같이 바뀌게 된다. pythontutor.com을 통해 이해하자. 1234567891011121314151617181920212223242526li3 = li.copy() # 얕은 복사li3&gt;&gt; [1, 2, 3, 4]li3.append(5)li3&gt;&gt; [1, 2, 3, 4, 5]li&gt;&gt; [1, 2, 3, 4]# 리스트 안에 리스트를 넣을 경우li = [1, 2, 3, 4, [6, 7]]li3 = li.copy() # 얕은 복사li3&gt;&gt; [1, 2, 3, 4, [6, 7]]# 리스트 안에 리스트에 요소 값 추가li3[4].append(8)li3&gt;&gt; [1, 2, 3, 4, [6, 7, 8]]# 원래 있던 리스트 안 리스트도 바뀜li&gt;&gt; [1, 2, 3, 4, [6, 7, 8]] 깊은 복사(deep copy) 깊은 복사를 하면 완전히 다른 객체를 만들어버린다. 기존 대상이 복사한 대상과 같지 않다. pythontutor.com을 통해 이해하자. 123456789101112import copyli4 = copy.deepcopy(li) # 깊은 복사li4&gt;&gt; [1, 2, 3, 4, [6, 7, 8]]li4[4][1] = 10li4&gt;&gt; [1, 2, 3, 4, [6, 10, 8]]li&gt;&gt; [1, 2, 3, 4, [6, 7, 8]] Computer Engineering Instruction Cycle(명령 주기) fetch PC(Program Counter)가 가리키고 있던 Instruction을 Memory로부터 가져옴 decode CU(Control Unit)이 IR(Instruction Register)에 있는 값을 가지고 분석 및 해석 execute 실제로 동작(실행) Memory Layout(Segment) 메모리 영역은 크게 다음과 같이 나뉜다.(stability) 프로그래머들이 코딩할 수 있는 User 영역 OS 관련 코드가 있는 Kernel 영역 User 영역에서 함부로 Kernel 영역에 접근할 수 없다.(security) window 98에서는 Kernel 영역의 메모리를 바꿀 수 있어서 위험했다.(블루 스크린) User 영역은 다음과 같다. code segment Instruction이 된 코드가 저장됨 data segment 전역 변수 저장 초기값이 있으면 data 영역에 할당 초기값이 없으면 BSS 영역에 할당 프로세스가 시작될 때 생성되고, 프로세스가 종료될 때 소멸됨 heap segment 프로그래머가 원할 때 지정할 수 있는 영역 프로그래머가 원할 때 생성하고 소멸할 수 있음 stack segment 지역 변수 저장 함수가 호출될 때 생성되고, 함수가 종료될 때 소멸됨 stack 크기는 기본적으로 1MB가 잡혀있다. heap은 크기가 제한되어 있지 않아서 stack 공간을 만날 때까지 계속 커질 수 있다. Heap 단점 메모리 누수(memory leak) 느리다.(malloc이 느리다.) 메모리 단편화(memory fragmentation) 2번과 3번이 연관됨 Stack과 Heap 비교 Stack stack pointer가 top을 가리키고 있기 때문에 할당할 지점을 찾을 필요가 없다. 그래서 stack은 빠르다. Heap 메모리에 비어있는 공간을 찾아야 한다. memory header는 몇바이트가 저장되는지 기억하고 있다. 전체 메모리 상에서는 충분하나, 조각조각으로 나뉘어져 있는 부분을 더한 것이기 때문에 단편화가 일어난다. 1238byte의 메모리 공간이 필요한 시점에서...4byte, 4byte, 2byte의 메모리들을 더하면 10byte로 충분해보인다.하지만 나누어져 있는 메모리이기 때문에 사용이 불가하다. Default Heap 프로세스가 생성될 때 제일 먼저 잡히는 heap 공간 Dynamic heap 내가 원하는 만큼 heap의 크기를 받아서 조절해서 프로그램하는 것 dynamic heap으로 구현한 것 중 하나가 python이다. dynamic heap을 통해 memory 단편화를 해결할 수 있다. Garbage collection 언어 차원에서 메모리를 관리해주는 것(heap을 관리해줌) reference counter 값이 0이 된 메모리를 지워준다. import sys의 sys.getrefcount() 함수 사용 가능 카운트 값은 실제 카운트 값보다 1이 큰 값 C++도 shared counter 기법을 통해 메모리 누수 문제를 해결할 수 있다. 가상 주소 공간(VAS. Virtual Address Space) OS가 프로세스가 시작될 때 할당해주는 가상 메모리 공간 Virtual Memory = RAM + Page file OS가 프로세스를 시작하면 4GB를 할당해준다. 즉, 프로세스가 페이지 테이블을 Main Memory에 만들고 페이지 테이블의 첫 주소를 가르쳐준다. Logical address(논리 주소) VAS에 있는 메모리 주소 Physical address(물리 주소) Main memory에 있는 메모리 주소 0x00000000 ~ 0xFFFFFFFF 중에서 앞에 0x”00000”까지가 주소를 가리킨다. 나머지 뒤에 0x”000”이 Offset(해당 페이지 시작으로부터 주소까지 거리)이다. 즉, 논리 주소(LA)를 물리 주소(PA)로 바꾸려면 앞 5자리만 바꾸면 된다. Page Table VAS에서의 논리 주소(LA)와 물리 주소(PA)가 기록된다. 두 주소가 모두 올라와 있으면 1로, 아니면 0으로 판단하는 유효 비트(valid bit)도 존재 한다. MMU(Memory Management Unit) PC가 가리키고 있는 논리 주소(LA)를 물리 주소(PA)로 바꿔준다. run-time mapping Preparing 프로그램을 실행하면 page table이 만들어진다. page table에서 지금 당장 필요할 것 같은 코드를 HDD에서 main memory로 가져오는 것을 말한다. Page Fault CPU가 logical memory를 요구하면 MMU가 physical memory로 바꿔서 가져온다. page table에 physical memory가 없고, vaild bit가 0인 상황이다. 이렇게 되면 HDD에서 원하는 데이터를 main memory에 올린다. 그 후, page table의 physical address를 가져오고 valid bit가 1이 되서 다시 동작하게 된다. 제일 처음에 메모리를 가져올 때에는 page fault가 무조건 일어나게 된다. 메모리를 가져올 때까지는 아무런 동작을 할 수 없다. Thrashing CPU 프로그램 처리 시간보다 page 교체에 더 많은 시간을 보내는 것을 말한다. main memory의 page 부재가 비정상적으로 많이 발생하여 CPU가 프로그램 처리보다 페이지 교체에 더 많은 시간을 보내 성능이 급격히 줄어드는 현상이다. 멀티 프로세싱 기능을 갖춘 시스템에서 가상 메모리의 페이지 부재(page fault)가 너무 많이 발생하여 프로세스 실행보다 페이지 교체에 더 많은 시간을 소모하는 현상이다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.03.14 Python and CE Study","slug":"190314-PCE-Study","date":"2019-03-13T15:26:22.000Z","updated":"2019-06-10T01:33:53.881Z","comments":true,"path":"2019/03/14/190314-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/14/190314-PCE-Study/","excerpt":"","text":"Computer Engineering CPU의 구조 CU(Control Unit) Instruction code(machine code) execution(0과 1의 코드를 실행) ALU(Arithmetic Logic Unit) +, -, *, /, &amp;, |, ^의 연산, 비교 수행 Register(레지스터) General Purpose Register(범용 레지스터) AX, BX, CX 등등 데이터를 일시적으로 저장 PC(Program Counter) 다음에 실행될 인스트럭션이 메인 메모리에서 저장된 곳의 주소값을 저장하는 레지스터 IR(Instruction Register) CU가 현재 실행 중인 인스트럭션 자체가 저장된 레지스터 CU가 이 곳을 참조하여 실행 Stack Pointer stack frame을 생성하고 stack segment의 맨 꼭대기(Top)를 가리킴 Base Pointer(Frame Pointer) stack frame 내에서 변수(데이터, 메모리)에 접근하는 기준점 CPU와 Memory(RAM) 관계 CPU와 Memory(RAM) 사이에는 address bus, control bus, data bus로 연결되어 있다. bit 수에 따라 address bus와 data bus의 수가 결정된다. address bus를 통해 주소를 메모리에 전송하면, 메모리는 지정된 주소의 데이터를 data bus에 실어보낸다. Memory(RAM)는 위에서부터 code, data, heap, stack 공간으로 이루어져 있다. 메모리 자체 내에서 연산이 수행되서 들어가는 것이 아니다. 범용 레지스터 AX, BX에서 연산한 것을 한번 더 AX에 저장한 후, RAM으로 가져오는 것이다. Instruction 의미 1기계어 &lt;--mapping--&gt; 어셈블리어 ex) C code를 기계어로 변환한 것 RISC(Reduced Instruction Set Computer) 기계어와 어셈블리어 매칭이 1:1 CISC(Complex Instruction Set Computer) 기계어와 어셈블리어 매칭이 비슷 Clock(클럭) Instruction을 실행하거나 실행되고 있는 시간 GHz = 주파수(frequency) 주기(Period) = 1/주파수 = sec/cycle Rising Edge(상승 에지)가 없으면 데이터를 보낼 수 없다. CPI(Clock Cycles Per Instruction) 인스터럭션 당 걸리는 수 Stack Segment Stack Pointer - esp 스택 영역의 맨 꼭대기(Top)를 가리킨다. Base Pointer(Frame Pointer) - ebp 스택 프레임 기준(가운데)을 가리킨다. 함수 안에 있는 값을 접근할 때 Base Pointer를 기준으로 접근한다. 함수가 호출될 때 최초에 함수가 호출되면 frame이 깨지지 않기 위해 미리 공간을 확보한다. stack segemet에서는 메모리가 거꾸로 쌓이기 때문에 주소값에 마이너스를 해야 공간이 늘어난다. 함수가 끝나고 다시 호출되었던 자리로 돌아가기 위해 Return Address(ret)도 stack에 쌓아둔다. Memory hierarchy(메모리 계층) 계층 순위 Register Cache Memory(RAM) Hard Disk(HDD) 사이클 Register 다른 Register Register Cache Register Memory(RAM) Register HDD 요즘에는 SSD도 있지만, 메모리 계층에서는 HDD와 SSD가 동급이다. 계층 순위가 올라갈수록 빠르고, 용량이 적으며, 값이 비싸다. 반드시 HDD -&gt; Memory -&gt; Cache -&gt; Register 순으로 저장된다. HDD에서 Register로 한번에 가져올 수는 없다. Memory(RAM)에도 buffer, Cache라는 공간이 있어서, HDD, SSD에서 가져온 값을 담아둘 수 있다. Cache에 대해 Principle of locality Temporal locality(시간 지연성) 한번 접근한 메모리에 자주 접근 Spatial locality(공간 지연성) 접근하는 메모리가 이전에 접근한 메모리의 근처일 확률이 높음 Cache line CPU가 Cache한테 데이터를 요청했을 때, 그 주변 데이터를 모두 가져옴(64 ~ 128byte) Cache Hit CPU가 요청한 데이터가 Cache에 있을 때 Cache miss CPU가 요청한 데이터가 Cache에 없을 때 메모리를 다시 가져와야 하는 상황 Cache Memory L1, L2, L3로 이루어짐 속도는 L1 &gt; L2 &gt; L3 용량은 L1 &lt; L2 &lt; L3 요즘 Cache L1은 CPU 안에 있다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"calculator","slug":"190313-Algorithm-calculator","date":"2019-03-13T10:15:36.000Z","updated":"2019-06-16T14:14:16.657Z","comments":true,"path":"2019/03/13/190313-Algorithm-calculator/","link":"","permalink":"http://JINUKK.github.io/2019/03/13/190313-Algorithm-calculator/","excerpt":"","text":"후위 표기법을 이용한 정수형 계산기 만들기 3*5 처럼 연산자가 중간에 있는 경우를 중위 표기법이라고 한다. *35 처럼 연산자가 앞에 있는 경우를 전위 표기법이라고 한다. 35* 처럼 연산자가 뒤에 있는 경우를 후위 표기법이라고 한다. 123456789101112후위 표기법- 컴퓨터가 계산하기 쉬운 수식- 괄호가 없다.- 연산자가 뒤에 위치[ 후위 표기법 적용 예 ](3 + 2 * 2 - 4) * 3 + 2 * (5 - 7) = 322 * + 4 - 3 * 257 - * +5 * 7 - 5 / 3 + 2 + 5 * 3 = 57 * 53 / - 2 + 53 * +7 - 3 * 5 / 2 + (3 * 5 - 2 * 3) = 735 * 2 / - 35 * 23 * - +6 * (5 - 2 * 3) - (3 * 2 + 3 / 2 + 1) = 6523 * - * 32 * 32 / + 1 + - 입력 시 피연산자는 1자리로 한다. 연산자(Operator) : 연산을 수행하는 기호 피연산자(Operand) : 연산에 참여하는 변수나 상수 정수 연산이므로 ‘//‘ 사용 stack 사용 후위 표기법으로 만드는 법 최종 후위 수식을 담을 수식 리스트와 연산자를 가중치에 따라 담을 스택 리스트 필요 각 연산자마다 가중치를 두어야 함 1순위 : *, / 2순위 : +, - 3순위 : (, ) 수식 리스트에는 피연산자를 무조건 넣는다. 연산자를 만나면 스택 리스트에 들어가는데 다음과 같은 규칙이 있다. “(“는 스택 리스트에 연산자가 있건 없건 무조건 넣는다. 연산자를 넣을 때, 가중치가 높으면 무조건 넣는다. 가중치가 같으면 그 전에 쌓여있던 연산자를 빼서 수식 리스트에 넣는다. 넣는 연산자 가중치가 작을 경우, 그 전에 쌓여있던 연산자를 빼서 수식 리스트에 넣는다. 그 다음으로 넣을 때에도 가중치 비교를 계속해서 넣는다. “)”를 만나면 “(“ 위에 쌓여 있는 모든 연산자를 수식 리스트에 넣는다. 함수를 구현할 때 하나의 함수로 끝내는 것은 좋지 않다. 기능을 가지고 있는 함수를 여러 개 만들어서 절차 지향적으로 실행하도록 한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135class Stack: def __init__(self): self.container = list() def empty(self): if not self.container: return True else: return False def push(self, data): self.container.append(data) def pop(self): return self.container.pop() def peek(self): return self.container[-1]def get_weight(opr): \"\"\" get_weight(string) --&gt; int 연산자 비교를 위해 정수형 값을 반환 \"\"\" if opr == '*' or opr == '/': result = 2 elif opr == '+' or opr == '-': result = 1 elif opr == '(' or opr ==')': result = 0 return resultdef conv_pfx(exp): \"\"\" conv_pfx(string) --&gt; string 연산자와 피연산자를 후위표기법으로 변환 \"\"\" re_exp = exp.replace(' ', '') listExp = [] oprStk = Stack() for i in range(len(re_exp)): if re_exp[i] == '*' or re_exp[i] == '/' or re_exp[i] == '+' or re_exp[i] == '-': if oprStk.empty(): oprStk.push(re_exp[i]) else: while get_weight(re_exp[i]) &lt;= get_weight(oprStk.peek()): listExp.append(oprStk.pop()) if oprStk.empty(): break oprStk.push(re_exp[i]) elif re_exp[i] == '(': oprStk.push(re_exp[i]) elif re_exp[i] == ')': while not oprStk.peek() == '(': listExp.append(oprStk.pop()) oprStk.pop() else: listExp.append(re_exp[i]) if i == len(re_exp) - 1: while not oprStk.empty(): listExp.append(oprStk.pop()) return ''.join(listExp)def operator(f_num, l_num, opr): \"\"\" operator(int, int, string) --&gt; int 연산자에 따라 연산을 수행하여 정수형 반환 \"\"\" if opr == '*': return f_num * l_num elif opr == '/': return f_num // l_num elif opr == '+': return f_num + l_num elif opr == '-': return f_num - l_numdef calculator(exp): \"\"\" calculator(string) --&gt; int 문자열 수식을 넣으면 결과값을 정수형으로 반환 \"\"\" pfx_exp = conv_pfx(exp) oprStk = Stack() for i in range(len(pfx_exp)): if pfx_exp[i] == '*' or pfx_exp[i] == '/' or pfx_exp[i] == '+' or pfx_exp[i] == '-': l_num = int(oprStk.pop()) f_num = int(oprStk.pop()) oprStk.push(str(operator(f_num, l_num, pfx_exp[i]))) else: oprStk.push(pfx_exp[i]) if i == len(pfx_exp) - 1: result = int(oprStk.pop()) return result# 계산기 테스트exp1 = '(3 + 2 * 2 - 4) * 3 + 2 * (5 - 7)'print(conv_pfx(exp1))print(calculator(exp1))&gt;&gt; 322*+4-3*257-*+ 5exp2 = '5 * 7 - 5 / 3 + 2 + 5 * 3'print(conv_pfx(exp2))print(calculator(exp2))&gt;&gt; 57*53/-2+53*+ 51","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://JINUKK.github.io/categories/Algorithm/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://JINUKK.github.io/tags/algorithm/"},{"name":"caculator","slug":"caculator","permalink":"http://JINUKK.github.io/tags/caculator/"}]},{"title":"2019.03.13 Python and CE Study","slug":"190313-PCE-Study","date":"2019-03-12T15:19:42.000Z","updated":"2019-06-16T14:16:44.312Z","comments":true,"path":"2019/03/13/190313-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/13/190313-PCE-Study/","excerpt":"","text":"ADT(Abstract Data Type) 추상 자료형 operation의 list(내부 구조체는 나열하지 않음) 어떤 자료구조가 가지고 있는 operation(함수)의 나열(블록) 함수 signature(interface)만 나열할 뿐 내부 구현을 표시하지 않음 - 추상화 operation(함수)의 작동 방식 설명 Stack and Queue 데이터를 일시적으로 저정할 때 많이 사용 Stack LIFO(Last In First Out) 후입선출 나중에 들어온 것이 제일 먼저 나가는 방식 ex) 접시 쌓기 linked list python list - 기초 자료구조 자료구조에 반드시 포함되어야 할 것 - insert, search, delete Coding Practice 후위 표기법을 이용한 정수형 계산기 만들기 3*5 처럼 연산자가 중간에 있는 경우를 중위 표기법이라고 한다. *35 처럼 연산자가 앞에 있는 경우를 전위 표기법이라고 한다. 35* 처럼 연산자가 뒤에 있는 경우를 후위 표기법이라고 한다. 123456789101112후위 표기법- 컴퓨터가 계산하기 쉬운 수식- 괄호가 없다.- 연산자가 뒤에 위치[ 후위 표기법 적용 예 ](3 + 2 * 2 - 4) * 3 + 2 * (5 - 7) = 322 * + 4 - 3 * 257 - * +5 * 7 - 5 / 3 + 2 + 5 * 3 = 57 * 53 / - 2 + 53 * +7 - 3 * 5 / 2 + (3 * 5 - 2 * 3) = 735 * 2 / - 35 * 23 * - +6 * (5 - 2 * 3) - (3 * 2 + 3 / 2 + 1) = 6523 * - * 32 * 32 / + 1 + - 입력 시 피연산자는 1자리로 한다. 연산자(Operator) : 연산을 수행하는 기호 피연산자(Operand) : 연산에 참여하는 변수나 상수 정수 연산이므로 ‘//‘ 사용 stack 사용 후위 표기법으로 만드는 법 최종 후위 수식을 담을 수식 리스트와 연산자를 가중치에 따라 담을 스택 리스트 필요 각 연산자마다 가중치를 두어야 함 1순위 : *, / 2순위 : +, - 3순위 : (, ) 수식 리스트에는 피연산자를 무조건 넣는다. 연산자를 만나면 스택 리스트에 들어가는데 다음과 같은 규칙이 있다. “(“는 스택 리스트에 연산자가 있건 없건 무조건 넣는다. 연산자를 넣을 때, 가중치가 높으면 무조건 넣는다. 가중치가 같으면 그 전에 쌓여있던 연산자를 빼서 수식 리스트에 넣는다. 넣는 연산자 가중치가 작을 경우, 그 전에 쌓여있던 연산자를 빼서 수식 리스트에 넣는다. 그 다음으로 넣을 때에도 가중치 비교를 계속해서 넣는다. “)”를 만나면 “(“ 위에 쌓여 있는 모든 연산자를 수식 리스트에 넣는다. 함수를 구현할 때 하나의 함수로 끝내는 것은 좋지 않다. 기능을 가지고 있는 함수를 여러 개 만들어서 절차 지향적으로 실행하도록 한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145class Stack: def __init__(self): self.container = list() def empty(self): if not self.container: return True else: return False def push(self, data): self.container.append(data) def pop(self): return self.container.pop() def peek(self): return self.container[-1]def get_weight(opr): \"\"\" get_weight(string) --&gt; int 연산자 비교를 위해 정수형 값을 반환 \"\"\" if opr == '*' or opr == '/': result = 2 elif opr == '+' or opr == '-': result = 1 elif opr == '(' or opr ==')': result = 0 return resultdef conv_pfx(exp): \"\"\" conv_pfx(string) --&gt; string 연산자와 피연산자를 후위표기법으로 변환 \"\"\" re_exp = exp.replace(' ', '') listExp = [] oprStk = Stack() for i in range(len(re_exp)): if re_exp[i] == '*' or re_exp[i] == '/' or re_exp[i] == '+' or re_exp[i] == '-': if oprStk.empty(): oprStk.push(re_exp[i]) else: while get_weight(re_exp[i]) &lt;= get_weight(oprStk.peek()): listExp.append(oprStk.pop()) if oprStk.empty(): break oprStk.push(re_exp[i]) elif re_exp[i] == '(': oprStk.push(re_exp[i]) elif re_exp[i] == ')': while not oprStk.peek() == '(': listExp.append(oprStk.pop()) oprStk.pop() else: listExp.append(re_exp[i]) if i == len(re_exp) - 1: while not oprStk.empty(): listExp.append(oprStk.pop()) return ''.join(listExp)def operator(f_num, l_num, opr): \"\"\" operator(int, int, string) --&gt; int 연산자에 따라 연산을 수행하여 정수형 반환 \"\"\" if opr == '*': return f_num * l_num elif opr == '/': return f_num // l_num elif opr == '+': return f_num + l_num elif opr == '-': return f_num - l_numdef calculator(exp): \"\"\" calculator(string) --&gt; int 문자열 수식을 넣으면 결과값을 정수형으로 반환 \"\"\" pfx_exp = conv_pfx(exp) oprStk = Stack() for i in range(len(pfx_exp)): if pfx_exp[i] == '*' or pfx_exp[i] == '/' or pfx_exp[i] == '+' or pfx_exp[i] == '-': l_num = int(oprStk.pop()) f_num = int(oprStk.pop()) oprStk.push(str(operator(f_num, l_num, pfx_exp[i]))) else: oprStk.push(pfx_exp[i]) if i == len(pfx_exp) - 1: result = int(oprStk.pop()) return result# 계산기 테스트exp1 = '(3 + 2 * 2 - 4) * 3 + 2 * (5 - 7)'print(conv_pfx(exp1))print(calculator(exp1))&gt;&gt; 322*+4-3*257-*+ 5exp2 = '5 * 7 - 5 / 3 + 2 + 5 * 3'print(conv_pfx(exp2))print(calculator(exp2))&gt;&gt; 57*53/-2+53*+ 51 Computer Engineering Hardware Architecture Keywords CPU의 구조 ALU(Arithmetic Logic Unit) 산술논리연산 장치 +, -, *, / 등의 정수 연산을 수행하는 유닛(가산기, 보수기, 쉬프터) CU(Control Unit) 제어 장치 명령어 해석과 실행을 담당하는 유닛 FPU(Floating Point Unit) 부동소수점 장치 실수 연산을 담당하는 유닛 CPU에서는 1개만 존재 그래픽 카드에는 FPU만 존재한다. 수많은 FPU를 병렬로 빠르게 계산할 수 있게 한다. Register(레지스터) CPU의 메모리 Program Counter(PC, Instruction Pointer), EIP Instruction Register(IR) Stack Pointer Base Pointer(Frame Pointer), EBP General Purpose Register(EAX, EBX, ECX…) Register를 알아야 Context Switching 기법을 이해할 수 있다. Memory Hierarchy(메모리 계층) Register Cache cache hit, cache miss Principle of locality Main memory(RAM) Hard Disk(HDD), Soild State Disk(SSD) Memory Layout(Segment) 각 영역에 변수가 들어간다.(메모리, 데이터) Code Segment Data Segment Stack Segment Heap Segment stack은 빠르고 heap은 느리다. page, page fault 가상 메모리(OS + 아키텍처)","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"call by object reference","slug":"190312-Python-call-by-object-reference","date":"2019-03-12T07:36:55.000Z","updated":"2019-06-16T07:42:01.198Z","comments":true,"path":"2019/03/12/190312-Python-call-by-object-reference/","link":"","permalink":"http://JINUKK.github.io/2019/03/12/190312-Python-call-by-object-reference/","excerpt":"","text":"Call by assignment 객체 참조에 의한 호출 stack frame 그림을 직접 그려보자. 변경할 수 없는 객체(immutable)의 경우12345678910111213141516def change_value(num, new_num): num = new_num print('%d in change value' % num)# 파이썬에서 \"=\"의 의미는 할당(assignment)# num은 new_num이 가리키는 값을 가리킨다.num = 10 # immutable(변경할 수 없는 객체)# num은 10을 가리킨다.# 10을 객체(object)라고 한다.change_value(num, 20)print(num)&gt;&gt; 20 in change value 10 두 결과값이 모두 num이 20이 나오지 않는다. change_value 함수의 num은 글로벌 변수 num의 값을 복사한 것이 아니다. change_value 함수의 num은 글로벌 변수 num의 값을 가리키는 것이다. 따라서 call by value는 아니다. num = new_num이 되면 num은 10을 가리키다가 20을 가리킨다. change_value 함수가 종료되면 stack frame에서 사라진다. 글로벌 변수 num에는 여전히 10이 남아있다. 파이썬 함수 안에서는 call by reference처럼 해결할 수는 없다. 하지만 다음처럼 해결할 수 있다.12345678910111213# 반환값을 num으로 받음# num에 반환값을 할당해서 num이 20을 가리키도록 함def change_value(num, new_num): num = new_num print('%d in change value' % num) return numnum = 10num = change_value(num, 20)print(num)&gt;&gt; 20 in change value 20 변경할 수 있는 객체(mutable)의 경우12345678910111213# list는 변경할 수 있는 객체(mutable)li = [1, 2, 3]def change_elem(li, idx, new_num): li[idx] = new_num print(li)change_elem(li, 1, 100)print(li)&gt;&gt; [1, 100, 3] [1, 100, 3] 이번에는 두 결과값이 다 같다. li[idx]도 상수 객체이기 때문에 imutable이다. 여기서 중요한 것은 li가 []의 object를 가리키는 것은 맞다. 하지만 [] 내부 각 자리에서 또 1, 2, 3을 각각 가리킨다. li[idx] = new_num이 실행되면, li[1] = 100이므로, li[1]이 2가 아닌 100을 가리키게 된다. change_elem 함수가 종료되면, 함수는 사라진다. 기존 li[1]도 100을 가리키고 있기 때문에 [1, 100, 3]이 된다. 123456789101112li = [1, 2, 3]def change_elem(li, a, b, c): li = [a, b, c] print(li)change_elem(li, 1, 100, 3)print(li)&gt;&gt; [1, 100, 3] [1, 2, 3] 위와 같은 경우는 바뀌지 않았다. global 영역의 list li는 []을 가리키고 [] 안 각 자리는 1, 2, 3을 가리킨다. change_elem 함수 내부에서도 object [ ]가 생성되게 된다. global 영역의 1과 3 그리고 새로 지정한 100을 [] 안 각 자리가 가리키게 된다. 파이썬에서는 자동적으로 같은 object를 가리키도록 해준다. 그래서 change_elem 함수 내부 li는 내부에서 생성된 object []를 가리키게 된다. 따라서 함수가 사라지면 기존 global li의 값은 변하지 않게 되는 것이다. 1234567891011121314# tuple은 변경할 수 없는 객체(immutable)tu = (1, 2, 3)def change_elem(tu, a, b, c): tu = (a, b, c) print(tu) return tutu = change_elem(tu, 1, 100, 2)print(tu)&gt;&gt; (1, 100, 2) (1, 100, 2) tuple의 요소 값은 바꿀 수는 없다. 그리고 또한 함수 내부에서도 바꾸는건 불가능하다. 따라서 위처럼 tu를 반환시킨다. return으로 받은 tu를 tu에다가 할당함으로 tu가 새로운 tu를 가리키도록 해준다.","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"call by object reference","slug":"call-by-object-reference","permalink":"http://JINUKK.github.io/tags/call-by-object-reference/"}]},{"title":"closure","slug":"190312-Python-closure","date":"2019-03-12T07:34:58.000Z","updated":"2019-06-16T07:39:50.962Z","comments":true,"path":"2019/03/12/190312-Python-closure/","link":"","permalink":"http://JINUKK.github.io/2019/03/12/190312-Python-closure/","excerpt":"","text":"함수 내부에 상태 정보를 가지고 있다. 상태 정보 = 관련 있는 데이터(함수가 처리하려는 데이터) class를 사용할 수 없을 때 쓴다. 계좌 만들기 예제 12345678910111213141516171819202122232425262728293031323334353637383940414243def account(clnt_name, balance): # 상태 정보 - free variable def change_money(money): nonlocal balance balance += money return (clnt_name, balance) return change_money# global variable - 맨 바깥쪽# local variable - 함수 내# free variable - 상태 정보my_acnt = account('greg', 5000)your_acnt = account('john', 3000)type(my_acnt)&gt;&gt; functionmy_acnt.__name__ == your_acnt.__name__&gt;&gt; Truemy_acnt.__name__&gt;&gt; 'change_money'# input 값 + 상태 정보 = output이 나온다.my_acnt(1000)&gt;&gt; ('greg', 6000)your_acnt(1000)&gt;&gt; ('john', 4000)# cell_contents : 담겨 있는 상태 정보를 불러옴cells = my_acnt.__closure__for cell in cells: print(cell.cell_contents, end = ' ')&gt;&gt; 6000 greg","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"closure","slug":"closure","permalink":"http://JINUKK.github.io/tags/closure/"}]},{"title":"2019.03.12 Python and CE Study","slug":"190312-PCE-Study","date":"2019-03-11T15:13:10.000Z","updated":"2019-05-06T15:18:06.307Z","comments":true,"path":"2019/03/12/190312-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/12/190312-PCE-Study/","excerpt":"","text":"closure 함수 내부에 상태 정보를 가지고 있다. 상태 정보 = 관련 있는 데이터(함수가 처리하려는 데이터) class를 사용할 수 없을 때 쓴다. 계좌 만들기 예제 1234567891011121314151617181920212223242526272829303132333435def account(clnt_name, balance): # 상태 정보 - free variable def change_money(money): nonlocal balance balance += money return (clnt_name, balance) return change_money# global variable - 맨 바깥쪽# local variable - 함수 내# free variable - 상태 정보my_acnt = account('greg', 5000)your_acnt = account('john', 3000)type(my_acnt)&gt;&gt; functionmy_acnt.__name__ == your_acnt.__name__&gt;&gt; Truemy_acnt.__name__&gt;&gt; 'change_money'# input 값 + 상태 정보 = output이 나온다.my_acnt(1000)&gt;&gt; ('greg', 6000)your_acnt(1000)&gt;&gt; ('john', 4000)# cell_contents : 담겨 있는 상태 정보를 불러옴cells = my_acnt.__closure__for cell in cells: print(cell.cell_contents, end = ' ')&gt;&gt; 6000 greg 문자, 문자열 character set 문자 집합 문자(character)를 모아둔 것 ex) 라틴 문자 character encoding 문자 인코딩 문자 집합을 메모리에 저장 · 통신하기 위해 부호화하는 방식 ex) 모스 부호 code point 문자 하나에 정수 하나를 매핑해둠 ex) ASCII 코드의 ‘a’는 97 ASCII CODE 0 ~ 127의 7bit로 모두 표현 가능 128가지 밖에 표현하지 못함 ASCII table 참고 UNICODE 0x0000 ~ 0xFFFF의 다국적 기본평면(BMP)에서부터 16번 평면까지 총 17개 존재 기본 평면(BMP)은 한글과 한중일 통합 한자들로 이루어져 있음 ASCII CODE와 UNICODE ASCII CODE ‘a’ = 97 ==메모리에 저장될 때==&gt; 0b01100001 = 1byte로 표현 UNICODE ‘가’ = 0xac00 =(메모리에 저장될 때)=&gt; 0b1010110000000000 = 2byte로 표현 기본 평면(BMP)이 아닌 2번째 평면부터는 0xFFFF가 넘어감 = 3byte를 사용 2byte + 4bit = 3byte를 쓰기보다는 padding byte를 추가해서 4byte로 쓰는 것이 좋음 다양한 인코딩 방식(UTF-8, UTF-16, UTF-32)이 생겨남 유니코드 부호화 방식 UTF-8 영어 때문에 1byte(8bit)를 기반으로 보내는 가변 길이 인코딩 방식 한글을 보낼 때는 3byte 사용 UTF-8이 기준 UTF-8 구조 U+0800 - U+FFFF ==&gt; 1110XXXX 10XXXXXX 10XXXXXX의 3byte 구조 ‘가’의 유니코드 ==&gt; U+AC00 ==&gt; 1010 1100 0000 0000 ==&gt; 1010 110000 000000 X자리에 넣기 ==&gt; 11101010 10110000 10000000 ==&gt; 0x EA B0 80 즉, 3byte로 인코딩됨 UTF-16 1차 평면(BMP)에서는 2byte로 표현 2차 평면 이상부터는 앞에 “0000”을 붙여서 4byte로 표현 다국적 기본 평면(BMP) : 16bit = 2byte 다국적 보충 평면(SMP) 이상 : 32bit = 4byte UTF-32 모두 4byte로 보내는 인코딩 방식 CP949 통합형 한글 코드(Unified Hangul Code) 마이크로 소프트 사에서 만듦 현대의 모든 한글 수용 유니코드 사용 방법(ASCII 호환) 123456789101112131415161718'\\u0041'&gt;&gt; A# 한글의 범위 U+AC00 ~ U+D7AF'\\uac00'&gt;&gt; '가'a = '가'b = a. encode('utf-8')type(b)&gt;&gt; bytesprint(b)&gt;&gt; b'\\xea\\xb0\\x80'# 0x ea b0 80의 3byte가 나온다.# 통신할 때는 1byte씩하여 ea, b0, 80으로 나눠서 보내진다. little endian과 big endian CPU에 따라 다르다. big endian ‘1234’의 수에서 most significant disit은 맨 앞의 1이 된다. Sparc / RISC CPU 계열 little endian ‘4321’의 수에서 most significant disit은 맨 뒤의 1이 된다. Intel CPU 계열 big endian과 little endian 사이에서 0xac00을 보낸다고 할때, ac 00 순으로 가는건지, 00 ac 순으로 가는건지 기준이 뭘까? Networking에서의 protocol 기준은 ‘big endian’으로 한다. UTF-8은 ‘endianless’이다. = little endian이건 big endian이건 상관없다. ex) 0x ea b0 80은 80 b0 ea로 보낸다고 생각하겠지만, 변환하지 않는다. 123456c = a.encode('utf-16')print(c)&gt;&gt; b'\\xff\\xfe\\x00\\xac'# 00 ac로 나오는 것을 볼 수 있다.# little endian으로 읽는 Intel 계열 CPU이기 때문이다. 마이크로소프트 사가 도입한 코드 - CP979 123a = '가'a.encode('cp949')&gt;&gt; b'\\xb0\\xa1' 부호화 1234a = '가'b = a.encode() # UTF-8이 defaultb&gt;&gt; b'\\xea\\xb0\\x80' 복호화 12b.decode()&gt;&gt; '가' CP949는 UTF-8이 아니므로 복호화할 시, 오류가 난다. 123456c = a.encode('cp949')c&gt;&gt; b'\\xb0\\xa1'c.decode()&gt;&gt; UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb0 in position 0: invalid start byte UTF-8 방식이 아닐 경우, 복호화할 수 있는 방법 CP949가 아닌 다른 인코딩 방식일 수도 있기 때문에 찾아야 하는 경우가 올 수 있다. 1234567try: d = c.decode()except UnicodeDecodeError: d = c.decode('cp949')d&gt;&gt; '가' Call by value 값에 의한 부름 stack frame 그림을 직접 그려보자. 123456789101112131415161718// C language codeinclude &lt;stdio.h&gt;void change_value(int x, int val) &#123; x = val; printf(\"x : %d in change_value \\n\", x);&#125;int main(void) &#123; int x = 10; change_value(x, 20); printf(\"x : %d in main \\n\",x);&#125;// 실행 결과&gt;&gt; x : 20 in change_value x : 10 in main 두 결과값이 모두 x가 20이 나오지 않는 것을 알 수 있다. stack frame에서 main 함수의 x와 change_value 함수의 x는 다르다. change_value의 x는 main 함수의 x 값을 복사해오기만 한다. 그리고 결과적으로 change_value 함수 안에서는 x 값이 20이 된 상태로 나온다. 하지만 change_value 함수가 끝나면 함수가 사라진다. 그러면 main 함수의 x값은 여전히 10으로 남아있다. Call by reference 참조에 의한 부름 stack frame 그림을 직접 그려보자. 1234567891011121314151617// C language codeinclude &lt;stdio.h&gt;void change_value(int * x, int val) &#123; *x = val; printf(\"x : %d in change_value \\n\", *x);&#125;int main(void) &#123; int x = 10; change_value(&amp;x, 20); printf(\"x : %d in main \\n\",x);&#125;// 실행 결과&gt;&gt; x : 20 in change_value x : 20 in main 두 결과값이 모두 x가 20이 나온다. change_value 함수를 호출할 때에는 주소 연산자(&amp;)를 붙여준다. change_value 함수 선언에서는 매개변수에 *를 붙여준다. stack frame에 쌓일 때 change_value의 x가 main 함수 x의 메모리 주소 처음을 가리키게 된다. change_value 함수 내부 지역변수 x에서도 *을 붙여줘서 main 함수 x에 접근할 수 있게 만들었다.(dereference: 역참조) 접근할 수 있게 되면서 main 함수 x의 값을 20으로 바꿀 수 있다. Call by object reference Call by assignment 객체 참조에 의한 호출 stack frame 그림을 직접 그려보자. 변경할 수 없는 객체(immutable)의 경우 123456789101112131415def change_value(num, new_num): num = new_num print('%d in change value' % num)# 파이썬에서 \"=\"의 의미는 할당(assignment)# num은 new_num이 가리키는 값을 가리킨다.num = 10 # immutable(변경할 수 없는 객체)# num은 10을 가리킨다.# 10을 객체(object)라고 한다.change_value(num, 20)print(num)&gt;&gt; 20 in change value 10 두 결과값이 모두 num이 20이 나오지 않는다. change_value 함수의 num은 글로벌 변수 num의 값을 복사한 것이 아니다. change_value 함수의 num은 글로벌 변수 num의 값을 가리키는 것이다. 따라서 call by value는 아니다. num = new_num이 되면 num은 10을 가리키다가 20을 가리킨다. change_value 함수가 종료되면 stack frame에서 사라진다. 글로벌 변수 num에는 여전히 10이 남아있다. 파이썬 함수 안에서는 call by reference처럼 해결할 수는 없다. 하지만 다음처럼 해결할 수 있다. 12345678910111213# 반환값을 num으로 받음# num에 반환값을 할당해서 num이 20을 가리키도록 함def change_value(num, new_num): num = new_num print('%d in change value' % num) return numnum = 10num = change_value(num, 20)print(num)&gt;&gt; 20 in change value 20 변경할 수 있는 객체(mutable)의 경우 1234567891011# list는 변경할 수 있는 객체(mutable)li = [1, 2, 3]def change_elem(li, idx, new_num): li[idx] = new_num print(li)change_elem(li, 1, 100)print(li)&gt;&gt; [1, 100, 3] [1, 100, 3] 이번에는 두 결과값이 다 같다. li[idx]도 상수 객체이기 때문에 imutable이다. 여기서 중요한 것은 li가 []의 object를 가리키는 것은 맞다. 하지만 [] 내부 각 자리에서 또 1, 2, 3을 각각 가리킨다. li[idx] = new_num이 실행되면, li[1] = 100이므로, li[1]이 2가 아닌 100을 가리키게 된다. change_elem 함수가 종료되면, 함수는 사라진다. 기존 li[1]도 100을 가리키고 있기 때문에 [1, 100, 3]이 된다. 12345678910li = [1, 2, 3]def change_elem(li, a, b, c): li = [a, b, c] print(li) change_elem(li, 1, 100, 3)print(li)&gt;&gt; [1, 100, 3] [1, 2, 3] 위와 같은 경우는 바뀌지 않았다. global 영역의 list li는 []을 가리키고 [] 안 각 자리는 1, 2, 3을 가리킨다. change_elem 함수 내부에서도 object [ ]가 생성되게 된다. global 영역의 1과 3 그리고 새로 지정한 100을 [] 안 각 자리가 가리키게 된다. 파이썬에서는 자동적으로 같은 object를 가리키도록 해준다. 그래서 change_elem 함수 내부 li는 내부에서 생성된 object []를 가리키게 된다. 따라서 함수가 사라지면 기존 global li의 값은 변하지 않게 되는 것이다. 123456789101112# tuple은 변경할 수 없는 객체(immutable)tu = (1, 2, 3)def change_elem(tu, a, b, c): tu = (a, b, c) print(tu) return tutu = change_elem(tu, 1, 100, 2)print(tu)&gt;&gt; (1, 100, 2) (1, 100, 2) tuple의 요소 값은 바꿀 수는 없다. 그리고 또한 함수 내부에서도 바꾸는건 불가능하다. 따라서 위처럼 tu를 반환시킨다. return으로 받은 tu를 tu에다가 할당함으로 tu가 새로운 tu를 가리키도록 해준다. Call by value 의미 C 언어에서는 reference라는 개념 자체가 없다. C 언어에서는 값을 복사하는 call by value 개념 밖에 없다. C++에서 참조자 개념으로 등장한 것이 Call by reference이다. Call by value는 stack frame 안 변수에 값이 바뀌더라도 stack frame 바깥쪽 변수에 영향을 주지 않는 것을 보장한다. 주소값을 복사하는 Call by address라는 말도 된다.(원본 주소의 “값”을 복사하는 Call by value의 형태) Call by address vs Call by reference? 둘 다 원본 변수의 값을 변경한다는 동일성을 가지고 있다. 하지만, 포인터 변수는 주소값을 가지고 있는 변수로서 4byte의 메모리 공간을 차지 참조자(레퍼런스) 변수는 메모리 공간을 차지하지 않고 원본 변수의 별명으로 붙음","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"decorator","slug":"190311-Python-decorator","date":"2019-03-11T07:17:53.000Z","updated":"2019-06-16T07:33:37.191Z","comments":true,"path":"2019/03/11/190311-Python-decorator/","link":"","permalink":"http://JINUKK.github.io/2019/03/11/190311-Python-decorator/","excerpt":"","text":"쉽게 기능을 추가할 수 있다. 1234567891011121314151617# 처음 함수를 정의할 때 쓰는 *의 의미는 가변인자를 사용한다는 의미이다.# 함수를 호출할 때 쓰는 *의 의미는 unpacking을 의미한다.(tuple, dictionary)def outer(org_func): def inner(*args, **kwargs): # 추가되는 기능 print(\"여기에 기능 추가\") return org_func(*args, **kwargs) return innerdef func(a, b): return a + bfunc.__name__&gt;&gt; 'func' 일반적인 기능 추가 12345678func = outer(func) # innerfunc.__name__&gt;&gt; 'inner'func(4, 6)&gt;&gt; 여기에 기능 추가 10 데코레이터를 사용한 기능 추가 1234567@outerdef func(a, b): return a + bfunc(4, 6)&gt;&gt; 여기에 기능 추가 10 데코레이터를 사용하여 경과 시간 측정 함수 기능 추가 123456789101112131415161718192021222324252627282930from functools import wrapsimport timedef benchmarker(org_func): @wraps(org_func) def inner(*args, **kwargs): start = time.time() result = org_func(*args, **kwargs) elapsed = time.time() - start print(f'elapsed time : &#123;elapsed:.2f&#125;') return result return inner@benchmarkerdef something(a, b): time.sleep(2) # C언어에서는 ms이지만 python에서는 sec이다. return a + bsomething(1, 2)&gt;&gt; elapsed time : 2.00 3something.__name__&gt;&gt; 'something'# wraps()를 사용하면 원래 함수의 이름을 가질 수 있다.# wraps()를 사용하지 않으면 something의 이름은 inner가 된다. 데코레이터를 사용하여 callcounter 함수 기능 추가 어떤 함수를 호출한 횟수를 보여주는 함수1234567891011121314151617181920212223242526272829303132333435363738394041424344454647g_call_num = 0def callcounter(org_func): @wraps(org_func) def inner(*args, **kwargs): global g_call_num g_call_num += 1 print(f'&#123;g_call_num&#125;번 호출되었습니다.') return org_func(*args, **kwargs) return inner@callcounterdef func(a, b): return a + bfor _ in range(10): print(func(10, 5))&gt;&gt; 1번 호출되었습니다. 15 2번 호출되었습니다. 15 3번 호출되었습니다. 15 4번 호출되었습니다. 15 5번 호출되었습니다. 15#경과 시간 측정 함수까지 기능 추가@benchmarker@callcounterdef another_func(a, b): return a + banother_func.__name__&gt;&gt; 'another_func'another_func(10, 2)&gt;&gt; 6번 호출되었습니다. elapsed time : 0.00 12","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"decorator","slug":"decorator","permalink":"http://JINUKK.github.io/tags/decorator/"},{"name":"wrap","slug":"wrap","permalink":"http://JINUKK.github.io/tags/wrap/"}]},{"title":"Lambda function","slug":"190311-Python-lambda-function","date":"2019-03-11T07:15:38.000Z","updated":"2019-06-16T07:26:51.094Z","comments":true,"path":"2019/03/11/190311-Python-lambda-function/","link":"","permalink":"http://JINUKK.github.io/2019/03/11/190311-Python-lambda-function/","excerpt":"","text":"익명 함수 이름이 없다. 함수를 재사용하지 않고 몇번 정도만 쓸때 아래와 같이 일반적인 함수는 객체를 만듦 재사용을 위해 함수 이름(메모리)를 할당 12345def func(a, b): return a + bfunc&gt;&gt; &lt;function __main__.func(a, b)&gt; 아래와 같이 람다 함수를 쓸 경우, 변수에 할당해놓지 않으면 메모리에서 사라짐 람다는 익명 함수이기 때문에 한번 쓰임 다음 줄로 넘어가면 힙(heap) 메모리 영역에서 증발된다. 123f = lambda a,b : a + bf(1, 2)&gt;&gt; 3 파이썬의 함수 = 식(expression) 1234567891011121314151617181920212223242526272829303132# 이항식# ex) a+ba = 10b = 20a + b&gt;&gt; 30# 단항식# ex) 10# '10' 자체도 식이다.10&gt;&gt; 10# 문자열도 문자열 자체를 반환하기 때문에 식이다.\"I am your father!\"&gt;&gt; 'I am your father!'# return 값이 없어도 None을 반환하기 때문에 식이다.def func(a, b): a + bprint(func(10, 20))&gt;&gt; None# print()도 None을 반환하기 때문에 식이다.print(print(func(10, 20)))&gt;&gt; None None lambda는 return을 쓰지 않아도 무조건 값을 반환하기 때문에 return이 필요없다. 맨 뒷자리에 무조건 식이 와야 한다. 123f2 = lambda a, b: a + bf2(1, 2)&gt;&gt; 3 아래와 같이 함수를 잠깐 쓰고 넘어갈 때 람다를 쓴다. 이렇게 하면 함수가 메모리에 남지 않는다. 12345678910li = [5, 2, 3, 1, 7, 10]li.sort(key = lambda x: x % 2, reverse = True)li&gt;&gt; [5, 3, 1, 7, 2, 10]# key 값에 'x % 2' 조건이 있다.# 짝수는 0이 되고 홀수는 1이 된다.# li = [5, 2, 3, 1, 7, 10]이 [1, 0, 1, 1, 1, 0]이 된다.# sort를 쓰면 오름차순이지만, reverse를 썼기 때문에 1, 0 순으로 정렬된다.# 정렬 후에도 작은 숫자대로 정렬이 되지 않았는데, 이 것을 stable sort라고 한다. filter, map, reduce lazy evaluation(게으른 연산) python에서도 filter, map, reduce 함수가 있다. filter, map은 바로 쓸 수 있으나, reduce는 functools 모듈을 추가해주어야 한다. 1234from functools import reducereduce&gt;&gt; &lt;function _functools.reduce&gt; filter 12345678910111213141516171819202122232425262728293031323334353637383940414243# lambda 함수 조건 : 양수만 출력# filter 맨 마지막 인자는 iterable 객체를 넣어준다.(순회 가능한 객체 ex) list 등)# filter 함수의 판단은 boolean이다.(True, False)li = [-3, 5, 1, 2, -5, -4, 14]f = filter(lambda e: e &gt; 0, li)f&gt;&gt; &lt;filter at 0x1db910&gt;# next()를 통해 결과값을 순차적으로 호출할 수 있다.next(f)&gt;&gt; 5next(f)&gt;&gt; 1next(f)&gt;&gt; 2next(f)&gt;&gt; 14# 조건에 만족하는 수가 끝나면 StopIteration 에러가 발생한다.next(f)&gt;&gt; StopIteration# for문을 사용해서 조건에 맞는 수를 모두 출력할 수 있다.f = filter(lambda e: e &gt; 0, li)for e in f: print(e, end = ' ')&gt;&gt; 5 1 2 14# list 형변환을 통해서 list로 받을 수 있다.without_neg = list(filter(lambda e: e &gt; 0, li))without_neg&gt;&gt; [5, 1, 2, 14] map, filter, reduce, generator 쓰는 이유 = lazy evaluation(게으른 연산) 함수의 실행 시기는 내가 결정한다! 내가 원할 때만 결과값을 가져온다! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051li = [-3, 5, 1, 2, -5, -4, 14]def func(x): print(\"func executed\") return x &gt; 0f = filter(func, li)next(f)&gt;&gt; func executed func executed 5next(f)&gt;&gt; func executed 1result = []for elem in li: if elem &gt; 0: result.append(elem)result&gt;&gt; [5, 1, 2, 14]f = filter(func, li)print(\"다른 작업\") # 다른 작업을 나타냄&gt;&gt; 다른 작업next(f)&gt;&gt; func executed func executed 5print(\"another job\") # 다른 작업을 나타냄&gt;&gt; another jobnext(f)&gt;&gt; func executed 1# 위 결과처럼 for문 안에 함수가 있으면 반복이 끝날 때까지 실행해야 한다.# 그러나 filter 함수는 내가 원하는 시점에서 부를 수 있다.(lazy evaluation) map 123456789101112131415161718192021222324252627282930li = [2, 3, 5, 7]# map = 맵핑한다.m = map(lambda x: x**2, li)# m은 map 객체# filter 객체와 map 객체 모두 generator 객체이다.# generator 객체는 iterator 객체이다.# filter 객체와 map 객체 모두 iterable 성질이 있다.# iterable 성질이 있다면 for문이 적용 가능하다.next(m)&gt;&gt; 4next(m)&gt;&gt; 9next(m)&gt;&gt; 25next(m)&gt;&gt; 49# map 또한 조건에 만족하는 수가 끝나면 StopIteration 에러가 발생한다.next(m)&gt;&gt; StopIteration 양수를 골라내서 제곱한 값을 리스트로 만들기 123456789101112li = [2, 3, -5, 6, -2, 1, -10]result_li = list(map(lambda x: x**2, filter(lambda e: e &gt; 0, li)))print(result_li)&gt;&gt; [4, 9, 36, 1]# map 함수를 먼저 쓰게 되면 제곱을 할 경우, 음수도 양수가 되버린다.# filter, map 객체 모두 iterable 성질이 있어서 함수에 바로 적용 가능하다. reduce 자료구조(list, tuple)를 연산을 통해서 단 하나의 값으로 만드는 함수 12345678910111213from functools import reducehelp(reduce)&gt;&gt; Help on built-in function reduce in module _functools: reduce(...) reduce(function, sequence[, initial]) -&gt; value Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5). If initial is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty. reduce 함수 설명을 보면 처음 인자(function)는 람다식 두 번째 인자(sequence)는 순회할 수 있는 객체(iterable) 반환값은 하나의 value로 나오는 것을 알 수 있음 12345678910li = [2, 3, -5, 6, -2, 1, -10]result = reduce(lambda a, b: a + b, li, 100)# 끝에 100을 넣어주면 처음 a에 2가 들어가는 것이 아니라 100이 들어간다.# 100과 같이 초기값이 없다면 a에 2가 들어가고 b에 3이 들어간다.result&gt;&gt; 95 최소값 구하기 1234567li = [3, 6, 8, -10, 2, 1, 100, 50, 46, -47]result = reduce(lambda a, b: a if a &lt; b else b, li)result&gt;&gt; -47# 최대값을 구하려면 a &gt; b하면 된다. 문자수 세기 결과값은 dictionary로 표시 python 함수는 식이므로 무조건 값을 반환 논리 연산을 할 때 마지막으로 참조한 값을 반환12345678910111213141516171819202122232425262728dic = &#123;'a' : 1, 'b' : 2&#125;# a가 존재하면 a의 value 값을, a가 존재하지 않으면 0을 나타낸다.dic.get('a', 0)&gt;&gt; 1# update()의 반환값은 None이다.print(dic.update(&#123;'a' : 5&#125;))&gt;&gt; Noneli = ['a', 'b', 'a', 'b', 'b', 'a', 'c', 'a']result = reduce(lambda dic, ch: dic.update(&#123;ch : dic.get(ch, 0)+1&#125;) or dic, li, &#123;&#125;)result&gt;&gt; &#123;'a': 4, 'b': 3, 'c': 1&#125;# update()는 None을 반환하기 때문에 or를 이용해서 dic 객체를 반환한다.# 논리 연산에서는 마지막 참조한 값을 반환한다.# 예를 들어 or 앞의 값이 False이면 뒤의 값까지 보고 판단한다.# 따라서 앞이 False라면 뒤의 값(마지막 값)을 참조하게 된다.# dic.get(ch, 0)은 해당 키 값이 있다면 키 값을 반환해주고 없다면 0을 반환해준다.# 처음 초기값 &#123;&#125;(빈 딕셔너리)가 dic에 들어가고 ch에 'a'가 들어간다.# 그 다음 or 연산을 통해 update()를 실행한 후, 결과값이 dic에 들어가게 된다.","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"lambda function","slug":"lambda-function","permalink":"http://JINUKK.github.io/tags/lambda-function/"},{"name":"filter","slug":"filter","permalink":"http://JINUKK.github.io/tags/filter/"},{"name":"map","slug":"map","permalink":"http://JINUKK.github.io/tags/map/"},{"name":"reduce","slug":"reduce","permalink":"http://JINUKK.github.io/tags/reduce/"}]},{"title":"2019.03.11 Python and CE Study","slug":"190311-PCE-Study","date":"2019-03-10T15:07:08.000Z","updated":"2019-05-06T15:12:38.513Z","comments":true,"path":"2019/03/11/190311-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/11/190311-PCE-Study/","excerpt":"","text":"lambda function 익명 함수 이름이 없다. 함수를 재사용하지 않고 몇번 정도만 쓸때 아래와 같이 일반적인 함수는 객체를 만듦 재사용을 위해 함수 이름(메모리)를 할당 12345def func(a, b): return a + bfunc&gt;&gt; &lt;function __main__.func(a, b)&gt; 아래와 같이 람다 함수를 쓸 경우, 변수에 할당해놓지 않으면 메모리에서 사라짐 람다는 익명 함수이기 때문에 한번 쓰임 다음 줄로 넘어가면 힙(heap) 메모리 영역에서 증발된다. 123f = lambda a,b : a + bf(1, 2)&gt;&gt; 3 파이썬의 함수 = 식(expression) 12345678910111213141516171819202122232425262728# 이항식# ex) a+ba = 10b = 20a + b&gt;&gt; 30# 단항식# ex) 10# '10' 자체도 식이다.10&gt;&gt; 10# 문자열도 문자열 자체를 반환하기 때문에 식이다.\"I am your father!\"&gt;&gt; 'I am your father!'# return 값이 없어도 None을 반환하기 때문에 식이다.def func(a, b): a + bprint(func(10, 20))&gt;&gt; None# print()도 None을 반환하기 때문에 식이다.print(print(func(10, 20)))&gt;&gt; None None lambda는 return을 쓰지 않아도 무조건 값을 반환하기 때문에 return이 필요없다. 맨 뒷자리에 무조건 식이 와야 한다. 123f2 = lambda a, b: a + bf2(1, 2)&gt;&gt; 3 아래와 같이 함수를 잠깐 쓰고 넘어갈 때 람다를 쓴다. 이렇게 하면 함수가 메모리에 남지 않는다. 1234567891011li = [5, 2, 3, 1, 7, 10]li.sort(key = lambda x: x % 2, reverse = True)li&gt;&gt; [5, 3, 1, 7, 2, 10]# key 값에 'x % 2' 조건이 있다.# 짝수는 0이 되고 홀수는 1이 된다.# li = [5, 2, 3, 1, 7, 10]이 [1, 0, 1, 1, 1, 0]이 된다.# sort를 쓰면 오름차순이지만, reverse를 썼기 때문에 1, 0 순으로 정렬된다.# 정렬 후에도 작은 숫자대로 정렬이 되지 않았는데, 이 것을 stable sort라고 한다. filter, map, reduce lazy evaluation(게으른 연산) python에서도 filter, map, reduce 함수가 있다. filter, map은 바로 쓸 수 있으나, reduce는 functools 모듈을 추가해주어야 한다. 1234from functools import reducereduce&gt;&gt; &lt;function _functools.reduce&gt; filter 1234567891011121314151617181920212223242526272829303132333435# lambda 함수 조건 : 양수만 출력# filter 맨 마지막 인자는 iterable 객체를 넣어준다.(순회 가능한 객체 ex) list 등)# filter 함수의 판단은 boolean이다.(True, False)li = [-3, 5, 1, 2, -5, -4, 14]f = filter(lambda e: e &gt; 0, li)f&gt;&gt; &lt;filter at 0x1db910&gt;# next()를 통해 결과값을 순차적으로 호출할 수 있다.next(f)&gt;&gt; 5next(f)&gt;&gt; 1next(f)&gt;&gt; 2next(f)&gt;&gt; 14# 조건에 만족하는 수가 끝나면 StopIteration 에러가 발생한다.next(f)&gt;&gt; StopIteration# for문을 사용해서 조건에 맞는 수를 모두 출력할 수 있다.f = filter(lambda e: e &gt; 0, li)for e in f: print(e, end = ' ')&gt;&gt; 5 1 2 14# list 형변환을 통해서 list로 받을 수 있다.without_neg = list(filter(lambda e: e &gt; 0, li))without_neg&gt;&gt; [5, 1, 2, 14] map, filter, reduce, generator 쓰는 이유 = lazy evaluation(게으른 연산) 함수의 실행 시기는 내가 결정한다! 내가 원할 때만 결과값을 가져온다! 1234567891011121314151617181920212223242526272829303132333435363738394041li = [-3, 5, 1, 2, -5, -4, 14]def func(x): print(\"func executed\") return x &gt; 0f = filter(func, li)next(f)&gt;&gt; func executed func executed 5next(f)&gt;&gt; func executed 1result = []for elem in li: if elem &gt; 0: result.append(elem)result&gt;&gt; [5, 1, 2, 14]f = filter(func, li)print(\"다른 작업\") # 다른 작업을 나타냄&gt;&gt; 다른 작업next(f)&gt;&gt; func executed func executed 5print(\"another job\") # 다른 작업을 나타냄&gt;&gt; another jobnext(f)&gt;&gt; func executed 1# 위 결과처럼 for문 안에 함수가 있으면 반복이 끝날 때까지 실행해야 한다.# 그러나 filter 함수는 내가 원하는 시점에서 부를 수 있다.(lazy evaluation) map 1234567891011121314151617181920212223li = [2, 3, 5, 7]# map = 맵핑한다.m = map(lambda x: x**2, li)# m은 map 객체# filter 객체와 map 객체 모두 generator 객체이다.# generator 객체는 iterator 객체이다.# filter 객체와 map 객체 모두 iterable 성질이 있다.# iterable 성질이 있다면 for문이 적용 가능하다.next(m)&gt;&gt; 4next(m)&gt;&gt; 9next(m)&gt;&gt; 25next(m)&gt;&gt; 49# map 또한 조건에 만족하는 수가 끝나면 StopIteration 에러가 발생한다.next(m)&gt;&gt; StopIteration 양수를 골라내서 제곱한 값을 리스트로 만들기 123456789li = [2, 3, -5, 6, -2, 1, -10]result_li = list(map(lambda x: x**2, filter(lambda e: e &gt; 0, li)))print(result_li)&gt;&gt; [4, 9, 36, 1]# map 함수를 먼저 쓰게 되면 제곱을 할 경우, 음수도 양수가 되버린다.# filter, map 객체 모두 iterable 성질이 있어서 함수에 바로 적용 가능하다. reduce 자료구조(list, tuple)를 연산을 통해서 단 하나의 값으로 만드는 함수 1234567891011121314from functools import reducehelp(reduce)&gt;&gt; Help on built-in function reduce in module _functools: reduce(...) reduce(function, sequence[, initial]) -&gt; value Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5). If initial is present, it is placed before the items of the sequence in the calculation, and serves as a default when the sequence is empty. reduce 함수 설명을 보면 처음 인자(function)는 람다식 두 번째 인자(sequence)는 순회할 수 있는 객체(iterable) 반환값은 하나의 value로 나오는 것을 알 수 있음 123456789li = [2, 3, -5, 6, -2, 1, -10]result = reduce(lambda a, b: a + b, li, 100)# 끝에 100을 넣어주면 처음 a에 2가 들어가는 것이 아니라 100이 들어간다.# 100과 같이 초기값이 없다면 a에 2가 들어가고 b에 3이 들어간다.result&gt;&gt; 95 최소값 구하기 1234567li = [3, 6, 8, -10, 2, 1, 100, 50, 46, -47]result = reduce(lambda a, b: a if a &lt; b else b, li)result&gt;&gt; -47# 최대값을 구하려면 a &gt; b하면 된다.¶ 문자수 세기 결과값은 dictionary로 표시 python 함수는 식이므로 무조건 값을 반환 논리 연산을 할 때 마지막으로 참조한 값을 반환 1234567891011121314151617181920212223dic = &#123;'a' : 1, 'b' : 2&#125;# a가 존재하면 a의 value 값을, a가 존재하지 않으면 0을 나타낸다.dic.get('a', 0)&gt;&gt; 1# update()의 반환값은 None이다.print(dic.update(&#123;'a' : 5&#125;))&gt;&gt; Noneli = ['a', 'b', 'a', 'b', 'b', 'a', 'c', 'a']result = reduce(lambda dic, ch: dic.update(&#123;ch : dic.get(ch, 0)+1&#125;) or dic, li, &#123;&#125;)result&gt;&gt; &#123;'a': 4, 'b': 3, 'c': 1&#125;# update()는 None을 반환하기 때문에 or를 이용해서 dic 객체를 반환한다.# 논리 연산에서는 마지막 참조한 값을 반환한다.# 예를 들어 or 앞의 값이 False이면 뒤의 값까지 보고 판단한다.# 따라서 앞이 False라면 뒤의 값(마지막 값)을 참조하게 된다.# dic.get(ch, 0)은 해당 키 값이 있다면 키 값을 반환해주고 없다면 0을 반환해준다.# 처음 초기값 &#123;&#125;(빈 딕셔너리)가 dic에 들어가고 ch에 'a'가 들어간다.# 그 다음 or 연산을 통해 update()를 실행한 후, 결과값이 dic에 들어가게 된다. Decorator(데코레이터) 쉽게 기능을 추가할 수 있다. 123456789101112131415# 처음 함수를 정의할 때 쓰는 *의 의미는 가변인자를 사용한다는 의미이다.# 함수를 호출할 때 쓰는 *의 의미는 unpacking을 의미한다.(tuple, dictionary)def outer(org_func): def inner(*args, **kwargs): # 추가되는 기능 print(\"여기에 기능 추가\") return org_func(*args, **kwargs) return innerdef func(a, b): return a + b func.__name__&gt;&gt; 'func' 일반적인 기능 추가 1234567func = outer(func) # innerfunc.__name__&gt;&gt; 'inner'func(4, 6)&gt;&gt; 여기에 기능 추가 10 데코레이터를 사용한 기능 추가 1234567@outerdef func(a, b): return a + bfunc(4, 6)&gt;&gt; 여기에 기능 추가 10 데코레이터를 사용하여 경과 시간 측정 함수 기능 추가 123456789101112131415161718192021222324252627from functools import wrapsimport timedef benchmarker(org_func): @wraps(org_func) def inner(*args, **kwargs): start = time.time() result = org_func(*args, **kwargs) elapsed = time.time() - start print(f'elapsed time : &#123;elapsed:.2f&#125;') return result return inner@benchmarkerdef something(a, b): time.sleep(2) # C언어에서는 ms이지만 python에서는 sec이다. return a + bsomething(1, 2)&gt;&gt; elapsed time : 2.00 3something.__name__&gt;&gt; 'something'# wraps()를 사용하면 원래 함수의 이름을 가질 수 있다.# wraps()를 사용하지 않으면 something의 이름은 inner가 된다. 데코레이터를 사용하여 callcounter 함수 기능 추가 어떤 함수를 호출한 횟수를 보여주는 함수 1234567891011121314151617181920212223242526272829303132333435363738394041g_call_num = 0def callcounter(org_func): @wraps(org_func) def inner(*args, **kwargs): global g_call_num g_call_num += 1 print(f'&#123;g_call_num&#125;번 호출되었습니다.') return org_func(*args, **kwargs) return inner@callcounterdef func(a, b): return a + bfor _ in range(10): print(func(10, 5))&gt;&gt; 1번 호출되었습니다. 15 2번 호출되었습니다. 15 3번 호출되었습니다. 15 4번 호출되었습니다. 15 5번 호출되었습니다. 15#경과 시간 측정 함수까지 기능 추가@benchmarker@callcounterdef another_func(a, b): return a + banother_func.__name__&gt;&gt; 'another_func'another_func(10, 2)&gt;&gt; 6번 호출되었습니다. elapsed time : 0.00 12","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"2019.03.08 Python and CE Study","slug":"190308-PCE-Study","date":"2019-03-08T14:59:05.000Z","updated":"2019-05-06T15:02:43.518Z","comments":true,"path":"2019/03/08/190308-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/08/190308-PCE-Study/","excerpt":"","text":"Computer Engineering CPU = ALU + CU + Register ALU(Arithmetic Logic Unit) 산술논리연산 장치 +, -, *, /, &amp;, |, ^의 비교, 판단, 연산 담당 CU(Control Unit) 제어 장치 명령어 해석과 실행을 담당 Register(레지스터) CPU의 메모리 32bit 컴퓨터는 레지스터도 32bit EAX, ECX 등등 1234567891011# 아래 연산이 이루어질때# a = 10, b = 20, c = 30이 RAM에 기록됨# 하지만 연산 과정은 RAM에서 a의 값이 CPU 레지스터 EAX에, b는 ECX에 기록# 그리고 ALU를 통해 연산된 후, c = 30이 EAX에 기록된 다음, RAM으로 다시 값이 기록# RAM에서 계산되는 것이 아니다!a = 10b = 20c = a+bprint(c)&gt;&gt; 30 CPU 정수의 곱셉과 나눗셈 CPU는 전가산기로 계산되기 때문에 빼기는 보수기(2의 보수)를 통해 연산 곱셉과 나눗셈은 Shifter(비트 이동)를 통해 연산 곱셉은 레지스터 2개 필요 Shifter 되는 수 = 지금 사용되는 bit의 수 4비트 값이 계산되면 Shift는 4번 됨(비트의 수만큼 Shift 됨) 실수(real number) 고정소수점 : 정밀도가 높으나, 표현 범위가 좁아 쓰지 않는다. 부동소수점(floating point) : 정밀도가 낮으나, 표현 범위가 넓기 때문에 쓰인다. 부동소수점은 IEEE 표준에 따름 소수점이 이동한다고 하여 floating point라고 함 1023.0 x 10^0 = 102.3 x 10^1 = 10.23 x 10^2 = 1.023 x 10^3 1023.0은 가수부(mantissa), 10^2는 지수부(exponent)라고 한다.(10은 기수[radix]) 2진수 예) 1010 = 101.0 x 2^1 = 10.10 x 2^2 = 1.010 x 2^3 단정도 32bit = 4byte 부호(1bit) + 지수(8bit) + 가수(23bit) 배정도 64bit = 8byte 부호(1bit) + 지수(11bit) + 가수(52bit) 부호(sign), 지수(exponent), 가수(mantissa) 지수부를 넓힌다는 건 표현 범위를 넓힌다는 것 가수부를 넓힌다는 건 정밀도를 높힌다는 것 정규화 정수 부분을 0이 아닌 자연수로 만드는 것 ex) 5234의 정규화 : 5.234 x 10^3 정규화를 함으로써 맨 앞의 한자리는 mantissa에 포함시키지 않는다. 정규화 식 : 2진수로 바꿔서 나타냄 1234567±1.mantissa x 2^(exp - bias)- exp : 실제로 메모리에 저장되는 것- bias : 2^(n-1) - 1- float일 경우, bias = 2^(8 - 1) - 1 = 127- double일 경우, bias = 2^(11 - 1) - 1 = 1023- 계산된 exp의 값을 2진수로 바꿔서 메모리에 저장 digit(자리수) = 정밀도 10진수 1자리를 표현하기 위해 2진수 4자리가 필요하다. 계산기로 2진수 1111을 치면 10진수 = 15(적어도 10진수 한 자리수는 모두 표현 가능) 2진수 7자리 수는 10진수 2자리 수를 보장한다.(99까지 표현이 가능) 2진수 10자리 수는 10진수 3자리 수를 보장한다. 2진수 24자리 수는 10진수 7자리 수를 보장한다. 2진수 53자리 수는 10진수 15자리 수를 보장한다. double 형에서 정밀도는 소수점 아래 15자리를 보장하는 것이 아니다. double 형에서 정밀도는 10진수 15자리를 이야기하는 것이다. epsilon의 정의 1.0(2) x 2^0과 다음으로 표현할 수 있는 수 사이의 차이 double 형이 더 정밀하는 것을 알 수 있다. 123456789# float 형에서의 epsilon = 2^-23f_ep = 2**(-23)print(f_ep)&gt;&gt; 1.1920928955078125e-07# double 형에서의 epsilon = 2^-52d_ep = 2**(-52)print(d_ep)&gt;&gt; 2.220446049250313e-16 Comparison 아래와 같이 a와 b 모두 0.3으로 참이 나와야 하는데 거짓이 나온다. 1234a = 0.3b = 0.1*3a == b&gt;&gt; False 이 문제를 해결하기 위한 비교 방법들이다. 절대 비교 기법(Absolute comparison) 두 수의 차를 절대값으로 만든다. ‘1.0e-10’과 같이 기준을 잡아서 비교하는 것이다. 하지만 ‘1.0e-10’이라는 기준이 너무 막연하고 모호하다. 기준으로 잡는 수를 변경할 수 있도록 매개변수로 잡는 방법도 있다. 12345678910from math import fabs # math 모듈에서 fabs라는 절대값 함수를 가져옴def is_equal_abs(a,b): return fabs(a-b) &lt;= 1.0e-10if is_equal_abs(a,b): print('이 정도 차이면 같다.')else: print('같은 수가 아니다.')&gt;&gt; 이 정도 차이면 같다. 상대 비교 기법(Relative comparison) sys 모듈에서 epsilon 값을 적용한다. 절대값을 취한 a와 b 사이 중 큰 값을 이용한다. 매개변수를 추가하여 정밀도 범위 조정을 가능하게 한다. 123456789101112131415161718192021from math import fabsimport sysdef is_equal_rel(a,b, w=0): \"\"\" is_equal(a, b, w=0) -&gt; bool w는 가중치입니다. w를 0부터 늘려가며 상대 오차 범위를 조정해주세요. \"\"\" ep = sys.float_info.epsilon # sys 모듈에서 epsilon 값을 적용 diff = fabs(a-b) return diff &lt;= max(fabs(a), fabs(b))*ep*(2**w)a = 0.3b = 0.3if is_equal_rel(a,b): print('같다.')else: print('다르다.')&gt;&gt; 같다. 정밀도 범위 조정 1234567891011121314151617181920s = 0.0a = 0.01t = 1.0for _ in range(100): s+=a# 정밀도 범위를 조정하지 않은 경우if is_equal_rel(s, t): print('같다.')else: print('다르다.')&gt;&gt; 다르다.# 정밀도를 조정한 경우if is_equal_rel(s, t, 2): print('같다.') else: print('다르다.')&gt;&gt; 같다. 알고리즘 성능을 가늠하는 기준 : 시간 절대 시간 : 컴퓨터 성능에 의해 기준 자체가 모호하므로 기준으로 삼기 어려움 상대 시간 : 데이터의 개수(n)에 따른 연산 횟수를 가지고 비교 알고리즘 성능을 상대 시간으로 결정하기로 함 연산 횟수는 알고리즘 안에서 헤비하게 쓰이는 연산을 기준으로 삼음 보통 비교 연산 부분을 기준으로 삼음(if문, for문…등등) 알고리즘의 성능 3가지 최선의 경우 : 알고리즘 성능에서는 잘 사용하지 않는다. 평균의 경우 : quick sort Algorithm에서 쓰인다. 최악의 경우 : 알고리즘 성능에서 많이 쓰인다. O(n) 오 upper bound 최악의 경우에 이 정도까지 나타낸다는 의미 Ω(n) 오메가 under bound 최선의 경우에 이 정도까지 나타낸다는 의미 θ(n) 세타 upper bound + under bound 12345T(n) = 3n^2 + 5n - 1- 위 식에서 그래프의 미분율이 중요함- 그래프가 어디서 시작하는지는 중요하지 않음- 그래프의 생김새를 결정하는 맨 앞자리(3n^2)로 빅오(O) 판단 빅오(O)의 가장 좋은 5가지(속도 순) O(상수) 상수 시간(constant) 연산 횟수가 늘어나도 상수 시간이 정해져 있음 배열의 인덱싱(array indexing) = search() linked list의 insert(), delete() O(log(n)) 로그 시간 데이터 양이 많아져도 시간이 조금씩 늘어남 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듬 binary seach BST insert(), search(), delete() 계열 모두 O(n) 선형 시간 데이터 양에 따라 시간이 정비례함 array의 insert(), delete() linked list의 search() O((n)log(n)) 데이터 양이 n배 많아진다면, 실행 시간은 n배보다 조금 더 많아짐(정비례 X) 두 수를 직접 비교해서 정렬하는 알고리즘은 O((n)log(n))보다 좋아질 수 없다는 것이 증명되었음 quick sort, merge sort, heap sort O(n^2) 데이터 양에 따라 걸리는 시간은 제곱에 비례함 효율이 좋지 않음 그래프의 모양이 4번보다 가파름 2중 for문 bubble sort, insertion sort, selection sort 4번과 5번의 성능 차이는 엄청 크다.(비교할 수 있는 성능이 아님) 빅오(O)를 무조건 믿으면 안되는 이유 만약 O(n)의 알고리즘을 쓴다고 할 때, 성능이 좋지 않은 경우가 있다. 이럴 경우, CPU가 RAM에서 받아오는지 Hard Disk에서 받아오는지 알아야 한다. CPU가 RAM에서는 20-100cycle이지만, Hard Disk에서는 500,000-5,000,000cycle이다. 따라서 벤치마킹을 살펴보는 것이 중요하다.","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"comparison","slug":"190308-Python-comparison","date":"2019-03-08T07:13:02.000Z","updated":"2019-06-16T07:31:14.016Z","comments":true,"path":"2019/03/08/190308-Python-comparison/","link":"","permalink":"http://JINUKK.github.io/2019/03/08/190308-Python-comparison/","excerpt":"","text":"아래와 같이 a와 b 모두 0.3으로 참이 나와야 하는데 거짓이 나온다. 12345a = 0.3b = 0.1*3a == b&gt;&gt; False 이 문제를 해결하기 위한 비교 방법들이다. 절대 비교 기법(Absolute comparison) 두 수의 차를 절대값으로 만든다. ‘1.0e-10’과 같이 기준을 잡아서 비교하는 것이다. 하지만 ‘1.0e-10’이라는 기준이 너무 막연하고 모호하다. 기준으로 잡는 수를 변경할 수 있도록 매개변수로 잡는 방법도 있다. 1234567891011from math import fabs # math 모듈에서 fabs라는 절대값 함수를 가져옴def is_equal_abs(a,b): return fabs(a-b) &lt;= 1.0e-10if is_equal_abs(a,b): print('이 정도 차이면 같다.')else: print('같은 수가 아니다.')&gt;&gt; 이 정도 차이면 같다. 상대 비교 기법(Relative comparison) sys 모듈에서 epsilon 값을 적용한다. 절대값을 취한 a와 b 사이 중 큰 값을 이용한다. 매개변수를 추가하여 정밀도 범위 조정을 가능하게 한다. 12345678910111213141516171819202122from math import fabsimport sysdef is_equal_rel(a,b, w=0): \"\"\" is_equal(a, b, w=0) -&gt; bool w는 가중치를 의미 w를 0부터 늘려가며 상대 오차 범위를 조정 \"\"\" ep = sys.float_info.epsilon # sys 모듈에서 epsilon 값을 적용 diff = fabs(a-b) return diff &lt;= max(fabs(a), fabs(b))*ep*(2**w)a = 0.3b = 0.3if is_equal_rel(a,b): print('같다.')else: print('다르다.')&gt;&gt; 같다. 정밀도 범위 조정 12345678910111213141516171819202122s = 0.0a = 0.01t = 1.0for _ in range(100): s+=a# 정밀도 범위를 조정하지 않은 경우if is_equal_rel(s, t): print('같다.')else: print('다르다.')&gt;&gt; 다르다.# 정밀도를 조정한 경우if is_equal_rel(s, t, 2): print('같다.') else: print('다르다.')&gt;&gt; 같다.","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"comparison","slug":"comparison","permalink":"http://JINUKK.github.io/tags/comparison/"},{"name":"epsilon","slug":"epsilon","permalink":"http://JINUKK.github.io/tags/epsilon/"}]},{"title":"2019.03.07 Python and CE Study","slug":"190307-PCE-Study","date":"2019-03-07T14:50:45.000Z","updated":"2019-06-16T06:55:23.595Z","comments":true,"path":"2019/03/07/190307-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/07/190307-PCE-Study/","excerpt":"","text":"Algorithm Tower of Hanoi(하노이 탑) 반드시 큰 쟁반이 아래에 있어야 한다. 큰 쟁반이 작은 쟁반보다 위에 있을 수 없다. 기둥1(_from), 기둥2(_by), 기둥3(_to)이 있다. 기둥 1에서 기둥3으로 모두 이동시켜야 한다. 123456789101112# (num - 1)개를 _from에서 _to를 이용하여 _by로 이동시킨다.# num(제일 큰 쟁반)을 _from에서 _to로 이동시킨다.# (n - 1)개를 _by에서 _from을 이용하여 _to로 이동시킨다.def hanoi(num, _from, _by, _to): #base case if num == 1: print(f'&#123;_from&#125;에서 &#123;_to&#125;로 &#123;num&#125;번째 쟁반 이동') return hanoi(num - 1, _from, _to, _by) print(f'&#123;_from&#125;에서 &#123;_to&#125;로 &#123;num&#125;번째 쟁반 이동') hanoi(num - 1, _by, _from, _to) 함수가 동작하는 모습을 stack frame으로 그려본다. “pythontutor.com”을 이용하여 함수가 동작하는 모습을 보는 것도 좋다. 점화식 및 기저 조건을 잘 만드는 것이 중요하다. stack frame에 쌓이는 모습을 call stack이라고 한다. call stack 맨 위에 있는 frame이 실행 권한을 가진다. 함수가 실행이 끝나지 않은 상태에서 위 frame에 실행 권한을 주는 것을 blocking이라고 한다. 12345678hanoi(3, 'A', 'B', 'C')&gt;&gt; A에서 C로 1번째 쟁반 이동 A에서 B로 2번째 쟁반 이동 C에서 B로 1번째 쟁반 이동 A에서 C로 3번째 쟁반 이동 B에서 A로 1번째 쟁반 이동 B에서 C로 2번째 쟁반 이동 A에서 C로 1번째 쟁반 이동 first class function first class function 조건 argument(parameter) - 매개 변수 함수 자체를 매개변수로 다른 함수에 전달 12345678910def f(a, b): return a + bdef g(func, c, d): return func(c, d)a = 10b = 20g(f, a, b) # 함수 자체를 매개변수로 전달&gt;&gt; 30 variable - 변수(값) 함수를 변수에 할당 123456def f(a, b): return a + bf_var = f # 함수를 변수에 할당f_var(20 ,30)&gt;&gt; 50 return - 반환 다른 함수의 결과값으로 반환 1234567891011121314def create_calc(kind): if kind == 'add': def add(a, b): return a + b return add elif kind == 'sub': def sub(a, b): return a - b return sub # 다른 함수의 결과값으로 반환f = create_calc('add')f(10, 20)&gt;&gt; 30 기수법 기수(radix) 한 자리에 표현할 수 있는 수 10진수 - 0 , 1, 2, 3, 4, 5, 6, 7, 8, 9 2진수 - 0, 1 16진수 - 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F ‘0b’는 2진수 1a = 0b1010 # 0b는 2진수 ‘0x’는 16진수 hex()를 이용하여 16진수 변환 123456hex(a) # 0x는 16진수&gt;&gt; '0xa'b = 0b10101111hex(b)&gt;&gt; '0xaf' bin()을 이용하여 2진수 변환 123c = 0xafbin(c)&gt;&gt; '0b10101111' Computer Engineering 32bit와 64bit 한 번에 보낼 수 있는 데이터의 양(32bit = 32개, 64bit = 64개) 32bit는 메모리 주소로 4GB가 한계이다.(2^32 = 4,294,967,296) 32bit CPU에서 4GB 이상의 램을 사용해도 사용할 수 없다. 64bit는 2^64개만큼 쓸 수 있지만 실제로는 48bit 정도만 쓴다. 1byte = 8bit -&gt; 옥텟(octet) 하드웨어의 추상화 / 언어의 추상화 Low - Level Language = Assembly Language CPU가 바뀌면 다시 설계해야 하고 레지스트리까지 모두 알아야 한다. 하드웨어에 의존적인 언어 High - Level Language = C, Python, Javascript 제조사의 Complier만 있다면 어떤 CPU든 가능하다. C 언어의 경우 int, short, char와 같이 메모리 바인딩을 해줘야 한다. integer overflow 1byte = 0 ~ 255(unsigned), -128 ~ 127 4bytes = 0 ~ 2^32-1(unsigned), -2^31 ~ 2^31-1 char형 변수 a = 126이 두 번 증가하면 -128 ~ 127의 범위를 벗어남 실제로 출력하면 128이 아닌 -128이 나오는데 이 것을 integer overflow라고 함 2의 보수 양의 정수 표현 부호 비트 0 정수를 2진수로 표현 음의 정수 표현 부호 비트는 1 정수를 2의 보수(two’s complement)로 저장 1의 보수는 모든 비트를 반전시켜주기만 하면 된다. 1의 보수한 상태에서 1을 더하면 2의 보수가 된다. 2의 보수를 원래의 수에 더하면 자릿수가 바뀐다. 12345678910111213141516a = 43bin(a)&gt;&gt; '0b101011'# 양의 정수 43 = 0b00101011# 음의 정수 43 = 0b00101011 -(1의 보수)-&gt; 0b11010100 -(2의 보수)-&gt; 0b11010101# 정수를 메모리에 저장되는 'byte' 형태로 표현# to_bytes()의 마지막 인자는 정수를 표현하는데 2의 보수가 사용되는지 결정a.to_bytes(1, 'little', signed = True)&gt;&gt; b'+'# signed의 기본값 = False# 음의 정수가 주어지고, signed가 False면 OverflowError 발생(-43).to_bytes(1, 'little', signed = True)&gt;&gt; b'\\xd5' # 0b11010101 CPU는 가산기로만 계산을 한다. 9 - 4를 계산하면 9 + (-4)로 계산을 한다. 9 = 0b1001 -4 = 0b0100 -&gt; 0b1011 -&gt; 0b1100 0b1001 + 0b1100 = 0b10101 에서 4자리만 기억하므로 맨 앞을 빼면 0b0101 = 5 Algorithom Linear search and Binary search Binary search와 성능을 비교하기 위해 Linear search를 만든다. Linear search(선형 탐색) 데이터가 모인 집합의 처음부터 끝까지 하나씩 순서대로 비교하여 찾음 123456789101112131415161718192021def linear_search(li, target): \"\"\" linear_search(li, target) -&gt; idx 반환값은 target이 있다면 target의 인덱스 target이 없다면 None을 반환 \"\"\" for i in range(len(li)): if li[i] == target: return i return Noneli = [5, 7, 2, 8, 3, 9, 1]linear_search(li, 8)&gt;&gt; 3print(linear_search(li,10))&gt;&gt; None Binary search(이진 탐색) 데이터의 집합이 반드시 정렬된 상태어야 함 시작 인덱스와 끝 인덱스 그리고 중간 인덱스를 정의 원하는 인덱스가 중간 인덱스보다 작다면 끝 인덱스를 중간 인덱스보다 작게 만든다. 원하는 인덱스가 중간 인덱스보다 크다면 시작 인덱스를 중간 인덱스보다 크게 만든다. 시작 인덱스가 끝 인덱스보다 커지면 반복을 멈춘다. 123456789101112131415161718192021222324252627282930def binary_search(li, target): \"\"\" binary_search(li, target) -&gt; idx 반환값은 target이 있다면 target의 인덱스 target이 없다면 None을 반환 \"\"\" start_idx = 0 end_idx = len(li) - 1 while start_idx &lt;= end_idx: mid_idx = (start_idx + end_idx) // 2 if li[mid_idx] == target: return mid_idx elif li[mid_idx] &gt; target: end_idx = mid_idx - 1 else: start_idx = mid_idx + 1 return Noneli = [3, 5, 7, 8, 9, 11, 12]binary_search(li, 8)&gt;&gt; 3print(binary_search(li,13))&gt;&gt; None 알고리즘 성능을 가늠하는 기준 : 시간 절대 시간 : 컴퓨터 성능에 의해 기준 자체가 모호하므로 기준으로 삼기 어려움 상대 시간 : 데이터의 개수(n)에 따른 연산 횟수를 가지고 비교 알고리즘 성능을 상대 시간으로 결정하기로 함 연산 횟수는 알고리즘 안에서 헤비하게 쓰이는 연산을 기준으로 삼음 보통 비교 연산 부분을 기준으로 삼음(if문, for문…등등) 알고리즘의 성능 3가지 최선의 경우 : 알고리즘 성능에서는 잘 사용하지 않는다. 평균의 경우 : quick sort Algorithm에서 쓰인다. 최악의 경우 : 알고리즘 성능에서 많이 쓰인다. 그래프 성능 비교 : Linear search &lt; Binary search","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"binary search","slug":"190307-Algorithm-binary-search","date":"2019-03-07T07:02:48.000Z","updated":"2019-06-16T10:05:31.786Z","comments":true,"path":"2019/03/07/190307-Algorithm-binary-search/","link":"","permalink":"http://JINUKK.github.io/2019/03/07/190307-Algorithm-binary-search/","excerpt":"","text":"Binary search(이진 탐색) 데이터의 집합이 반드시 정렬된 상태어야 함 시작 인덱스와 끝 인덱스 그리고 중간 인덱스를 정의 원하는 인덱스가 중간 인덱스보다 작다면 끝 인덱스를 중간 인덱스보다 작게 만든다. 원하는 인덱스가 중간 인덱스보다 크다면 시작 인덱스를 중간 인덱스보다 크게 만든다. 시작 인덱스가 끝 인덱스보다 커지면 반복을 멈춘다. 12345678910111213141516171819202122232425262728293031def binary_search(li, target): \"\"\" binary_search(li, target) -&gt; idx 반환값은 target이 있다면 target의 인덱스 target이 없다면 None을 반환 \"\"\" start_idx = 0 end_idx = len(li) - 1 while start_idx &lt;= end_idx: mid_idx = (start_idx + end_idx) // 2 if li[mid_idx] == target: return mid_idx elif li[mid_idx] &gt; target: end_idx = mid_idx - 1 else: start_idx = mid_idx + 1 return Noneli = [3, 5, 7, 8, 9, 11, 12]binary_search(li, 8)&gt;&gt; 3print(binary_search(li,13))&gt;&gt; None","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://JINUKK.github.io/categories/Algorithm/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://JINUKK.github.io/tags/algorithm/"},{"name":"binary search","slug":"binary-search","permalink":"http://JINUKK.github.io/tags/binary-search/"}]},{"title":"linear search","slug":"190307-Algorithm-linear-search","date":"2019-03-07T07:01:58.000Z","updated":"2019-06-16T10:04:46.742Z","comments":true,"path":"2019/03/07/190307-Algorithm-linear-search/","link":"","permalink":"http://JINUKK.github.io/2019/03/07/190307-Algorithm-linear-search/","excerpt":"","text":"Linear search(선형 탐색) 데이터가 모인 집합의 처음부터 끝까지 하나씩 순서대로 비교하여 찾음1234567891011121314151617181920def linear_search(li, target): \"\"\" linear_search(li, target) -&gt; idx 반환값은 target이 있다면 target의 인덱스 target이 없다면 None을 반환 \"\"\" for i in range(len(li)): if li[i] == target: return i return Noneli = [5, 7, 2, 8, 3, 9, 1]linear_search(li, 8)&gt;&gt; 3print(linear_search(li,10))&gt;&gt; None","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://JINUKK.github.io/categories/Algorithm/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://JINUKK.github.io/tags/algorithm/"},{"name":"linear search","slug":"linear-search","permalink":"http://JINUKK.github.io/tags/linear-search/"}]},{"title":"radix","slug":"190307-Python-radix","date":"2019-03-07T07:01:22.000Z","updated":"2019-06-16T07:29:16.049Z","comments":true,"path":"2019/03/07/190307-Python-radix/","link":"","permalink":"http://JINUKK.github.io/2019/03/07/190307-Python-radix/","excerpt":"","text":"기수(radix) 한 자리에 표현할 수 있는 수 10진수 - 0 , 1, 2, 3, 4, 5, 6, 7, 8, 9 2진수 - 0, 1 16진수 - 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F ‘0b’는 2진수 1a = 0b1010 # 0b는 2진수 ‘0x’는 16진수 hex()를 이용하여 16진수 변환 123456hex(a) # 0x는 16진수&gt;&gt; '0xa'b = 0b10101111hex(b)&gt;&gt; '0xaf' bin()을 이용하여 2진수 변환 1234c = 0xafbin(c)&gt;&gt; '0b10101111'","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"radix","slug":"radix","permalink":"http://JINUKK.github.io/tags/radix/"}]},{"title":"First class function","slug":"190307-Python-first-class-function","date":"2019-03-07T06:58:04.000Z","updated":"2019-06-16T07:28:37.162Z","comments":true,"path":"2019/03/07/190307-Python-first-class-function/","link":"","permalink":"http://JINUKK.github.io/2019/03/07/190307-Python-first-class-function/","excerpt":"","text":"first class function 조건 argument(parameter) - 매개 변수 함수 자체를 매개변수로 다른 함수에 전달1234567891011def f(a, b): return a + bdef g(func, c, d): return func(c, d)a = 10b = 20g(f, a, b) # 함수 자체를 매개변수로 전달&gt;&gt; 30 variable - 변수(값) 함수를 변수에 할당123456def f(a, b): return a + bf_var = f # 함수를 변수에 할당f_var(20 ,30)&gt;&gt; 50 return - 반환 다른 함수의 결과값으로 반환12345678910111213141516def create_calc(kind): if kind == 'add': def add(a, b): return a + b return add elif kind == 'sub': def sub(a, b): return a - b return sub # 다른 함수의 결과값으로 반환f = create_calc('add')f(10, 20)&gt;&gt; 30","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"first class function","slug":"first-class-function","permalink":"http://JINUKK.github.io/tags/first-class-function/"}]},{"title":"tower of hanoi","slug":"190307-Algorithm-tower-of-hanoi","date":"2019-03-07T06:55:52.000Z","updated":"2019-06-16T10:04:21.101Z","comments":true,"path":"2019/03/07/190307-Algorithm-tower-of-hanoi/","link":"","permalink":"http://JINUKK.github.io/2019/03/07/190307-Algorithm-tower-of-hanoi/","excerpt":"","text":"Tower of Hanoi(하노이 탑) 반드시 큰 쟁반이 아래에 있어야 한다. 큰 쟁반이 작은 쟁반보다 위에 있을 수 없다. 기둥1(_from), 기둥2(_by), 기둥3(_to)이 있다. 기둥 1에서 기둥3으로 모두 이동시켜야 한다. 1234567891011121314# (num - 1)개를 _from에서 _to를 이용하여 _by로 이동시킨다.# num(제일 큰 쟁반)을 _from에서 _to로 이동시킨다.# (n - 1)개를 _by에서 _from을 이용하여 _to로 이동시킨다.def hanoi(num, _from, _by, _to): #base case if num == 1: print(f'&#123;_from&#125;에서 &#123;_to&#125;로 &#123;num&#125;번째 쟁반 이동') return hanoi(num - 1, _from, _to, _by) print(f'&#123;_from&#125;에서 &#123;_to&#125;로 &#123;num&#125;번째 쟁반 이동') hanoi(num - 1, _by, _from, _to) 함수가 동작하는 모습을 stack frame으로 그려본다. “pythontutor.com”을 이용하여 함수가 동작하는 모습을 보는 것도 좋다. 점화식 및 기저 조건을 잘 만드는 것이 중요하다. stack frame에 쌓이는 모습을 call stack이라고 한다. call stack 맨 위에 있는 frame이 실행 권한을 가진다. 함수가 실행이 끝나지 않은 상태에서 위 frame에 실행 권한을 주는 것을 blocking이라고 한다. 12345678hanoi(3, 'A', 'B', 'C')&gt;&gt; A에서 C로 1번째 쟁반 이동 A에서 B로 2번째 쟁반 이동 C에서 B로 1번째 쟁반 이동 A에서 C로 3번째 쟁반 이동 B에서 A로 1번째 쟁반 이동 B에서 C로 2번째 쟁반 이동 A에서 C로 1번째 쟁반 이동","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://JINUKK.github.io/categories/Algorithm/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://JINUKK.github.io/tags/algorithm/"},{"name":"tower of hanoi","slug":"tower-of-hanoi","permalink":"http://JINUKK.github.io/tags/tower-of-hanoi/"}]},{"title":"2019.03.06 Python and CE Study","slug":"190306-PCE-Study","date":"2019-03-06T14:42:19.000Z","updated":"2019-05-06T14:56:46.984Z","comments":true,"path":"2019/03/06/190306-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/06/190306-PCE-Study/","excerpt":"","text":"프로그래머가 하는일 - 추상화(abstraction) 절차 지향 procedure, procedural oriented 절치 지향보다는 프로시져 지향이라고 하는 것이 맞다. 객체 지향 OOP(Object-Oriented Programming) 인터페이스(interface)와 구현(implementation) interface function signature 사용자들에게 제공(사용법만 알면 함수를 사용 가능하도록 함) implementation 함수를 직접 만들기(내부 구현) 함수 이름은 기능을 명확하게 표현해야 함 매개 변수는 어떻게 설계하고 무엇을 인자로 받을 것인지 생각해야 함 결과 값으로 어떤 결과를 반환할 것인지 생각해야 함 1234567def func(a, b):\"\"\"func(integer, integer) -&gt; integer두 값을 인자로 받고결과는 그 두 값을 더한 값\"\"\"return a + b ctrl + ]를 사용하면 indent됨(범위를 지정하여 사용 가능) 함수 안에 “”” “”” 사이에 함수 설명을 넣을 수 있음 ‘-&gt;’에는 반환되는 자료형을 써주는 것이 좋음 1234567help(func)&gt;&gt; Help on function func in module __main__: func(a, b) func(integer, integer) -&gt; integer 두 값을 인자로 받고 결과는 그 두 값을 더한 값 사용자 입력 받기 1234567891011input_data = input(\"무엇이든 입력하세요 : \")&gt;&gt; 무엇이든 입력하세요 : 여기에 입력type(input_data)&gt;&gt; strdata = int(input(\"숫자를 입력하세요 : \")) # int형변환&gt;&gt; 숫자를 입력하세요 : 1type(data)&gt;&gt; int Coding Practice 가위바위보 게임 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151def get_player_choice(): \"\"\" get_player_choice() -&gt; string string : &#123;'바위', '가위', '보'&#125; 결과값이 위 세 값 중에 하나임을 보장한다. \"\"\" player = input(\"바위, 가위, 보 중에 한 가지를 입력하세요 : \") while player != '바위' and player != '가위' and player != '보' : player = input('다시 입력하세요 : ') # while문에 직접 조건을 넣음 return playerimport random# 0 --&gt; '바위'# 1 --&gt; '가위'# 2 --&gt; '보'# random 내장 함수를 이용하기 위해 import로 random 모듈을 불러옴# Tuple 이용def get_computer_choice(): \"\"\" get_computer_choice() -&gt; string string = &#123;'바위', '가위', '보'&#125; \"\"\" choice_tu = ('바위', '가위', '보') computer = choice_tu[random.randint(0,2)] # 정수형 랜덤 숫자를 받음 return computerdef who_wins(player, computer): \"\"\" who_wins(player, computer) -&gt; string string = &#123;'player', 'computer', 'draw'&#125; \"\"\" if player == '바위': if computer == '바위': winner = 'draw' elif computer == '가위': winner = 'player' else: winner = 'computer' elif player == '가위': if computer == '바위': winner = 'computer' elif computer == '가위': winner = 'draw' else: winner = 'player' else: if computer == '바위': winner = 'player' elif computer == '가위': winner = 'computer' else: winner = 'draw' return winnerdef play_one(): \"\"\" play_one() -&gt; string string = &#123;'player', 'computer', 'draw'&#125; 한 판에 대해서 플레이어가 이기면 \"플레이어 승\" 출력 컴퓨터가 이기면 \"컴퓨터 승\" 출력 비기면 \"무승부\" 출력 무승부가 나면 둘 중에 한 명이 이길 때까지 반복 \"\"\" while True: player = get_player_choice() computer = get_computer_choice() winner = who_wins(player, computer) if winner == 'player': print('플레이어 승!') return 'player' elif winner == 'computer': print('컴퓨터 승!') return 'computer' else: print('무승부') pass # pass는 실행할 것이 아무것도 없다는 의미 # pass는 아무런 동작을 하지 않고 다음 코드를 실행 # continue는 다음 순번의 loop를 실행 # pass와 continue의 차이 알기 def play(): while True: try: user_num_games = int(input(\"1: 3판2선승, 2: 5판3선승: \")) if user_num_games != 1 and user_num_games != 2: print(\"1 또는 2의 값만 입력하세요.\") continue else: break except ValueError: print(\"숫자가 아닌 값을 입력하셨습니다. 다시 입력하세요.\") #user_num_games --&gt; 1 or 2 num_games = 3 if user_num_games == 1 else 5 #3판 2선승 --&gt; 2승 or 5판 3선승 --&gt; 3승 count = 2 if num_games == 3 else 3 win_list = [] # 리스트를 만들어서 이긴 대상을 리스트 인덱스로 넣어둔다. # 리스트 내장 함수 count를 사용하여 선승을 판단한다. # for문 내부에 i라는 변수를 사용하지 않으면 _로 표시해도 무관하다. for _ in range(num_games): win_list.append(play_one()) print('player : ', win_list.count('player'),'승', 'computer : ', win_list.count('computer'),'승') if win_list.count('player') &gt;= count: print(\"플레이어 우승!\") break elif win_list.count('computer') &gt;= count: print(\"컴퓨터 우승!\") breakplay()&gt;&gt; 1: 3판2선승, 2: 5판3선승: 1 바위, 가위, 보 중에 한 가지를 입력하세요 : 바위 무승부 바위, 가위, 보 중에 한 가지를 입력하세요 : 가위 컴퓨터 승! player : 0 승 computer : 1 승 바위, 가위, 보 중에 한 가지를 입력하세요 : 보 컴퓨터 승! player : 0 승 computer : 2 승 컴퓨터 우승! pass와 continue pass 실행할 코드가 없다는 것을 의미 다음 코드를 실행 12345for i in range(1, 5): if i == 3: pass print(i, end = ' ') # 3일 때에도 print 함수를 실행함&gt;&gt; 1 2 3 4 continue 조건이 참이 되면 다음 순번으로 강제 이동 12345for i in range(1, 5): if i == 3: continue print(i, end = ' ') # 3일 때 loop의 다음 순번으로 이동, print 함수를 실행하지 않음&gt;&gt; 1 2 4 packing과 unpacking packing tuple로 선언하지 않았음 type은 tuple로 나옴 = packing이 되었음 123container = 1, 2, 3, 4, 5type(container)&gt;&gt; tuple unpacking 위 container 변수를 unpacking 함 변수 앞에 *를 붙여주면 묶음 123456789a, b, *c = containera&gt;&gt; 1b&gt;&gt; 2c&gt;&gt; [3, 4, 5] dictionary에서 items()도 unpacking 1234dic = &#123;'a' : 1, 'b' : 2&#125;for k, v in dic.items(): print(k,v, end = ' ')&gt;&gt; a 1 b 2 packing과 unpacking 활용 함수에서 매개변수 앞에 *를 붙여주면 가변인자로 받을 수 있다. 12345def sum_int(*args): # 함수에서 가변인자 받는 방법 s = 0 for arg in args: s += arg return s 아래와 같이 1, 2, 3, 4, 5의 가변인자가 들어오면 tuple로 packing이 됨 12sum_int(1, 2, 3, 4, 5)&gt;&gt; 15 아래와 같이 list 형태로 가변인자를 넣게 되면 하나의 데이터로 인식하여 에러 발생 1234li = [1, 2, 3, 4]sum_int(li)&gt;&gt; TypeError: unsupported operand type(s) for +=: 'int' and 'list' 따라서 *를 붙여서 다시 unpacking하여 사용 123# *를 붙여서 다시 unpacking하여 사용sum_int(*li)&gt;&gt; 10 아래와 같은 매개변수의 형태로 모든 인자를 다 받을 수 있다. args : non keyword arguments kwargs : keyword arguments kwargs는 dictionary를 packing할 때 사용한다.(keyword가 존재) 함수를 정의할 때, *args, **kwargs는 가변인자를 받겠다는 의미이다. 1234567def sum_int(*args, **kwargs): print(args) print(kwargs)sum_int(1, 2, 3, age = 100, weight = 100)&gt;&gt; (1, 2, 3) &#123;'age': 100, 'weight': 100&#125; keyword가 없는 인자는 앞에, keyword가 있는 인자는 뒤에 위치해야 한다. keyword 인자 뒤에 keyword가 없는 인자가 존재하면 에러가 발생한다. 12sum_int(1, 2, 3, age = 100, weight = 100, 4)&gt;&gt; SyntaxError: positional argument follows keyword argument 함수를 호출하는 입장에서의 *, **는 unpacking을 의미한다. 123sum_int(*li, **dic)&gt;&gt; (1, 2, 3, 4) &#123;'a': 1, 'b': 2&#125; 삼항 연산자 ‘참인 경우의 값’ if ‘조건’ else ‘거짓인 경우의 값’ if문의 일반 사용 예 123456a = 10if a &gt;= 10: print('good!')else: print('bad!')&gt;&gt; good! 삼항 연산자 적용 예 12345# if 조건문 결과는 앞에, else 조건문 결과는 뒤에 위치시킨다.# if else 간에 ':'를 붙이지 않아도 된다.print('good!') if a &gt;= 10 else print('bad!')&gt;&gt; good! 재귀 함수(recursive function, recursion) 자기가 자기 자신을 호출하는 함수 기저 조건(base case) = 종료 조건, 탈출 조건 Basic 기저 조건을 반드시 정해줘야 한다.(종료, 탈출) 재귀하는 과정에서 자기 자신을 만날 때마다 blocking이 걸린다. blocking이 걸린 다음에 함수가 호출되며 stack frame에 쌓인다. 함수가 쌓일 수 있는 stack frame 공간이 정해져 있다. 정해진 stack frame을 넘어버리면 stack overflow가 발생한다. 123456789101112def func(num): # 기저 조건(base case) # 종료 조건 # 탈출 조건 if num &lt;= 0: return print(num, end = ' ') func(num - 1) func(5)&gt;&gt; 5 4 3 2 1 Basic function example factorial(계승) 점화식 –&gt; fac(num) = fac(num - 1)*num 기저 조건 –&gt; if num == 1 return 1 123456789def factorial(num): if num == 1: return 1 return factorial(num - 1) * num for num in range(1, 10): print(factorial(num), end = ' ')&gt;&gt; 1 2 6 24 120 720 5040 40320 362880 fibonacci(피보나치) 점화식 : fibo(n) = fibo(n - 2) + fibo(n - 1) 기저 조건 : if n == 1 or n == 2 then return 1 123456789def fibonacci(n): if n == 1 or n == 2: return 1 return fibonacci(n - 2) + fibonacci(n - 1)for n in range(1, 10): print(fibonacci(n), end = ' ')&gt;&gt; 1 1 2 3 5 8 13 21 34","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"Recursive function","slug":"190306-Python-recursive-function","date":"2019-03-06T06:47:05.000Z","updated":"2019-06-16T06:51:16.206Z","comments":true,"path":"2019/03/06/190306-Python-recursive-function/","link":"","permalink":"http://JINUKK.github.io/2019/03/06/190306-Python-recursive-function/","excerpt":"","text":"재귀 함수(recursive function, recursion) 자기가 자기 자신을 호출하는 함수 기저 조건(base case) = 종료 조건, 탈출 조건 Basic 기저 조건을 반드시 정해줘야 한다.(종료, 탈출) 재귀하는 과정에서 자기 자신을 만날 때마다 blocking이 걸린다. blocking이 걸린 다음에 함수가 호출되며 stack frame에 쌓인다. 함수가 쌓일 수 있는 stack frame 공간이 정해져 있다. 정해진 stack frame을 넘어버리면 stack overflow가 발생한다.123456789101112def func(num): # 기저 조건(base case) # 종료 조건 # 탈출 조건 if num &lt;= 0: return print(num, end = ' ') func(num - 1)func(5)&gt;&gt; 5 4 3 2 1 Basic function example factorial(계승) 점화식 –&gt; fac(num) = fac(num - 1)*num 기저 조건 –&gt; if num == 1 return 112345678def factorial(num): if num == 1: return 1 return factorial(num - 1) * numfor num in range(1, 10): print(factorial(num), end = ' ')&gt;&gt; 1 2 6 24 120 720 5040 40320 362880 fibonacci(피보나치) 점화식 : fibo(n) = fibo(n - 2) + fibo(n - 1) 기저 조건 : if n == 1 or n == 2 then return 112345678def fibonacci(n): if n == 1 or n == 2: return 1 return fibonacci(n - 2) + fibonacci(n - 1)for n in range(1, 10): print(fibonacci(n), end = ' ')&gt;&gt; 1 1 2 3 5 8 13 21 34","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"recursive function","slug":"recursive-function","permalink":"http://JINUKK.github.io/tags/recursive-function/"}]},{"title":"삼항 연산자","slug":"190306-Python-ternary-operator","date":"2019-03-06T06:46:37.000Z","updated":"2019-06-16T06:52:21.884Z","comments":true,"path":"2019/03/06/190306-Python-ternary-operator/","link":"","permalink":"http://JINUKK.github.io/2019/03/06/190306-Python-ternary-operator/","excerpt":"","text":"‘참인 경우의 값’ if ‘조건’ else ‘거짓인 경우의 값’ if문의 일반 사용 예 123456a = 10if a &gt;= 10: print('good!')else: print('bad!')&gt;&gt; good! 삼항 연산자 적용 예 1234# if 조건문 결과는 앞에, else 조건문 결과는 뒤에 위치시킨다.# if else 간에 ':'를 붙이지 않아도 된다.print('good!') if a &gt;= 10 else print('bad!')&gt;&gt; good!","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"operator","slug":"operator","permalink":"http://JINUKK.github.io/tags/operator/"},{"name":"if","slug":"if","permalink":"http://JINUKK.github.io/tags/if/"}]},{"title":"packing과 unpacking","slug":"190306-Python-packing-unpacking","date":"2019-03-06T06:45:32.000Z","updated":"2019-06-16T06:49:19.461Z","comments":true,"path":"2019/03/06/190306-Python-packing-unpacking/","link":"","permalink":"http://JINUKK.github.io/2019/03/06/190306-Python-packing-unpacking/","excerpt":"","text":"packing tuple로 선언하지 않았음 type은 tuple로 나옴 = packing이 되었음123container = 1, 2, 3, 4, 5type(container)&gt;&gt; tuple unpacking 위 container 변수를 unpacking 함 변수 앞에 *를 붙여주면 묶음 1234567a, b, *c = containera&gt;&gt; 1b&gt;&gt; 2c&gt;&gt; [3, 4, 5] dictionary에서 items()도 unpacking 1234dic = &#123;'a' : 1, 'b' : 2&#125;for k, v in dic.items(): print(k,v, end = ' ')&gt;&gt; a 1 b 2 packing과 unpacking 활용 함수에서 매개변수 앞에 *를 붙여주면 가변인자로 받을 수 있다. 12345def sum_int(*args): # 함수에서 가변인자 받는 방법 s = 0 for arg in args: s += arg return s 아래와 같이 1, 2, 3, 4, 5의 가변인자가 들어오면 tuple로 packing이 됨 12sum_int(1, 2, 3, 4, 5)&gt;&gt; 15 아래와 같이 list 형태로 가변인자를 넣게 되면 하나의 데이터로 인식하여 에러 발생 123li = [1, 2, 3, 4]sum_int(li)&gt;&gt; TypeError: unsupported operand type(s) for +=: 'int' and 'list' 따라서 *를 붙여서 다시 unpacking하여 사용 123# *를 붙여서 다시 unpacking하여 사용sum_int(*li)&gt;&gt; 10 아래와 같은 매개변수의 형태로 모든 인자를 다 받을 수 있다. args : non keyword arguments kwargs : keyword arguments kwargs는 dictionary를 packing할 때 사용한다.(keyword가 존재) 함수를 정의할 때, *args, **kwargs는 가변인자를 받겠다는 의미이다. 1234567def sum_int(*args, **kwargs): print(args) print(kwargs)sum_int(1, 2, 3, age = 100, weight = 100)&gt;&gt; (1, 2, 3) &#123;'age': 100, 'weight': 100&#125; keyword가 없는 인자는 앞에, keyword가 있는 인자는 뒤에 위치해야 한다. keyword 인자 뒤에 keyword가 없는 인자가 존재하면 에러가 발생한다. 12sum_int(1, 2, 3, age = 100, weight = 100, 4)&gt;&gt; SyntaxError: positional argument follows keyword argument 함수를 호출하는 입장에서의 *, **는 unpacking을 의미한다. 123sum_int(*li, **dic)&gt;&gt; (1, 2, 3, 4) &#123;'a': 1, 'b': 2&#125;","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"packing","slug":"packing","permalink":"http://JINUKK.github.io/tags/packing/"},{"name":"unpacking","slug":"unpacking","permalink":"http://JINUKK.github.io/tags/unpacking/"},{"name":"args","slug":"args","permalink":"http://JINUKK.github.io/tags/args/"},{"name":"kwargs","slug":"kwargs","permalink":"http://JINUKK.github.io/tags/kwargs/"}]},{"title":"pass와 continue","slug":"190306-Python-pass-continue","date":"2019-03-06T06:45:22.000Z","updated":"2019-06-16T06:47:57.687Z","comments":true,"path":"2019/03/06/190306-Python-pass-continue/","link":"","permalink":"http://JINUKK.github.io/2019/03/06/190306-Python-pass-continue/","excerpt":"","text":"pass 실행할 코드가 없다는 것을 의미 다음 코드를 실행12345for i in range(1, 5): if i == 3: pass print(i, end = ' ') # 3일 때에도 print 함수를 실행함&gt;&gt; 1 2 3 4 continue 조건이 참이 되면 다음 순번으로 강제 이동12345for i in range(1, 5): if i == 3: continue print(i, end = ' ') # 3일 때 loop의 다음 순번으로 이동, print 함수를 실행하지 않음&gt;&gt; 1 2 4","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"pass","slug":"pass","permalink":"http://JINUKK.github.io/tags/pass/"},{"name":"continue","slug":"continue","permalink":"http://JINUKK.github.io/tags/continue/"}]},{"title":"2019.03.05 Python and CE Study","slug":"190305-PCE-Study","date":"2019-03-05T14:23:40.000Z","updated":"2019-05-06T14:41:14.884Z","comments":true,"path":"2019/03/05/190305-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/05/190305-PCE-Study/","excerpt":"","text":"Dictiionary key와 value가 한 쌍 hash로 구현(대응 관계) Basic key:value로 입력 중괄호 사용 1dic = &#123;'a': 1, 'b': 2, 'c': 3&#125; 새로운 값을 삽입 123dic['e'] = 4dic&gt;&gt; &#123;'a': 1, 'b': 2, 'c': 3, 'e': 4&#125; 기존 값 변경이 가능 123dic['a'] = 20dic&gt;&gt; &#123;'a': 20, 'b': 2, 'c': 3, 'e': 4&#125; 변경이 불가능한 객체를 key로 사용 key 값은 변경이 가능한 객체로 사용 불가능(unhashable) 1234567dic[(1, 2, 3)] = 50dic&gt;&gt; &#123;'a': 20, 'b': 2, 'c': 3, 'e': 4, (1, 2, 3): 50&#125;dic[[5, 6, 'a']] = 60 # 변경이 가능한 객체를 키로 사용 불가능&gt;&gt; TypeError: unhashable type: 'list' 관련 함수들 1dir(dic) 12# dictionary 예시dic = &#123;'a' : 1, 'b' : 2, 'c' : 3&#125; 1) search 계열 - get() : key로 value 얻기 - key가 없는 값을 불러오면 에러가 발생하지만, get()을 사용하면 None을 반환 12345678910111213141516171819202122232425262728293031323334353637dic.get('c')&gt;&gt; 3print(\"dic.get('e') : \", dic.get('e'))&gt;&gt; dic.get('e') : Noneprint(\"dic['e'] : \", dic['e'])&gt;&gt; KeyError: 'e'if dic.get('e'): print(dic['e'])else: print('No data') # dic.get('e') = None이므로 if문이 실행하지 않음&gt;&gt; No datatry: print(dic['e'])except KeyError: print('No data') # try except문을 사용&gt;&gt; No data# key 값이 없을 경우, get(key, default_value)를 사용하여 default 값을 대신 가져옴dic.get('e', 2)&gt;&gt; 2# for문을 사용할 경우, key 값만 가져옴for i in dic: print(i, end = ' ')&gt;&gt; a b c# items()를 사용할 경우, key와 value 모두를 가져옴for pair in dic.items(): print(pair, end = ' ') # tuple 형태&gt;&gt; ('a', 1) ('b', 2) ('c', 3)for key, value in dic.items():print(key, value, end = ' ') # tuple 형태로 가져오지 않음&gt;&gt; a 1 b 2 c 3 2) delete 계열 - pop() : 원하는 key의 value를 반환하고 삭제 - popitems() : 임의의 key와 value를 반환하고 삭제 123456789dic.pop('b')&gt;&gt; 2dic&gt;&gt; &#123;'a': 1, 'c': 3&#125;dic.popitem()&gt;&gt; ('c', 3)dic&gt;&gt; &#123;'a': 1&#125; 3) insert 계열 - update() : key가 있으면 원하는 value로 바꾸고 key가 없으면 추가 - setdefault() : 원하는 key의 value를 찾아 반환 123456789101112131415161718192021dic = &#123;'a' : 1, 'b' : 2, 'c' : 3&#125;dic.update(&#123;'b':40, 'd':50&#125;)dic&gt;&gt; &#123;'a': 1, 'b': 40, 'c': 3, 'd': 50&#125;# tuple을 사용하면 dictionary 안에서는 key와 value로 넣어줌c = (('e', 11), ('f', 12))dic.update(c)dic&gt;&gt; &#123;'a': 1, 'b': 40, 'c': 3, 'd': 50, 'e': 11, 'f': 12&#125;dic = &#123;'a' : 1, 'b' : 2, 'c' : 3&#125;dic.setdefault('b')&gt;&gt; 2# setdefault()는 key가 없을 경우, default 값으로 새로운 요소 추가dic.setdefault('e', 10)&gt;&gt; 10dic&gt;&gt; &#123;'a': 1, 'b': 2, 'c': 3, 'e': 10&#125; 4) view 객체 사용 12345678910111213141516171819202122232425262728293031323334353637383940414243444546dic = &#123;'a' : 1, 'b' : 2, 'c' : 3&#125;# keys()를 사용하여 key에 관한 view 객체 반환# list 형변환을 사용하여 list로 사용 가능key_view = dic.keys()key_view&gt;&gt; dict_keys(['a', 'b', 'c'])key_list = list(dic.keys())key_list&gt;&gt; ['a', 'b', 'c']# values()를 사용하여 value에 관한 view 객체 반환# list 형변환을 사용하여 list로 사용 가능value_view = dic.values()value_view&gt;&gt; dict_values([1, 2, 3])value_list = list(dic.values())value_list&gt;&gt; [1, 2, 3]# 요소 값을 추가할 경우, view 객체는 변경됨# list 형변환을 통해 대입해준 list 변수는 변하지 않음dic['d'] = 4key_view&gt;&gt; dict_keys(['a', 'b', 'c', 'd'])value_view&gt;&gt; dict_values([1, 2, 3, 4])key_list&gt;&gt; ['a', 'b', 'c']value_list&gt;&gt; [1, 2, 3]# list 형변환을 다시 해줘야 한다.list(dic.keys())&gt;&gt; ['a', 'b', 'c', 'd']# 대입해준 list는 여전히 변하지 않는다.key_list&gt;&gt; ['a', 'b', 'c']dic&gt;&gt; &#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125; for 문 반복문 Basic iterable 객체(순회하는 객체) 이용 가능 1234567891011121314li = [1, 2, 3]for a in li: print(a, end = ' ')&gt;&gt; 1 2 3tu = (1, 2, 3, 'a')for t in tu: print(t, end = ' ')&gt;&gt; 1 2 3 astring = 'abcde'for ch in string: print(ch, end = ' ')&gt;&gt; a b c d e range(start, end, step) : 범위 끝은 포함하지 않음 1234567891011for num in range(1, 11): print(num, end = ' ')&gt;&gt; 1 2 3 4 5 6 7 8 9 10for num in range(1, 11, 2): print(num, end = ' ')&gt;&gt; 1 3 5 7 9for num in range(11): print(num, end = ' ')&gt;&gt; 0 1 2 3 4 5 6 7 8 9 10 List Comprehension for문을 이용한 list 생성 12345li = []for i in range(1, 11): li.append(i)li&gt;&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 리스트 컴프리헨션을 통한 list 생성 1234# i 값에 연산도 가능하다.li2 = [i for i in range(1, 11)]li2&gt;&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] Dictionary Comprehension 1234# 튜플 속의 튜플 선언tu = (('a', 1), ('b', 2), ('c', 3), ('d', 4))tu&gt;&gt; (('a', 1), ('b', 2), ('c', 3), ('d', 4)) for문을 이용한 dictionary 생성 12345dic = &#123;&#125;for k, v in tu: dic[k] = vdic&gt;&gt; &#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125; 딕셔너리 컴프리헨션을 통한 dictionary 생성 1234# v 값에 연산도 가능하다.dic2 = &#123;k : v for k, v in tu&#125;dic2&gt;&gt; &#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125; while 문 반복문 1234567891011# a가 5보다 클 경우 반복# a가 7일 경우 break문을 통해 빠져나감# 'a = a - 1'은 'a -=1'로 사용 가능a = 10while a &gt; 5: print(a, end = ' ') if a == 7: break a -= 1&gt;&gt; 10 9 8 7 Boolean Basic 0 이외에 모든 정수가 참이다. 할당할 때는 ‘=’, 비교할 때는 ‘==’ 12345678910111213141516171819202122a = True # 참b = False # 거짓a = 10if a == 10: print('a == 10')&gt;&gt; a == 10# else if = elifif a &gt; 10: print('a &gt; 10')elif a &lt; 10: print('a &lt; 10')else: print('a == 10')&gt;&gt; a == 10a == 10&gt;&gt; Truea &lt; 10&gt;&gt; False python에서 False로 간주하는 객체 False, None, 빈 문자열, 빈 리스트, 빈 튜플, 빈 딕셔너리, 공집합(set()) not을 사용하여 반대 선언 가능 1234567891011121314151617li = []if not li: print('True')&gt;&gt; Truetu = ()if not tu: print('True')&gt;&gt; Truedic = &#123;&#125;if not &#123;&#125;: print('True')&gt;&gt; Truenot False&gt;&gt; True Operator 논리 연산자 AND : 모두 참일 때 빼고는 다 거짓 OR : 모두 거짓일 때 빼고는 다 참 12345True and True&gt;&gt; TrueFalse or False&gt;&gt; False 맨 마지막에 참조하는 객체를 반환 [1, 2] or [] 에서는 이미 [1, 2]에서 참 거짓 판단이 끝났으므로, 뒤 []까지 보지 않음 [1, 2] and []에서는 [1, 2]가 참이면 뒤에까지 봐야하므로 뒤까지 보고 판단 [] and [1, 2]일 경우 이미 앞에서 거짓이므로 거짓 판단 [1, 2] and [3, 4]이면 앞이 참이고 뒤에도 참이므로 뒤를 출력(마지막 참조 객체) 1234567891011[1, 2] and []&gt;&gt; [][1, 2] or []&gt;&gt; [1, 2][1, 2] or [3, 4]&gt;&gt; [1, 2][] or [3, 4]&gt;&gt; [3, 4] 비트 연산자 AND : &amp; OR : | 12345bin(0b1010 &amp; 0b1100) # AND&gt;&gt; '0b1000'bin(0b1010 | 0b1100) # OR&gt;&gt; '0b1110' XOR(EXCLUSIVE OR) 서로 다르면 참, 서로 같으면 거짓 12bin(0b1010 ^ 0b1100)&gt;&gt; '0b110' 비트 이동 연산자(Shift Operator) 꺾여있는 방향으로 이동 123451 &lt;&lt; 1&gt;&gt; 210 &gt;&gt; 1&gt;&gt; 5 산술 연산자 +, -, /, //, *… 등등 실수형 나누기 1210 / 3&gt;&gt; 3.3333333333333335 정수형 나누기 1210 // 3&gt;&gt; 3 제곱 표현 122**52 # 2의 52승&gt;&gt; 4503599627370496 나머지 구하기 123a = 8 % 3a&gt;&gt; 2 Function routine, subroutine, proceduce, function 함수 정의 전역 변수(global variable) : global frame에 쌓인다. 지역 변수(local variable) : 함수가 호출되고 stack frame이 생길때 생기고 함수가 끝나면 사라진다. 함수 선언 시, 들여쓰기 공백은 4칸으로 4의 배수로만 띄워주면 문제없다. 12345a = 10 # 전역 변수b = 20 # 전역 변수def func(c,d): e = c + d # 지역 변수 return e 함수 호출 함수가 호출되는 시점이 바로 stack frame이 생성되는 시점이다. 12func(a, b)&gt;&gt; 30 namespace 변수의 유효 범위를 namespace 기반으로 결정 1234567891011121314# 전역 변수 g_val은 global frame에 생성# stack frame이 생성되는 시점은 func(g_val)이 실행될 때# def func(val) 부분이 생성 시점이 아님# 함수가 호출됨으로 인해 매개변수 val은 120을 가리킴# 하지만 전역 변수 g_val은 20으로 변하지 않음g_val = 20def func(val): val += 100func(g_val)g_val&gt;&gt; 20 global문을 사용하여 func() 내에서 전역 변수 수정 가능 1234567def func(): global g_val g_val += 30func()g_val&gt;&gt; 50 namespace 개념을 통해 ‘이름 공간’에서 가장 가까운 변수에 접근 nonlocal문을 사용하면 함수에서 가장 가까운 해당 변수에 접근할 수 있다. nonlocal문으로 지정해주지 않아도 가장 가까운 해당 변수에 접근한다. 가장 가까운 변수에 접근하게 되면 그 이상의 공간 변수로 접근하지 않는다. 1234567891011121314151617181920# 변수 b와 같은 경우, 전역 변수와 지역 변수 모두 아니다.a = 10def outer(): b = 100 def inner1(): b = 30 def inner2(): nonlocal b b -= 10 print(b) d = 40 inner2() inner1() print(b)outer()&gt;&gt; 20 100 Algorithm bubble_sort(거품 정렬) Comparson sort의 한 종류 두 수를 비교해서 정렬하는 방법 마지막 전 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬 한번 순회가 끝나면 가장 큰 자료가 맨 뒤로 이동 2번째 순회에서는 맨 끝에 잇는 자료는 정렬에서 제외되는 방식 순회할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어남 123456789101112li = [5, 2, 9, 3, 8, 4]def bubble_sort(li):n = len(li)for i in range(n - 1): for j in range(n - 1 - i): if li[j] &gt; li[j+1]: li[j], li[j + 1] = li[j + 1], li[j]bubble_sort(li)li&gt;&gt; [2, 3, 4, 5, 8, 9] python에서의 두 변수 값 바꾸기(swap) 보통 임시로 저장할 변수를 이용하여 바꿈 12345678910a = 10b = 20temp = aa = bb = tempprint(a, b)&gt;&gt; 20 10 python에서는 한 줄로 바꾸기 가능 123456a = 10b = 20a, b = b, aprint(a, b)&gt;&gt; 20 10","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]},{"title":"bubble sort","slug":"190305-Algorithm-Sort-bubble-sort","date":"2019-03-05T06:30:23.000Z","updated":"2019-07-21T07:26:03.715Z","comments":true,"path":"2019/03/05/190305-Algorithm-Sort-bubble-sort/","link":"","permalink":"http://JINUKK.github.io/2019/03/05/190305-Algorithm-Sort-bubble-sort/","excerpt":"","text":"Help Link! GeeksforGeeks Youtube(https://www.youtube.com/watch?v=nmhjrI-aW5o) bubble sort(거품 정렬) Comparison sort의 한 종류 두 수를 비교해서 정렬하는 방법 O(n^2) simple sort 마지막 전 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬 한번 순회가 끝나면 가장 큰 자료가 맨뒤로 이동 2번째 순회에서는 맨 끝에 있는 자료를 정렬에서 제외되는 방식 순회할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어남 123456789101112131415161718192021222324import randomdef bubble_sort(li): n = len(li) for i in range(n-1): for j in range(n-i-1): if li[j] &gt; li[j+1]: li[j], li[j+1] = li[j+1], li[j] if __name__ == '__main__': while True: num_data = int(input('데이터 개수(종료:0):')) if not num_data: break data = [random.randint(1,100) for _ in range(num_data)] print(data) bubble_sort(data) print(data) python에서의 두 변수 값 바꾸기(swap) 보통 임시로 저장할 변수를 이용하여 바꿈 1234567a = 10b = 20temp = aa = bb = tempprint(a, b)&gt;&gt; 20 10 python에서는 한 줄로 바꾸기 가능 12345a = 10b = 20a, b = b, aprint(a, b)&gt;&gt; 20 10","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://JINUKK.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://JINUKK.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://JINUKK.github.io/tags/algorithm/"},{"name":"sort","slug":"sort","permalink":"http://JINUKK.github.io/tags/sort/"},{"name":"bubble sort","slug":"bubble-sort","permalink":"http://JINUKK.github.io/tags/bubble-sort/"}]},{"title":"function","slug":"190305-Python-function","date":"2019-03-05T06:29:44.000Z","updated":"2019-06-16T06:43:33.181Z","comments":true,"path":"2019/03/05/190305-Python-function/","link":"","permalink":"http://JINUKK.github.io/2019/03/05/190305-Python-function/","excerpt":"","text":"routine, subroutine, proceduce, function 함수 정의 전역 변수(global variable) : global frame에 쌓인다. 지역 변수(local variable) : 함수가 호출되고 stack frame이 생길때 생기고 함수가 끝나면 사라진다. 함수 선언 시, 들여쓰기 공백은 4칸으로 4의 배수로만 띄워주면 문제없다.12345a = 10 # 전역 변수b = 20 # 전역 변수def func(c,d): e = c + d # 지역 변수 return e 함수 호출 함수가 호출되는 시점이 바로 stack frame이 생성되는 시점이다.12func(a, b)&gt;&gt; 30 namespace 변수의 유효 범위를 namespace 기반으로 결정 123456789101112# 전역 변수 g_val은 global frame에 생성# stack frame이 생성되는 시점은 func(g_val)이 실행될 때# def func(val) 부분이 생성 시점이 아님# 함수가 호출됨으로 인해 매개변수 val은 120을 가리킴# 하지만 전역 변수 g_val은 20으로 변하지 않음g_val = 20def func(val): val += 100func(g_val)g_val&gt;&gt; 20 global문을 사용하여 func() 내에서 전역 변수 수정 가능 1234567def func(): global g_val g_val += 30func()g_val&gt;&gt; 50 namespace 개념을 통해 ‘이름 공간’에서 가장 가까운 변수에 접근 nonlocal문을 사용하면 함수에서 가장 가까운 해당 변수에 접근할 수 있다. nonlocal문으로 지정해주지 않아도 가장 가까운 해당 변수에 접근한다. 가장 가까운 변수에 접근하게 되면 그 이상의 공간 변수로 접근하지 않는다.123456789101112131415161718# 변수 b와 같은 경우, 전역 변수와 지역 변수 모두 아니다.a = 10def outer(): b = 100 def inner1(): b = 30 def inner2(): nonlocal b b -= 10 print(b) d = 40 inner2() inner1() print(b)outer()&gt;&gt; 20 100","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"function","slug":"function","permalink":"http://JINUKK.github.io/tags/function/"},{"name":"namespace","slug":"namespace","permalink":"http://JINUKK.github.io/tags/namespace/"}]},{"title":"operator","slug":"190305-Python-operator","date":"2019-03-05T06:29:39.000Z","updated":"2019-06-16T06:32:54.544Z","comments":true,"path":"2019/03/05/190305-Python-operator/","link":"","permalink":"http://JINUKK.github.io/2019/03/05/190305-Python-operator/","excerpt":"","text":"논리 연산자 AND : 모두 참일 때 빼고는 다 거짓 OR : 모두 거짓일 때 빼고는 다 참 12345True and True&gt;&gt; TrueFalse or False&gt;&gt; False 맨 마지막에 참조하는 객체를 반환 [1, 2] or [] 에서는 이미 [1, 2]에서 참 거짓 판단이 끝났으므로, 뒤 []까지 보지 않음 [1, 2] and []에서는 [1, 2]가 참이면 뒤에까지 봐야하므로 뒤까지 보고 판단 [] and [1, 2]일 경우 이미 앞에서 거짓이므로 거짓 판단 [1, 2] and [3, 4]이면 앞이 참이고 뒤에도 참이므로 뒤를 출력(마지막 참조 객체)1234567891011[1, 2] and []&gt;&gt; [][1, 2] or []&gt;&gt; [1, 2][1, 2] or [3, 4]&gt;&gt; [1, 2][] or [3, 4]&gt;&gt; [3, 4] 비트 연산자 AND : &amp; OR : | 12345bin(0b1010 &amp; 0b1100) # AND&gt;&gt; '0b1000'bin(0b1010 | 0b1100) # OR&gt;&gt; '0b1110' XOR(EXCLUSIVE OR) 서로 다르면 참, 서로 같으면 거짓 12bin(0b1010 ^ 0b1100)&gt;&gt; '0b110' 비트 이동 연산자(Shift Operator) 꺾여있는 방향으로 이동123451 &lt;&lt; 1&gt;&gt; 210 &gt;&gt; 1&gt;&gt; 5 산술 연산자 +, -, /, //, *… 등등 실수형 나누기 1210 / 3&gt;&gt; 3.3333333333333335 정수형 나누기 1210 // 3&gt;&gt; 3 제곱 표현 122**52 # 2의 52승&gt;&gt; 4503599627370496 나머지 구하기 123a = 8 % 3a&gt;&gt; 2","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"operator","slug":"operator","permalink":"http://JINUKK.github.io/tags/operator/"}]},{"title":"반복문","slug":"190305-Python-loop","date":"2019-03-05T06:29:31.000Z","updated":"2019-06-16T06:44:25.784Z","comments":true,"path":"2019/03/05/190305-Python-loop/","link":"","permalink":"http://JINUKK.github.io/2019/03/05/190305-Python-loop/","excerpt":"","text":"for 문 Basic iterable 객체(순회하는 객체) 이용 가능 1234567891011121314li = [1, 2, 3]for a in li: print(a, end = ' ')&gt;&gt; 1 2 3tu = (1, 2, 3, 'a')for t in tu: print(t, end = ' ')&gt;&gt; 1 2 3 astring = 'abcde'for ch in string: print(ch, end = ' ')&gt;&gt; a b c d e range(start, end, step) : 범위 끝은 포함하지 않음 1234567891011for num in range(1, 11): print(num, end = ' ')&gt;&gt; 1 2 3 4 5 6 7 8 9 10for num in range(1, 11, 2): print(num, end = ' ')&gt;&gt; 1 3 5 7 9for num in range(11): print(num, end = ' ')&gt;&gt; 0 1 2 3 4 5 6 7 8 9 10 List Comprehension for문을 이용한 list 생성 12345li = []for i in range(1, 11): li.append(i)li&gt;&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 리스트 컴프리헨션을 통한 list 생성 1234# i 값에 연산도 가능하다.li2 = [i for i in range(1, 11)]li2&gt;&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] Dictionary Comprehension 1234# 튜플 속의 튜플 선언tu = (('a', 1), ('b', 2), ('c', 3), ('d', 4))tu&gt;&gt; (('a', 1), ('b', 2), ('c', 3), ('d', 4)) for문을 이용한 dictionary 생성 12345dic = &#123;&#125;for k, v in tu: dic[k] = vdic&gt;&gt; &#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125; 딕셔너리 컴프리헨션을 통한 dictionary 생성 1234# v 값에 연산도 가능하다.dic2 = &#123;k : v for k, v in tu&#125;dic2&gt;&gt; &#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125; while 문12345678910# a가 5보다 클 경우 반복# a가 7일 경우 break문을 통해 빠져나감# 'a = a - 1'은 'a -=1'로 사용 가능a = 10while a &gt; 5: print(a, end = ' ') if a == 7: break a -= 1&gt;&gt; 10 9 8 7","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"for","slug":"for","permalink":"http://JINUKK.github.io/tags/for/"},{"name":"while","slug":"while","permalink":"http://JINUKK.github.io/tags/while/"},{"name":"comprehension","slug":"comprehension","permalink":"http://JINUKK.github.io/tags/comprehension/"}]},{"title":"boolean","slug":"190305-Python-boolean","date":"2019-03-05T06:29:22.000Z","updated":"2019-06-16T06:32:01.362Z","comments":true,"path":"2019/03/05/190305-Python-boolean/","link":"","permalink":"http://JINUKK.github.io/2019/03/05/190305-Python-boolean/","excerpt":"","text":"Basic 0 이외에 모든 정수가 참이다. 할당할 때는 ‘=’, 비교할 때는 ‘==’123456789101112131415161718192021a = True # 참b = False # 거짓a = 10if a == 10: print('a == 10')&gt;&gt; a == 10# else if = elifif a &gt; 10: print('a &gt; 10')elif a &lt; 10: print('a &lt; 10')else: print('a == 10')&gt;&gt; a == 10a == 10&gt;&gt; Truea &lt; 10&gt;&gt; False python에서 False로 간주하는 객체 False, None, 빈 문자열, 빈 리스트, 빈 튜플, 빈 딕셔너리, 공집합(set()) not을 사용하여 반대 선언 가능1234567891011121314151617li = []if not li: print('True')&gt;&gt; Truetu = ()if not tu: print('True')&gt;&gt; Truedic = &#123;&#125;if not &#123;&#125;: print('True')&gt;&gt; Truenot False&gt;&gt; True","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"boolean","slug":"boolean","permalink":"http://JINUKK.github.io/tags/boolean/"}]},{"title":"dictionary","slug":"190305-Python-dictionary","date":"2019-03-05T06:29:12.000Z","updated":"2019-06-16T06:32:14.626Z","comments":true,"path":"2019/03/05/190305-Python-dictionary/","link":"","permalink":"http://JINUKK.github.io/2019/03/05/190305-Python-dictionary/","excerpt":"","text":"key와 value가 한 쌍 hash로 구현(대응 관계) Basic key:value로 입력 중괄호 사용 1dic = &#123;'a': 1, 'b': 2, 'c': 3&#125; 새로운 값을 삽입 123dic['e'] = 4dic&gt;&gt; &#123;'a': 1, 'b': 2, 'c': 3, 'e': 4&#125; 기존 값 변경이 가능 123dic['a'] = 20dic&gt;&gt; &#123;'a': 20, 'b': 2, 'c': 3, 'e': 4&#125; 변경이 불가능한 객체를 key로 사용 key 값은 변경이 가능한 객체로 사용 불가능(unhashable)123456dic[(1, 2, 3)] = 50dic&gt;&gt; &#123;'a': 20, 'b': 2, 'c': 3, 'e': 4, (1, 2, 3): 50&#125;dic[[5, 6, 'a']] = 60 # 변경이 가능한 객체를 키로 사용 불가능&gt;&gt; TypeError: unhashable type: 'list' 관련 함수들 1dir(dic) 12# dictionary 예시dic = &#123;'a' : 1, 'b' : 2, 'c' : 3&#125; 1) search 계열 - get() : key로 value 얻기 - key가 없는 값을 불러오면 에러가 발생하지만, get()을 사용하면 None을 반환 12345678910111213141516171819202122232425262728293031323334353637dic.get('c')&gt;&gt; 3print(\"dic.get('e') : \", dic.get('e'))&gt;&gt; dic.get('e') : Noneprint(\"dic['e'] : \", dic['e'])&gt;&gt; KeyError: 'e'if dic.get('e'): print(dic['e'])else: print('No data') # dic.get('e') = None이므로 if문이 실행하지 않음&gt;&gt; No datatry: print(dic['e'])except KeyError: print('No data') # try except문을 사용&gt;&gt; No data# key 값이 없을 경우, get(key, default_value)를 사용하여 default 값을 대신 가져옴dic.get('e', 2)&gt;&gt; 2# for문을 사용할 경우, key 값만 가져옴for i in dic: print(i, end = ' ')&gt;&gt; a b c# items()를 사용할 경우, key와 value 모두를 가져옴for pair in dic.items(): print(pair, end = ' ') # tuple 형태&gt;&gt; ('a', 1) ('b', 2) ('c', 3)for key, value in dic.items():print(key, value, end = ' ') # tuple 형태로 가져오지 않음&gt;&gt; a 1 b 2 c 3 2) delete 계열 - pop() : 원하는 key의 value를 반환하고 삭제 - popitems() : 임의의 key와 value를 반환하고 삭제 123456789dic.pop('b')&gt;&gt; 2dic&gt;&gt; &#123;'a': 1, 'c': 3&#125;dic.popitem()&gt;&gt; ('c', 3)dic&gt;&gt; &#123;'a': 1&#125; 3) insert 계열 - update() : key가 있으면 원하는 value로 바꾸고 key가 없으면 추가 - setdefault() : 원하는 key의 value를 찾아 반환 12345678910111213141516171819202122dic = &#123;'a' : 1, 'b' : 2, 'c' : 3&#125;dic.update(&#123;'b':40, 'd':50&#125;)dic&gt;&gt; &#123;'a': 1, 'b': 40, 'c': 3, 'd': 50&#125;# tuple을 사용하면 dictionary 안에서는 key와 value로 넣어줌c = (('e', 11), ('f', 12))dic.update(c)dic&gt;&gt; &#123;'a': 1, 'b': 40, 'c': 3, 'd': 50, 'e': 11, 'f': 12&#125;dic = &#123;'a' : 1, 'b' : 2, 'c' : 3&#125;dic.setdefault('b')&gt;&gt; 2# setdefault()는 key가 없을 경우, default 값으로 새로운 요소 추가dic.setdefault('e', 10)&gt;&gt; 10dic&gt;&gt; &#123;'a': 1, 'b': 2, 'c': 3, 'e': 10&#125; 4) view 객체 사용 12345678910111213141516171819202122232425262728293031323334353637383940414243444546dic = &#123;'a' : 1, 'b' : 2, 'c' : 3&#125;# keys()를 사용하여 key에 관한 view 객체 반환# list 형변환을 사용하여 list로 사용 가능key_view = dic.keys()key_view&gt;&gt; dict_keys(['a', 'b', 'c'])key_list = list(dic.keys())key_list&gt;&gt; ['a', 'b', 'c']# values()를 사용하여 value에 관한 view 객체 반환# list 형변환을 사용하여 list로 사용 가능value_view = dic.values()value_view&gt;&gt; dict_values([1, 2, 3])value_list = list(dic.values())value_list&gt;&gt; [1, 2, 3]# 요소 값을 추가할 경우, view 객체는 변경됨# list 형변환을 통해 대입해준 list 변수는 변하지 않음dic['d'] = 4key_view&gt;&gt; dict_keys(['a', 'b', 'c', 'd'])value_view&gt;&gt; dict_values([1, 2, 3, 4])key_list&gt;&gt; ['a', 'b', 'c']value_list&gt;&gt; [1, 2, 3]# list 형변환을 다시 해줘야 한다.list(dic.keys())&gt;&gt; ['a', 'b', 'c', 'd']# 대입해준 list는 여전히 변하지 않는다.key_list&gt;&gt; ['a', 'b', 'c']dic&gt;&gt; &#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125;","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"dictionary","slug":"dictionary","permalink":"http://JINUKK.github.io/tags/dictionary/"}]},{"title":"tuple","slug":"190304-Python-tuple","date":"2019-03-04T06:13:39.000Z","updated":"2019-06-16T06:17:11.789Z","comments":true,"path":"2019/03/04/190304-Python-tuple/","link":"","permalink":"http://JINUKK.github.io/2019/03/04/190304-Python-tuple/","excerpt":"","text":"python에서 tuple은 변경 불가능한 객체(immutable) 인덱싱으로 접근 가능 요소 값 변경 불가능 list보다 속도가 빠름 Basic 튜플은 소괄호로 선언한다. 1234567tu = (1, 2, 3, 4)tu&gt;&gt; (1, 2, 3, 4)tu2 = ()tu2&gt;&gt; () 인덱싱으로 접근 가능 12tu[2]&gt;&gt; 3 요소 값 변경 불가능 12tu[2] = 5&gt;&gt; TypeError: 'tuple' object does not support item assignment 관련 함수들 1dir(tu)","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"tuple","slug":"tuple","permalink":"http://JINUKK.github.io/tags/tuple/"}]},{"title":"set","slug":"190304-Python-set","date":"2019-03-04T06:13:34.000Z","updated":"2019-06-16T06:16:19.059Z","comments":true,"path":"2019/03/04/190304-Python-set/","link":"","permalink":"http://JINUKK.github.io/2019/03/04/190304-Python-set/","excerpt":"","text":"집합을 표현하기 위해서 만들어진 자료구조 중복의 데이터를 허용하지 않음(집합 표현) Basic list는 중복의 데이터를 허용한다. 123li = [1, 2, 3, 3, 4, 2, 4]li&gt;&gt; [1, 2, 3, 3, 4, 2, 4] set은 중복의 데이터를 허용하지 않는다. 123s = set([1, 2, 3, 3, 4, 2, 4])s&gt;&gt; &#123;1, 2, 3, 4&#125; 문자열을 입력하여 만들 수도 있다. 123string_set = set('abcde')string_set&gt;&gt; &#123;'a', 'b', 'c', 'd', 'e'&#125; 집합 표현 union() : 합집합 ‘OR’ 연산자도 가능 intersection() : 교집합 ‘AND’ 연산자도 가능 difference() : 차집합 ‘-‘ 연산으로도 가능 symmetric_difference() : 대칭 차집합 교집합을 뺀 나머지 ‘XOR’ 연산자도 가능123456789101112131415161718192021222324252627282930313233343536s1 = set([1, 2, 3, 4])s2 = set([3, 4, 5, 6])# 합집합s.union([2, 5, 6])&gt;&gt; &#123;1, 2, 3, 4, 5, 6&#125;s1 | s2 # OR 연산자&gt;&gt; &#123;1, 2, 3, 4, 5, 6&#125;# 교집합s1.intersection(s2)&gt;&gt; &#123;3, 4&#125;s1 &amp; s2 # AND 연산자&gt;&gt; &#123;3, 4&#125;# 차집합s1.difference(s2)&gt;&gt; &#123;1, 2&#125;s1 - s2&gt;&gt; &#123;1, 2&#125;s2 - s1&gt;&gt; &#123;5, 6&#125;# 대칭 차집합s1.symmetric_difference(s2)&gt;&gt; &#123;1, 2, 5, 6&#125;s2.symmetric_difference(s1)&gt;&gt; &#123;1, 2, 5, 6&#125;s1 ^ s2 # XOR 연산자&gt;&gt; &#123;1, 2, 5, 6&#125; 관련 함수들 1dir(set) 1234# set 예시s = &#123;1, 2, 3, 4&#125;s&#123;1, 2, 3, 4&#125; add() : 요소 값 추가 중복의 데이터를 추가하면 들어가지 않는다.1234567s.add(5)s&gt;&gt; &#123;1, 2, 3, 4, 5&#125;s.add(3)s&gt;&gt; &#123;1, 2, 3, 4, 5&#125; update() : 요소 값 여러 개 추가 중복의 데이터는 추가되지 않는다.123s.update([3, 4, 5, 6])s&gt;&gt; &#123;1, 2, 3, 4, 5, 6&#125; remove() : 원하는 요소 값 제거 123s.remove(6)s&gt;&gt; &#123;1, 2, 3, 4, 5&#125; pop() : 임의의 요소 값을 반환한 후, 삭제 1234567891011121314151617help(s.pop) # 임의(arbitrary)의 수 선택&gt;&gt; Help on built-in function pop: pop(...) method of builtins.set instance Remove and return an arbitrary set element. Raises KeyError if the set is empty.s.pop()&gt;&gt; 1s&gt;&gt; &#123;2, 3, 4, 5&#125;s = set([9, 3, 7 ,5, 4])for i in range(3): print(s.pop(), end = \" \")&gt;&gt; 3 4 5 difference() vs difference_update() difference()는 기존 리스트가 바뀌지 않음 difference_update()는 기존 리스트가 바뀜1234567891011s1 = &#123;1, 2, 3, 4, 5&#125;s2 = &#123;3, 5&#125;s1.difference(s2)&gt;&gt; &#123;1, 2, 4&#125; s1&gt;&gt; &#123;1, 2, 3, 4, 5&#125; # 기존 리스트가 바뀌지 않음s1.difference_update(s2)s1&gt;&gt; &#123;1, 2, 4&#125; # 기존 리스트가 바뀜","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"set","slug":"set","permalink":"http://JINUKK.github.io/tags/set/"}]},{"title":"list","slug":"190304-Python-list","date":"2019-03-04T06:13:30.000Z","updated":"2019-06-16T06:15:13.390Z","comments":true,"path":"2019/03/04/190304-Python-list/","link":"","permalink":"http://JINUKK.github.io/2019/03/04/190304-Python-list/","excerpt":"","text":"python에서 list는 변경 가능한 객체(mutable) 자료형에 상관없이 만들 수 있다. Basic C 언어에서의 정의 12// 같은 타입을 가진 변수들의 모임int arr[5] = &#123;1, 2, 3, 4, 5&#125; python에서의 정의 1234# 다양한 변수들의 모임# 타입이 다른 변수들을 묶을 수 있다.# 리스트는 대괄호로 선언한다.li = [1, 0.5, 'abc'] 인덱싱이 가능하다. python에서는 음수 인덱싱이 가능하며, 뒤쪽부터 역순으로 접근한다. 연산도 가능하다. 123456789li = [10, 20, 30, 'a', 'b', 'c']li[2]&gt;&gt; 30li[-1]&gt;&gt; 'c'li*2&gt;&gt; [10, 20, 30, 'a', 'b', 'c', 10, 20, 30, 'a', 'b', 'c'] 슬라이싱도 가능하다([start(포함):end(미포함)]). 123456789101112131415161718192021222324252627282930313233li = [10, 20, 30, 'a', 'b', 'c']li[1:3]&gt;&gt; [20, 30]li[2:4] = [1]li&gt;&gt; [10, 20, 1, 'b', 'c']# 리스트 안에 리스트 넣기li[3] = [2]li&gt;&gt; [10, 20, 1, [2], 'c']li[2:3] = [3]li&gt;&gt; [10, 20, 3, [2], 'c']li[2] = [23]li&gt;&gt; [10, 20, [23], [2], 'c']li[2] = '23'li&gt;&gt; [10, 20, '23', [2], 'c']li[2] = 23li&gt;&gt; [10, 20, 23, [2], 'c']# 범위 안에 나누어서 넣기li[1:3] = '30'li&gt;&gt; [10, '3', '0', [2], 'c'] 관련 함수들 1dir(list) 자료 구조는 크게 3가지로 나눈다. 1) insert(삽입) 2) search(검색) 3) delete(삭제)12# list 예시li = [10, 20, 1, 'b','c'] 1) insert 계열 append() : 리스트 끝에 요소 값 추가 123li.append(100)li&gt;&gt; [10, 20, 1, 'b', 'c', 100] insert() : 원하는 자리를 지정하여 요소 값 추가 123li.insert(2,'a')li&gt;&gt; [10, 20, 'a', 1, 'b', 'c', 100] extend() : 인자를 리스트로 받아 기존 리스트를 확장 123li.extend([1, 2, 3])li&gt;&gt; [10, 20, 'a', 1, 'b', 'c', 100, 1, 2, 3] 2) search 계열 인덱싱 12li[2]&gt;&gt; 'a' index() : 원하는 요소 값의 위치를 반환 12li.index('b')&gt;&gt; 4 3) delete 계열 remove() : 원하는 요소 값 제거 값이 중복될 경우, 첫번째 값만 제거 반복해서 제거 가능123li.remove(1)li&gt;&gt; [10, 20, 'a', 'b', 'c', 100, 1, 2, 3] pop() : 요소 값 가져오기 인자를 넣지 않으면 요소 끝 자리에 있는 값을 가져옴 리스트에서는 삭제12345678li.pop()&gt;&gt; 3li.pop(2)&gt;&gt; 'a'li&gt;&gt; [10, 20, 'b', 'c', 100, 1, 2] 정렬 함수 sort() : 오름차순 정렬 sort(reverse = True) : 내림차순 정렬 sorted(list) : 오름차순 정렬(기존 리스트 차순을 변경하고 싶지 않을 때 사용)123456789101112131415161718192021222324252627import randomli = []for i in range(5): li.append(random.randint(1,10)) # 1부터 10 사이 임의의 정수li&gt;&gt; [4, 5, 8, 5, 9]li.sort()li&gt;&gt; [4, 5, 5, 8, 9]li.sort(reverse = True)li&gt;&gt; [9, 8, 5, 5, 4]li = []for i in range(5): li.append(random.randint(1,10))li&gt;&gt; [5, 8, 7, 10, 1]li_sorted = sorted(li)li_sorted &gt;&gt; [1, 5, 7, 8, 10] # 변경된 리스트li&gt;&gt; [5, 8, 7, 10, 1] # 변경되지 않은 기존 리스트","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"list","slug":"list","permalink":"http://JINUKK.github.io/tags/list/"}]},{"title":"string","slug":"190304-Python-string","date":"2019-03-04T06:04:12.000Z","updated":"2019-06-16T06:11:57.158Z","comments":true,"path":"2019/03/04/190304-Python-string/","link":"","permalink":"http://JINUKK.github.io/2019/03/04/190304-Python-string/","excerpt":"","text":"python에서 문자열은 변경이 불가능한 객체(immutable) Basic python의 문자열은 ‘ ‘ 와 “ “ 모두 사용하며, 같이 사용할 수도 있다. 1234567a = 'abcde'print(a)&gt;&gt; abcdea = \"abcde\"print(a)&gt;&gt; abcde 문자열 안에 ‘와 ‘’를 같이 쓰고 싶은 경우, ‘\\‘와 같이 쓰면 문자 취급을 할 수 있다. 1234567b = \"I said, 'I can do it!'\"print(b)&gt;&gt; I said, 'I can do it!'b = \"I said, \\'I can do it!\\'\"print(b)&gt;&gt; I said, 'I can do it!' “”” “”” 사이에 있는 모든 코드를 다 문자 취급할 수 있다(multi line). 123456789a = \"\"\"hello world!hello world!!hello world!!!\"\"\"print(a)&gt;&gt; hello world! hello world!! hello world!!! 문자열 연산도 가능하다. 1234567a = 'abcd'b = 'efgh'print(a+b)&gt;&gt; abcdefghprint('*'*30)&gt;&gt; ****************************** 문자열 인덱싱 및 길이 출력이 가능하다. 인덱싱 범위가 벗어난 경우, 에러가 발생한다.1234567891011c = \"abcde\"c[0]&gt;&gt; 'a'c[1]&gt;&gt; 'b'c[10]&gt;&gt; IndexError: string index out of rangea = \"abcd\"len(a)&gt;&gt; 4 Slicing(슬라이싱) [start(포함) : end(미포함)]123456789101112a = \"abcdefghijklmnopqrstuvwxyz\"a[1:10]&gt;&gt; 'bcdefghij'a[:10]&gt;&gt; 'abcdefghij'a[6:]&gt;&gt; 'ghijklmnopqrstuvwxyz'a = \"I love python\"a = a[:2] + \"like\" + a[6:]a&gt;&gt; I like python Format(포맷) 형식 12345678910111213141516'I like the number %d and color %s' % (2, 'black') &gt;&gt; 'I like the number 2 and color black'name1 = 'greg'name2 = 'john''hi &#123;1&#125; my name is &#123;0&#125;'.format(name1, name2)&gt;&gt; 'hi john my name is greg''hi &#123;&#125; my name is &#123;&#125;'.format(name1, name2)&gt;&gt; 'hi greg my name is john'# python3.6 이상에서만 지원되는 형식a = 10b = \"abcde\"f'value of a &#123;a&#125; and b is &#123;b&#125;'&gt;&gt; 'value of a 10 and b is abcde' ‘{인덱스:&lt;길이}’.format(값) : 부등호 방향으로 정렬 후, 공백으로 채우기 1234567891011121314'&#123;0:&gt;10&#125;'.format(7)&gt;&gt; ' 7''&#123;0:&gt;1&#125;'.format(7)&gt;&gt; '7''&#123;0:&lt;10&#125;'.format(7)&gt;&gt; '7 ''&#123;:&lt;20&#125;'.format(7)&gt;&gt; '7 'f'&#123;\"koo\":&lt;20&#125;'&gt;&gt; 'koo ' {인덱스:0의 개수.자릿수f}’.format(숫자): 자릿수 지정 가능 12345678910111213import mathmath.e&gt;&gt; 2.718281828459045'&#123;:.2f&#125;'.format(math.e)&gt;&gt; '2.72''&#123;:.5f&#125;'.format(math.e)&gt;&gt; '2.71828'e = math.ef'&#123;e:0.2f&#125;'&gt;&gt; '2.72' 관련 함수들 12# 가지고 있는 함수 보기dir(str) isdigit() : 문자열이 숫자인지 아닌지를 True 또는 False로 반환 123a = '5'a.isdigit()&gt;&gt; True isalpha() : 문자열이 문자인지 아닌지를 True 또는 False로 반환 123a = '5'a.isalpha()&gt;&gt; False count() : 해당 문자 개수 반환 123b = 'abcbbcbbbbabbbcaaabbbbb'b.count('b')&gt;&gt; 15 strip() : 문자열 기준으로 양쪽 공백 지우기 lstrip() : 문자열 기준으로 왼쪽에 있는 공백 지우기 rstrip() : 문자열 기준으로 오른쪽에 있는 공백 지우기 1234567c = ' abc'c.lstrip()&gt;&gt; 'abc'c = 'abc 'c.rstrip()&gt;&gt; 'abc' replace() : 문자열 바꾸기 123d = 'I like python'd.replace('python','C')&gt;&gt; 'I like C' split() : 문자열 나누기 괄호 안에 아무런 값도 넣지 않으면 공백(스페이스, 탭, 엔터 등) 기준으로 나눔 123e = \"koo_2019\"e.split('_')&gt;&gt; ['koo', '2019'] join() : 문자열 삽입 괄호 안에 아무런 값을 넣지 않아도 가능123456li = ['a', 'b', 'c', 'd', 'e']''.join(li)&gt;&gt; 'abcde'':'.join(li)&gt;&gt; 'a:b:c:d:e'","categories":[{"name":"Python","slug":"Python","permalink":"http://JINUKK.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://JINUKK.github.io/tags/python/"},{"name":"string","slug":"string","permalink":"http://JINUKK.github.io/tags/string/"}]},{"title":"2019.03.04 Python and CE Study","slug":"190304-PCE-Study","date":"2019-03-03T15:01:32.000Z","updated":"2019-04-30T08:40:33.250Z","comments":true,"path":"2019/03/04/190304-PCE-Study/","link":"","permalink":"http://JINUKK.github.io/2019/03/04/190304-PCE-Study/","excerpt":"","text":"String python에서 문자열은 변경이 불가능한 객체(immutable) Basic python의 문자열은 ‘ ‘ 와 “ “ 모두 사용하며, 같이 사용할 수도 있다. 1234567a = 'abcde'print(a)&gt;&gt; abcdea = \"abcde\"print(a)&gt;&gt; abcde 문자열 안에 ‘와 ‘’를 같이 쓰고 싶은 경우, ‘\\‘와 같이 쓰면 문자 취급을 할 수 있다. 1234567b = \"I said, 'I can do it!'\"print(b)&gt;&gt; I said, 'I can do it!'b = \"I said, \\'I can do it!\\'\"print(b)&gt;&gt; I said, 'I can do it!' “”” “”” 사이에 있는 모든 코드를 다 문자 취급할 수 있다(multi line). 123456789a = \"\"\"hello world!hello world!!hello world!!!\"\"\"print(a)&gt;&gt; hello world! hello world!! hello world!!! 문자열 연산도 가능하다. 1234567a = 'abcd'b = 'efgh'print(a+b)&gt;&gt; abcdefghprint('*'*30)&gt;&gt; ****************************** 문자열 인덱싱 및 길이 출력이 가능하다. 인덱싱 범위가 벗어난 경우, 에러가 발생한다. 12345678910111213c = \"abcde\"c[0]&gt;&gt; 'a'c[1]&gt;&gt; 'b'c[10]&gt;&gt; IndexError: string index out of rangea = \"abcd\"len(a)&gt;&gt; 4 Slicing(슬라이싱) [start(포함) : end(미포함)] 1234567891011121314a = \"abcdefghijklmnopqrstuvwxyz\"a[1:10]&gt;&gt; 'bcdefghij'a[:10]&gt;&gt; 'abcdefghij'a[6:]&gt;&gt; 'ghijklmnopqrstuvwxyz'a = \"I love python\"a = a[:2] + \"like\" + a[6:]a&gt;&gt; I like python Format(포맷) 형식 12345678910111213141516'I like the number %d and color %s' % (2, 'black') &gt;&gt; 'I like the number 2 and color black'name1 = 'greg'name2 = 'john''hi &#123;1&#125; my name is &#123;0&#125;'.format(name1, name2)&gt;&gt; 'hi john my name is greg''hi &#123;&#125; my name is &#123;&#125;'.format(name1, name2)&gt;&gt; 'hi greg my name is john'# python3.6 이상에서만 지원되는 형식a = 10b = \"abcde\"f'value of a &#123;a&#125; and b is &#123;b&#125;'&gt;&gt; 'value of a 10 and b is abcde' ‘{인덱스:&lt;길이}’.format(값) : 부등호 방향으로 정렬 후, 공백으로 채우기 1234567891011121314'&#123;0:&gt;10&#125;'.format(7)&gt;&gt; ' 7''&#123;0:&gt;1&#125;'.format(7)&gt;&gt; '7''&#123;0:&lt;10&#125;'.format(7)&gt;&gt; '7 ''&#123;:&lt;20&#125;'.format(7)&gt;&gt; '7 'f'&#123;\"koo\":&lt;20&#125;'&gt;&gt; 'koo ' {인덱스:0의 개수.자릿수f}’.format(숫자): 자릿수 지정 가능 12345678910111213import mathmath.e&gt;&gt; 2.718281828459045'&#123;:.2f&#125;'.format(math.e)&gt;&gt; '2.72''&#123;:.5f&#125;'.format(math.e)&gt;&gt; '2.71828'e = math.ef'&#123;e:0.2f&#125;'&gt;&gt; '2.72' 관련 함수들 12# 가지고 있는 함수 보기dir(str) isdigit() : 문자열이 숫자인지 아닌지를 True 또는 False로 반환 123a = '5'a.isdigit()&gt;&gt; True isalpha() : 문자열이 문자인지 아닌지를 True 또는 False로 반환 123a = '5'a.isalpha()&gt;&gt; False count() : 해당 문자 개수 반환 123b = 'abcbbcbbbbabbbcaaabbbbb'b.count('b')&gt;&gt; 15 strip() : 문자열 기준으로 양쪽 공백 지우기 lstrip() : 문자열 기준으로 왼쪽에 있는 공백 지우기 rstrip() : 문자열 기준으로 오른쪽에 있는 공백 지우기 1234567c = ' abc'c.lstrip()&gt;&gt; 'abc'c = 'abc 'c.rstrip()&gt;&gt; 'abc' replace() : 문자열 바꾸기 123d = 'I like python'd.replace('python','C')&gt;&gt; 'I like C' split() : 문자열 나누기 괄호 안에 아무런 값도 넣지 않으면 공백(스페이스, 탭, 엔터 등) 기준으로 나눔 123e = \"koo_2019\"e.split('_')&gt;&gt; ['koo', '2019'] join() : 문자열 삽입 괄호 안에 아무런 값을 넣지 않아도 가능 123456li = ['a', 'b', 'c', 'd', 'e']''.join(li)&gt;&gt; 'abcde'':'.join(li)&gt;&gt; 'a:b:c:d:e' List python에서 list는 변경 가능한 객체(mutable) 자료형에 상관없이 만들 수 있다. Basic C 언어에서의 정의 12// 같은 타입을 가진 변수들의 모임int arr[5] = &#123;1, 2, 3, 4, 5&#125; python에서의 정의 1234# 다양한 변수들의 모임# 타입이 다른 변수들을 묶을 수 있다.# 리스트는 대괄호로 선언한다.li = [1, 0.5, 'abc'] 인덱싱이 가능하다. python에서는 음수 인덱싱이 가능하며, 뒤쪽부터 역순으로 접근한다. 연산도 가능하다. 123456789li = [10, 20, 30, 'a', 'b', 'c']li[2]&gt;&gt; 30li[-1]&gt;&gt; 'c'li*2&gt;&gt; [10, 20, 30, 'a', 'b', 'c', 10, 20, 30, 'a', 'b', 'c'] 슬라이싱도 가능하다([start(포함):end(미포함)]). 12345678910111213141516171819202122232425262728293031323334li = [10, 20, 30, 'a', 'b', 'c']li[1:3]&gt;&gt; [20, 30]li[2:4] = [1]li&gt;&gt; [10, 20, 1, 'b', 'c']# 리스트 안에 리스트 넣기li[3] = [2]li&gt;&gt; [10, 20, 1, [2], 'c']li[2:3] = [3]li&gt;&gt; [10, 20, 3, [2], 'c']li[2] = [23]li&gt;&gt; [10, 20, [23], [2], 'c']li[2] = '23'li&gt;&gt; [10, 20, '23', [2], 'c']li[2] = 23li&gt;&gt; [10, 20, 23, [2], 'c']# 범위 안에 나누어서 넣기li[1:3] = '30'li&gt;&gt; [10, '3', '0', [2], 'c'] 관련 함수들 1dir(list) 자료 구조는 크게 3가지로 나눈다. 1) insert(삽입) 2) search(검색) 3) delete(삭제) 12# list 예시li = [10, 20, 1, 'b','c'] 1) insert 계열 append() : 리스트 끝에 요소 값 추가 123li.append(100)li&gt;&gt; [10, 20, 1, 'b', 'c', 100] insert() : 원하는 자리를 지정하여 요소 값 추가 123li.insert(2,'a')li&gt;&gt; [10, 20, 'a', 1, 'b', 'c', 100] extend() : 인자를 리스트로 받아 기존 리스트를 확장 123li.extend([1, 2, 3])li&gt;&gt; [10, 20, 'a', 1, 'b', 'c', 100, 1, 2, 3] 2) search 계열 인덱싱 12li[2]&gt;&gt; 'a' index() : 원하는 요소 값의 위치를 반환 12li.index('b')&gt;&gt; 4 3) delete 계열 remove() : 원하는 요소 값 제거 값이 중복될 경우, 첫번째 값만 제거 반복해서 제거 가능 123li.remove(1)li&gt;&gt; [10, 20, 'a', 'b', 'c', 100, 1, 2, 3] pop() : 요소 값 가져오기 인자를 넣지 않으면 요소 끝 자리에 있는 값을 가져옴 리스트에서는 삭제 12345678li.pop()&gt;&gt; 3li.pop(2)&gt;&gt; 'a'li&gt;&gt; [10, 20, 'b', 'c', 100, 1, 2] 정렬 함수 sort() : 오름차순 정렬 sort(reverse = True) : 내림차순 정렬 sorted(list) : 오름차순 정렬(기존 리스트 차순을 변경하고 싶지 않을 때 사용) 123456789101112131415161718192021222324252627import randomli = []for i in range(5): li.append(random.randint(1,10)) # 1부터 10 사이 임의의 정수li&gt;&gt; [4, 5, 8, 5, 9]li.sort()li&gt;&gt; [4, 5, 5, 8, 9]li.sort(reverse = True)li&gt;&gt; [9, 8, 5, 5, 4]li = []for i in range(5): li.append(random.randint(1,10))li&gt;&gt; [5, 8, 7, 10, 1]li_sorted = sorted(li)li_sorted &gt;&gt; [1, 5, 7, 8, 10] # 변경된 리스트li&gt;&gt; [5, 8, 7, 10, 1] # 변경되지 않은 기존 리스트 Set 집합을 표현하기 위해서 만들어진 자료구조 중복의 데이터를 허용하지 않음(집합 표현) Basic list는 중복의 데이터를 허용한다. 123li = [1, 2, 3, 3, 4, 2, 4]li&gt;&gt; [1, 2, 3, 3, 4, 2, 4] set은 중복의 데이터를 허용하지 않는다. 123s = set([1, 2, 3, 3, 4, 2, 4])s&gt;&gt; &#123;1, 2, 3, 4&#125; 문자열을 입력하여 만들 수도 있다. 123string_set = set('abcde')string_set&gt;&gt; &#123;'a', 'b', 'c', 'd', 'e'&#125; 집합 표현 union() : 합집합 ‘OR’ 연산자도 가능 intersection() : 교집합 ‘AND’ 연산자도 가능 difference() : 차집합 ‘-‘ 연산으로도 가능 symmetric_difference() : 대칭 차집합 교집합을 뺀 나머지 ‘XOR’ 연산자도 가능 123456789101112131415161718192021222324252627282930313233343536s1 = set([1, 2, 3, 4])s2 = set([3, 4, 5, 6])# 합집합s.union([2, 5, 6])&gt;&gt; &#123;1, 2, 3, 4, 5, 6&#125;s1 | s2 # OR 연산자&gt;&gt; &#123;1, 2, 3, 4, 5, 6&#125;# 교집합s1.intersection(s2)&gt;&gt; &#123;3, 4&#125;s1 &amp; s2 # AND 연산&gt;&gt; &#123;3, 4&#125;# 차집합s1.difference(s2)&gt;&gt; &#123;1, 2&#125;s1 - s2&gt;&gt; &#123;1, 2&#125;s2 - s1&gt;&gt; &#123;5, 6&#125;# 대칭 차집합s1.symmetric_difference(s2)&gt;&gt; &#123;1, 2, 5, 6&#125;s2.symmetric_difference(s1)&gt;&gt; &#123;1, 2, 5, 6&#125;s1 ^ s2 # XOR 연산자&gt;&gt; &#123;1, 2, 5, 6&#125; 관련 함수들 1dir(set) 1234# set 예시s = &#123;1, 2, 3, 4&#125;s&#123;1, 2, 3, 4&#125; add() : 요소 값 추가 중복의 데이터를 추가하면 들어가지 않는다. 1234567s.add(5)s&gt;&gt; &#123;1, 2, 3, 4, 5&#125;s.add(3)s&gt;&gt; &#123;1, 2, 3, 4, 5&#125; update() : 요소 값 여러 개 추가 중복의 데이터는 추가되지 않는다. 123s.update([3, 4, 5, 6])s&gt;&gt; &#123;1, 2, 3, 4, 5, 6&#125; remove() : 원하는 요소 값 제거 123s.remove(6)s&gt;&gt; &#123;1, 2, 3, 4, 5&#125; pop() : 임의의 요소 값을 반환한 후, 삭제 1234567891011121314151617help(s.pop) # 임의(arbitrary)의 수 선택&gt;&gt; Help on built-in function pop: pop(...) method of builtins.set instance Remove and return an arbitrary set element. Raises KeyError if the set is empty.s.pop()&gt;&gt; 1s&gt;&gt; &#123;2, 3, 4, 5&#125;s = set([9, 3, 7 ,5, 4])for i in range(3): print(s.pop(), end = \" \")&gt;&gt; 3 4 5 difference() vs difference_update() difference()는 기존 리스트가 바뀌지 않음 difference_update()는 기존 리스트가 바뀜 123456789101112s1 = &#123;1, 2, 3, 4, 5&#125;s2 = &#123;3, 5&#125;s1.difference(s2)&gt;&gt; &#123;1, 2, 4&#125; s1&gt;&gt; &#123;1, 2, 3, 4, 5&#125; # 기존 리스트가 바뀌지 않음s1.difference_update(s2)s1&gt;&gt; &#123;1, 2, 4&#125; # 기존 리스트가 바뀜 Tuple python에서 tuple은 변경 불가능한 객체(immutable) 인덱싱으로 접근 가능 요소 값 변경 불가능 list보다 속도가 빠름 Basic 튜플은 소괄호로 선언한다. 1234567tu = (1, 2, 3, 4)tu&gt;&gt; (1, 2, 3, 4)tu2 = ()tu2&gt;&gt; () 인덱싱으로 접근 가능 12tu[2]&gt;&gt; 3 요소 값 변경 불가능 12tu[2] = 5&gt;&gt; TypeError: 'tuple' object does not support item assignment 관련 함수들 1dir(tu)","categories":[{"name":"Study Review","slug":"Study-Review","permalink":"http://JINUKK.github.io/categories/Study-Review/"}],"tags":[]}]}